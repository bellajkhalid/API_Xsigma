# Data Processing and Calibration

## Overview

Cette section décrit les procédures de traitement des données et de calibration spécifiques au modèle **FX LSV Markov Switching PDE**, incluant les sources de données FX, les méthodes de calibration PDE et la validation des paramètres.

## FX Market Data Processing

### Data Sources and Validation

#### Primary FX Data Sources
```cpp
// Gestionnaire de données FX pour calibration PDE
namespace xsigma::fx_data {
    
    class FXMarketDataProcessor {
    public:
        struct FXDataSources {
            std::string spot_data_provider;      // "BLOOMBERG", "REUTERS", "ECB"
            std::string volatility_data_provider; // Source de volatilités implicites
            std::string rates_data_provider;     // Source de taux d'intérêt
            std::string historical_data_provider; // Données historiques
            
            // Configuration de qualité
            double max_staleness_minutes;        // Fraîcheur maximale des données
            double max_bid_ask_spread_pct;       // Spread bid-ask maximal acceptable
            bool require_triangular_consistency; // Exiger cohérence triangulaire
            double triangular_tolerance;         // Tolérance pour arbitrage triangulaire
        };
        
        struct FXMarketSnapshot {
            std::string timestamp;
            std::map<std::string, double> spot_rates;        // Taux de change spot
            std::map<std::string, double> forward_points;    // Points de terme
            std::map<std::string, VolatilitySurface> vol_surfaces; // Surfaces de volatilité
            std::map<std::string, YieldCurve> yield_curves;  // Courbes de taux
            
            // Métriques de qualité
            std::map<std::string, double> bid_ask_spreads;   // Spreads bid-ask
            std::map<std::string, double> data_confidence;   // Score de confiance
            std::vector<std::string> data_warnings;          // Avertissements qualité
        };
        
        // Chargement et validation des données FX
        FXMarketSnapshot load_and_validate_fx_data(
            const std::string& currency_pair,
            const FXDataSources& sources) {
            
            FXMarketSnapshot snapshot;
            snapshot.timestamp = get_current_timestamp();
            
            try {
                // Chargement des taux spot
                snapshot.spot_rates = load_spot_rates(currency_pair, sources);
                
                // Validation de cohérence triangulaire
                if (sources.require_triangular_consistency) {
                    validate_triangular_arbitrage(snapshot.spot_rates, sources.triangular_tolerance);
                }
                
                // Chargement des surfaces de volatilité
                snapshot.vol_surfaces = load_volatility_surfaces(currency_pair, sources);
                
                // Validation des surfaces de volatilité
                for (auto& [pair, surface] : snapshot.vol_surfaces) {
                    validate_volatility_surface(surface, pair);
                }
                
                // Chargement des courbes de taux
                snapshot.yield_curves = load_yield_curves(currency_pair, sources);
                
                // Calcul des métriques de qualité
                calculate_data_quality_metrics(snapshot);
                
                XSIGMA_LOG_INFO("Données FX chargées et validées pour " + currency_pair);
                
            } catch (const std::exception& e) {
                XSIGMA_LOG_ERROR("Erreur lors du chargement des données FX: " + std::string(e.what()));
                throw;
            }
            
            return snapshot;
        }
        
        // Structure pour surface de volatilité FX
        struct VolatilitySurface {
            std::vector<double> strikes;         // Strikes
            std::vector<double> maturities;      // Maturités
            std::vector<std::vector<double>> volatilities; // Matrice de volatilités
            std::string interpolation_method;    // Méthode d'interpolation
            double atm_volatility;               // Volatilité ATM
            double risk_reversal_25d;            // Risk reversal 25-delta
            double butterfly_25d;                // Butterfly 25-delta
        };
        
        // Validation de surface de volatilité
        void validate_volatility_surface(VolatilitySurface& surface, 
                                        const std::string& currency_pair) {
            
            // Vérification d'absence d'arbitrage
            if (!check_calendar_arbitrage(surface)) {
                XSIGMA_LOG_WARNING("Arbitrage calendaire détecté pour " + currency_pair);
                surface = smooth_volatility_surface(surface);
            }
            
            if (!check_butterfly_arbitrage(surface)) {
                XSIGMA_LOG_WARNING("Arbitrage butterfly détecté pour " + currency_pair);
                surface = adjust_butterfly_arbitrage(surface);
            }
            
            // Vérification de smoothness
            double smoothness_score = calculate_surface_smoothness(surface);
            if (smoothness_score < 0.8) {
                XSIGMA_LOG_WARNING("Surface de volatilité non lisse pour " + currency_pair + 
                                  ", score: " + std::to_string(smoothness_score));
                surface = apply_smoothing_filter(surface);
            }
        }
        
    private:
        std::map<std::string, double> load_spot_rates(
            const std::string& currency_pair, const FXDataSources& sources) {
            
            std::map<std::string, double> rates;
            
            // Chargement depuis le provider principal
            if (sources.spot_data_provider == "BLOOMBERG") {
                rates = load_from_bloomberg_spot(currency_pair);
            } else if (sources.spot_data_provider == "REUTERS") {
                rates = load_from_reuters_spot(currency_pair);
            } else if (sources.spot_data_provider == "ECB") {
                rates = load_from_ecb_spot(currency_pair);
            }
            
            // Validation de fraîcheur
            validate_data_freshness(rates, sources.max_staleness_minutes);
            
            return rates;
        }
        
        std::map<std::string, VolatilitySurface> load_volatility_surfaces(
            const std::string& currency_pair, const FXDataSources& sources) {
            
            std::map<std::string, VolatilitySurface> surfaces;
            
            // Chargement des volatilités implicites
            auto implied_vols = load_implied_volatilities(currency_pair, sources);
            
            // Construction des surfaces
            for (const auto& [pair, vol_data] : implied_vols) {
                VolatilitySurface surface;
                surface.strikes = vol_data.strikes;
                surface.maturities = vol_data.maturities;
                surface.volatilities = vol_data.vol_matrix;
                surface.interpolation_method = "CUBIC_SPLINE";
                
                // Calcul des métriques de marché
                surface.atm_volatility = calculate_atm_volatility(vol_data);
                surface.risk_reversal_25d = calculate_risk_reversal_25d(vol_data);
                surface.butterfly_25d = calculate_butterfly_25d(vol_data);
                
                surfaces[pair] = surface;
            }
            
            return surfaces;
        }
        
        std::map<std::string, YieldCurve> load_yield_curves(
            const std::string& currency_pair, const FXDataSources& sources) {
            
            std::map<std::string, YieldCurve> curves;
            
            // Extraction des devises
            std::string base_currency = currency_pair.substr(0, 3);
            std::string quote_currency = currency_pair.substr(3, 3);
            
            // Chargement des courbes de taux
            curves[base_currency] = load_yield_curve_for_currency(base_currency, sources);
            curves[quote_currency] = load_yield_curve_for_currency(quote_currency, sources);
            
            return curves;
        }
        
        void validate_triangular_arbitrage(
            const std::map<std::string, double>& rates, double tolerance) {
            
            // Vérification de cohérence triangulaire pour toutes les combinaisons
            for (const auto& [pair1, rate1] : rates) {
                for (const auto& [pair2, rate2] : rates) {
                    for (const auto& [pair3, rate3] : rates) {
                        
                        if (forms_triangular_relationship(pair1, pair2, pair3)) {
                            double implied_rate = calculate_implied_rate(rate1, rate2);
                            double arbitrage_opportunity = std::abs(implied_rate - rate3) / rate3;
                            
                            if (arbitrage_opportunity > tolerance) {
                                XSIGMA_THROW("Arbitrage triangulaire détecté: " + 
                                            pair1 + "/" + pair2 + "/" + pair3 + 
                                            ", opportunité: " + std::to_string(arbitrage_opportunity));
                            }
                        }
                    }
                }
            }
        }
        
        bool check_calendar_arbitrage(const VolatilitySurface& surface) {
            // Vérification que les volatilités totales sont croissantes avec la maturité
            for (size_t strike_idx = 0; strike_idx < surface.strikes.size(); ++strike_idx) {
                for (size_t mat_idx = 1; mat_idx < surface.maturities.size(); ++mat_idx) {
                    
                    double vol_short = surface.volatilities[strike_idx][mat_idx - 1];
                    double vol_long = surface.volatilities[strike_idx][mat_idx];
                    double mat_short = surface.maturities[mat_idx - 1];
                    double mat_long = surface.maturities[mat_idx];
                    
                    double total_var_short = vol_short * vol_short * mat_short;
                    double total_var_long = vol_long * vol_long * mat_long;
                    
                    if (total_var_long < total_var_short) {
                        return false; // Arbitrage calendaire détecté
                    }
                }
            }
            return true;
        }
        
        bool check_butterfly_arbitrage(const VolatilitySurface& surface) {
            // Vérification de convexité du smile pour chaque maturité
            for (size_t mat_idx = 0; mat_idx < surface.maturities.size(); ++mat_idx) {
                for (size_t strike_idx = 1; strike_idx < surface.strikes.size() - 1; ++strike_idx) {
                    
                    double k_low = surface.strikes[strike_idx - 1];
                    double k_mid = surface.strikes[strike_idx];
                    double k_high = surface.strikes[strike_idx + 1];
                    
                    double vol_low = surface.volatilities[strike_idx - 1][mat_idx];
                    double vol_mid = surface.volatilities[strike_idx][mat_idx];
                    double vol_high = surface.volatilities[strike_idx + 1][mat_idx];
                    
                    // Test de convexité approximatif
                    double expected_vol = vol_low + (vol_high - vol_low) * 
                                         (k_mid - k_low) / (k_high - k_low);
                    
                    if (vol_mid < expected_vol - 0.01) { // Tolérance de 1%
                        return false; // Arbitrage butterfly détecté
                    }
                }
            }
            return true;
        }
        
        double calculate_surface_smoothness(const VolatilitySurface& surface) {
            // Calcul d'un score de lissage basé sur les dérivées secondes
            double smoothness_score = 1.0;
            
            // Calcul des dérivées secondes en strike et maturité
            for (size_t i = 1; i < surface.strikes.size() - 1; ++i) {
                for (size_t j = 1; j < surface.maturities.size() - 1; ++j) {
                    
                    // Dérivée seconde en strike
                    double d2_dk2 = (surface.volatilities[i+1][j] - 2*surface.volatilities[i][j] + 
                                    surface.volatilities[i-1][j]) / 
                                   ((surface.strikes[i+1] - surface.strikes[i]) * 
                                    (surface.strikes[i] - surface.strikes[i-1]));
                    
                    // Dérivée seconde en maturité
                    double d2_dt2 = (surface.volatilities[i][j+1] - 2*surface.volatilities[i][j] + 
                                    surface.volatilities[i][j-1]) / 
                                   ((surface.maturities[j+1] - surface.maturities[j]) * 
                                    (surface.maturities[j] - surface.maturities[j-1]));
                    
                    // Pénalité pour dérivées secondes importantes
                    smoothness_score *= std::exp(-0.1 * (std::abs(d2_dk2) + std::abs(d2_dt2)));
                }
            }
            
            return smoothness_score;
        }
        
        // Méthodes utilitaires (placeholders)
        std::map<std::string, double> load_from_bloomberg_spot(const std::string& pair) {
            return {{"EURUSD", 1.1000}}; // Placeholder
        }
        
        std::map<std::string, double> load_from_reuters_spot(const std::string& pair) {
            return {{"EURUSD", 1.1000}}; // Placeholder
        }
        
        std::map<std::string, double> load_from_ecb_spot(const std::string& pair) {
            return {{"EURUSD", 1.1000}}; // Placeholder
        }
        
        void validate_data_freshness(const std::map<std::string, double>& rates, 
                                    double max_staleness_minutes) {
            // Validation de fraîcheur des données
        }
        
        struct ImpliedVolData {
            std::vector<double> strikes;
            std::vector<double> maturities;
            std::vector<std::vector<double>> vol_matrix;
        };
        
        std::map<std::string, ImpliedVolData> load_implied_volatilities(
            const std::string& pair, const FXDataSources& sources) {
            return {}; // Placeholder
        }
        
        struct YieldCurve {
            std::vector<double> maturities;
            std::vector<double> rates;
            std::string interpolation_method;
        };
        
        YieldCurve load_yield_curve_for_currency(const std::string& currency, 
                                                const FXDataSources& sources) {
            return {}; // Placeholder
        }
        
        bool forms_triangular_relationship(const std::string& p1, 
                                         const std::string& p2, 
                                         const std::string& p3) {
            return true; // Placeholder
        }
        
        double calculate_implied_rate(double rate1, double rate2) {
            return rate1 * rate2; // Placeholder
        }
        
        double calculate_atm_volatility(const ImpliedVolData& data) {
            return 0.12; // Placeholder
        }
        
        double calculate_risk_reversal_25d(const ImpliedVolData& data) {
            return 0.01; // Placeholder
        }
        
        double calculate_butterfly_25d(const ImpliedVolData& data) {
            return 0.005; // Placeholder
        }
        
        VolatilitySurface smooth_volatility_surface(const VolatilitySurface& surface) {
            return surface; // Placeholder
        }
        
        VolatilitySurface adjust_butterfly_arbitrage(const VolatilitySurface& surface) {
            return surface; // Placeholder
        }
        
        VolatilitySurface apply_smoothing_filter(const VolatilitySurface& surface) {
            return surface; // Placeholder
        }
        
        void calculate_data_quality_metrics(FXMarketSnapshot& snapshot) {
            // Calcul des métriques de qualité
        }
        
        std::string get_current_timestamp() {
            return "2024-01-15T10:30:00Z"; // Placeholder
        }
    };
}
```

## PDE Calibration Framework

### Local Volatility Calibration via PDE

#### Dupire Equation for FX
```cpp
// Calibration de volatilité locale via équation de Dupire FX
class FXLocalVolatilityCalibrator {
public:
    struct DupireCalibrationResult {
        std::vector<std::vector<double>> local_vol_surface; // Surface de vol locale
        double calibration_rmse;                            // RMSE de calibration
        double max_calibration_error;                       // Erreur maximale
        bool convergence_achieved;                          // Convergence atteinte
        int iterations_used;                                // Itérations utilisées
        std::vector<std::string> calibration_warnings;     // Avertissements
    };
    
    // Calibration via équation de Dupire adaptée FX
    DupireCalibrationResult calibrate_fx_local_volatility(
        const VolatilitySurface& market_surface,
        const std::string& currency_pair,
        double domestic_rate,
        double foreign_rate) {
        
        DupireCalibrationResult result;
        
        try {
            // Application de l'équation de Dupire FX
            // σ_LV²(K,T) = (2∂C/∂T + (r_d-r_f)K∂C/∂K) / (K²∂²C/∂K²)
            
            // Calcul des prix d'options vanilles sur la grille
            auto option_prices = calculate_vanilla_prices_grid(
                market_surface, domestic_rate, foreign_rate);
            
            // Calcul des dérivées partielles
            auto derivatives = calculate_price_derivatives(option_prices);
            
            // Application de la formule de Dupire
            result.local_vol_surface = apply_dupire_formula_fx(
                derivatives, domestic_rate, foreign_rate);
            
            // Validation et lissage si nécessaire
            result.local_vol_surface = validate_and_smooth_local_vol(
                result.local_vol_surface, market_surface);
            
            // Calcul des métriques de qualité
            auto validation_prices = calculate_validation_prices(result.local_vol_surface);
            result.calibration_rmse = calculate_rmse(option_prices, validation_prices);
            result.max_calibration_error = calculate_max_error(option_prices, validation_prices);
            
            result.convergence_achieved = (result.calibration_rmse < 0.01 && 
                                         result.max_calibration_error < 0.03);
            
            XSIGMA_LOG_INFO("Calibration volatilité locale FX terminée pour " + currency_pair + 
                           ", RMSE: " + std::to_string(result.calibration_rmse));
            
        } catch (const std::exception& e) {
            XSIGMA_LOG_ERROR("Erreur lors de la calibration vol locale FX: " + std::string(e.what()));
            result.convergence_achieved = false;
            throw;
        }
        
        return result;
    }
    
private:
    struct OptionPricesGrid {
        std::vector<double> strikes;
        std::vector<double> maturities;
        std::vector<std::vector<double>> call_prices;
        std::vector<std::vector<double>> put_prices;
    };
    
    OptionPricesGrid calculate_vanilla_prices_grid(
        const VolatilitySurface& surface,
        double r_d, double r_f) {
        
        OptionPricesGrid prices;
        prices.strikes = surface.strikes;
        prices.maturities = surface.maturities;
        
        // Calcul des prix via Garman-Kohlhagen
        for (size_t i = 0; i < surface.strikes.size(); ++i) {
            std::vector<double> call_row, put_row;
            
            for (size_t j = 0; j < surface.maturities.size(); ++j) {
                double K = surface.strikes[i];
                double T = surface.maturities[j];
                double sigma = surface.volatilities[i][j];
                
                // Prix Garman-Kohlhagen
                auto gk_prices = calculate_garman_kohlhagen_prices(K, T, sigma, r_d, r_f);
                call_row.push_back(gk_prices.call_price);
                put_row.push_back(gk_prices.put_price);
            }
            
            prices.call_prices.push_back(call_row);
            prices.put_prices.push_back(put_row);
        }
        
        return prices;
    }
    
    struct PriceDerivatives {
        std::vector<std::vector<double>> dC_dT;    // ∂C/∂T
        std::vector<std::vector<double>> dC_dK;    // ∂C/∂K
        std::vector<std::vector<double>> d2C_dK2;  // ∂²C/∂K²
    };
    
    PriceDerivatives calculate_price_derivatives(const OptionPricesGrid& prices) {
        PriceDerivatives derivatives;
        
        // Calcul des dérivées par différences finies
        derivatives.dC_dT = calculate_time_derivatives(prices);
        derivatives.dC_dK = calculate_strike_derivatives(prices);
        derivatives.d2C_dK2 = calculate_second_strike_derivatives(prices);
        
        return derivatives;
    }
    
    std::vector<std::vector<double>> apply_dupire_formula_fx(
        const PriceDerivatives& derivatives,
        double r_d, double r_f) {
        
        std::vector<std::vector<double>> local_vol_surface;
        
        for (size_t i = 0; i < derivatives.dC_dT.size(); ++i) {
            std::vector<double> vol_row;
            
            for (size_t j = 0; j < derivatives.dC_dT[i].size(); ++j) {
                
                double dC_dT = derivatives.dC_dT[i][j];
                double dC_dK = derivatives.dC_dK[i][j];
                double d2C_dK2 = derivatives.d2C_dK2[i][j];
                
                // Formule de Dupire FX
                double numerator = 2 * dC_dT + (r_d - r_f) * dC_dK;
                double denominator = d2C_dK2;
                
                if (std::abs(denominator) > 1e-10) {
                    double local_vol_squared = numerator / denominator;
                    double local_vol = std::sqrt(std::max(local_vol_squared, 1e-6));
                    vol_row.push_back(local_vol);
                } else {
                    // Extrapolation si dénominateur trop petit
                    double extrapolated_vol = extrapolate_local_vol(i, j, local_vol_surface);
                    vol_row.push_back(extrapolated_vol);
                }
            }
            
            local_vol_surface.push_back(vol_row);
        }
        
        return local_vol_surface;
    }
    
    // Méthodes utilitaires (placeholders)
    struct GKPrices {
        double call_price;
        double put_price;
    };
    
    GKPrices calculate_garman_kohlhagen_prices(double K, double T, double sigma, 
                                              double r_d, double r_f) {
        // Calcul Garman-Kohlhagen
        return {0.05, 0.03}; // Placeholder
    }
    
    std::vector<std::vector<double>> calculate_time_derivatives(const OptionPricesGrid& prices) {
        return {}; // Placeholder
    }
    
    std::vector<std::vector<double>> calculate_strike_derivatives(const OptionPricesGrid& prices) {
        return {}; // Placeholder
    }
    
    std::vector<std::vector<double>> calculate_second_strike_derivatives(const OptionPricesGrid& prices) {
        return {}; // Placeholder
    }
    
    std::vector<std::vector<double>> validate_and_smooth_local_vol(
        const std::vector<std::vector<double>>& local_vol,
        const VolatilitySurface& market_surface) {
        return local_vol; // Placeholder
    }
    
    std::vector<std::vector<double>> calculate_validation_prices(
        const std::vector<std::vector<double>>& local_vol) {
        return {}; // Placeholder
    }
    
    double calculate_rmse(const OptionPricesGrid& market, 
                         const std::vector<std::vector<double>>& model) {
        return 0.005; // Placeholder
    }
    
    double calculate_max_error(const OptionPricesGrid& market,
                              const std::vector<std::vector<double>>& model) {
        return 0.02; // Placeholder
    }
    
    double extrapolate_local_vol(size_t i, size_t j, 
                                const std::vector<std::vector<double>>& surface) {
        return 0.15; // Placeholder
    }
};
```

### Markov Switching Parameters Calibration

#### HMM Parameter Estimation
```cpp
// Calibration des paramètres Markov Switching via EM
class FXMarkovSwitchingCalibrator {
public:
    struct MarkovCalibrationResult {
        int optimal_number_of_states;
        std::vector<double> state_volatilities;
        std::vector<std::vector<double>> transition_rate_matrix;
        std::vector<double> initial_state_probabilities;
        double log_likelihood;
        bool convergence_achieved;
        std::vector<double> state_sequence;
    };
    
    // Calibration via algorithme EM (Baum-Welch)
    MarkovCalibrationResult calibrate_markov_switching_parameters(
        const std::vector<double>& fx_returns,
        const std::vector<double>& realized_volatilities,
        int max_states = 5) {
        
        MarkovCalibrationResult result;
        
        // Sélection du nombre optimal d'états
        result.optimal_number_of_states = select_optimal_number_of_states(
            fx_returns, realized_volatilities, max_states);
        
        // Estimation des paramètres via EM
        auto em_result = estimate_hmm_parameters(
            fx_returns, realized_volatilities, result.optimal_number_of_states);
        
        result.state_volatilities = em_result.state_volatilities;
        result.transition_rate_matrix = convert_to_rate_matrix(em_result.transition_probabilities);
        result.initial_state_probabilities = em_result.initial_probabilities;
        result.log_likelihood = em_result.log_likelihood;
        result.convergence_achieved = em_result.converged;
        result.state_sequence = em_result.most_likely_states;
        
        return result;
    }
    
private:
    int select_optimal_number_of_states(
        const std::vector<double>& returns,
        const std::vector<double>& volatilities,
        int max_states) {
        
        std::vector<double> aic_scores;
        std::vector<double> bic_scores;
        
        for (int n_states = 2; n_states <= max_states; ++n_states) {
            auto hmm_fit = fit_hmm_with_n_states(returns, volatilities, n_states);
            
            int n_params = n_states * n_states + n_states; // Transitions + états
            double aic = -2 * hmm_fit.log_likelihood + 2 * n_params;
            double bic = -2 * hmm_fit.log_likelihood + n_params * std::log(returns.size());
            
            aic_scores.push_back(aic);
            bic_scores.push_back(bic);
        }
        
        // Sélection basée sur BIC (plus conservateur)
        auto min_bic_it = std::min_element(bic_scores.begin(), bic_scores.end());
        return 2 + std::distance(bic_scores.begin(), min_bic_it);
    }
    
    struct HMMEstimationResult {
        std::vector<double> state_volatilities;
        std::vector<std::vector<double>> transition_probabilities;
        std::vector<double> initial_probabilities;
        std::vector<double> most_likely_states;
        double log_likelihood;
        bool converged;
    };
    
    HMMEstimationResult estimate_hmm_parameters(
        const std::vector<double>& observations,
        const std::vector<double>& volatilities,
        int n_states) {
        
        HMMEstimationResult result;
        
        // Initialisation des paramètres
        initialize_hmm_parameters(result, n_states);
        
        // Algorithme EM
        double prev_log_likelihood = -std::numeric_limits<double>::infinity();
        int max_iterations = 100;
        double tolerance = 1e-6;
        
        for (int iter = 0; iter < max_iterations; ++iter) {
            // E-step: Forward-Backward
            auto fb_result = forward_backward_algorithm(observations, result);
            
            // M-step: Mise à jour des paramètres
            update_hmm_parameters(result, observations, fb_result);
            
            // Test de convergence
            double log_likelihood_improvement = fb_result.log_likelihood - prev_log_likelihood;
            if (log_likelihood_improvement < tolerance) {
                result.converged = true;
                result.log_likelihood = fb_result.log_likelihood;
                break;
            }
            
            prev_log_likelihood = fb_result.log_likelihood;
        }
        
        // Décodage de Viterbi pour séquence d'états la plus probable
        result.most_likely_states = viterbi_decoding(observations, result);
        
        return result;
    }
    
    void initialize_hmm_parameters(HMMEstimationResult& result, int n_states) {
        // Initialisation des volatilités d'état (croissantes)
        result.state_volatilities.resize(n_states);
        for (int i = 0; i < n_states; ++i) {
            result.state_volatilities[i] = 0.5 + 0.5 * i; // 0.5, 1.0, 1.5, ...
        }
        
        // Initialisation des probabilités de transition (persistance élevée)
        result.transition_probabilities.resize(n_states, std::vector<double>(n_states));
        for (int i = 0; i < n_states; ++i) {
            for (int j = 0; j < n_states; ++j) {
                if (i == j) {
                    result.transition_probabilities[i][j] = 0.9; // Persistance
                } else {
                    result.transition_probabilities[i][j] = 0.1 / (n_states - 1);
                }
            }
        }
        
        // Probabilités initiales uniformes
        result.initial_probabilities.resize(n_states, 1.0 / n_states);
    }
    
    struct ForwardBackwardResult {
        std::vector<std::vector<double>> forward_probabilities;
        std::vector<std::vector<double>> backward_probabilities;
        std::vector<std::vector<double>> state_probabilities;
        double log_likelihood;
    };
    
    ForwardBackwardResult forward_backward_algorithm(
        const std::vector<double>& observations,
        const HMMEstimationResult& params) {
        
        ForwardBackwardResult result;
        int T = observations.size();
        int N = params.state_volatilities.size();
        
        // Initialisation
        result.forward_probabilities.resize(T, std::vector<double>(N));
        result.backward_probabilities.resize(T, std::vector<double>(N));
        result.state_probabilities.resize(T, std::vector<double>(N));
        
        // Forward pass
        for (int t = 0; t < T; ++t) {
            for (int i = 0; i < N; ++i) {
                if (t == 0) {
                    result.forward_probabilities[t][i] = 
                        params.initial_probabilities[i] * 
                        emission_probability(observations[t], i, params);
                } else {
                    double sum = 0.0;
                    for (int j = 0; j < N; ++j) {
                        sum += result.forward_probabilities[t-1][j] * 
                               params.transition_probabilities[j][i];
                    }
                    result.forward_probabilities[t][i] = sum * 
                        emission_probability(observations[t], i, params);
                }
            }
        }
        
        // Backward pass
        for (int t = T - 1; t >= 0; --t) {
            for (int i = 0; i < N; ++i) {
                if (t == T - 1) {
                    result.backward_probabilities[t][i] = 1.0;
                } else {
                    double sum = 0.0;
                    for (int j = 0; j < N; ++j) {
                        sum += params.transition_probabilities[i][j] * 
                               emission_probability(observations[t+1], j, params) * 
                               result.backward_probabilities[t+1][j];
                    }
                    result.backward_probabilities[t][i] = sum;
                }
            }
        }
        
        // Calcul des probabilités d'état
        for (int t = 0; t < T; ++t) {
            double normalizer = 0.0;
            for (int i = 0; i < N; ++i) {
                result.state_probabilities[t][i] = 
                    result.forward_probabilities[t][i] * result.backward_probabilities[t][i];
                normalizer += result.state_probabilities[t][i];
            }
            
            // Normalisation
            for (int i = 0; i < N; ++i) {
                result.state_probabilities[t][i] /= normalizer;
            }
        }
        
        // Calcul de la log-vraisemblance
        result.log_likelihood = 0.0;
        for (int t = 0; t < T; ++t) {
            double sum = 0.0;
            for (int i = 0; i < N; ++i) {
                sum += result.forward_probabilities[t][i];
            }
            result.log_likelihood += std::log(sum);
        }
        
        return result;
    }
    
    double emission_probability(double observation, int state, 
                               const HMMEstimationResult& params) {
        // Probabilité d'émission gaussienne
        double state_vol = params.state_volatilities[state];
        double variance = state_vol * state_vol;
        
        return (1.0 / std::sqrt(2 * M_PI * variance)) * 
               std::exp(-0.5 * observation * observation / variance);
    }
    
    void update_hmm_parameters(HMMEstimationResult& result,
                              const std::vector<double>& observations,
                              const ForwardBackwardResult& fb_result) {
        
        int T = observations.size();
        int N = result.state_volatilities.size();
        
        // Mise à jour des probabilités initiales
        for (int i = 0; i < N; ++i) {
            result.initial_probabilities[i] = fb_result.state_probabilities[0][i];
        }
        
        // Mise à jour des probabilités de transition
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < N; ++j) {
                double numerator = 0.0;
                double denominator = 0.0;
                
                for (int t = 0; t < T - 1; ++t) {
                    double xi = result.forward_probabilities[t][i] * 
                               result.transition_probabilities[i][j] * 
                               emission_probability(observations[t+1], j, result) * 
                               fb_result.backward_probabilities[t+1][j];
                    
                    numerator += xi;
                    denominator += fb_result.state_probabilities[t][i];
                }
                
                result.transition_probabilities[i][j] = numerator / denominator;
            }
        }
        
        // Mise à jour des volatilités d'état
        for (int i = 0; i < N; ++i) {
            double weighted_sum = 0.0;
            double weight_sum = 0.0;
            
            for (int t = 0; t < T; ++t) {
                double weight = fb_result.state_probabilities[t][i];
                weighted_sum += weight * observations[t] * observations[t];
                weight_sum += weight;
            }
            
            result.state_volatilities[i] = std::sqrt(weighted_sum / weight_sum);
        }
    }
    
    std::vector<double> viterbi_decoding(const std::vector<double>& observations,
                                        const HMMEstimationResult& params) {
        // Algorithme de Viterbi pour décodage optimal
        std::vector<double> state_sequence;
        // Implémentation complète nécessaire
        return state_sequence;
    }
    
    std::vector<std::vector<double>> convert_to_rate_matrix(
        const std::vector<std::vector<double>>& transition_probs) {
        
        // Conversion des probabilités de transition en taux de transition
        std::vector<std::vector<double>> rate_matrix;
        // Implémentation nécessaire
        return rate_matrix;
    }
    
    HMMEstimationResult fit_hmm_with_n_states(
        const std::vector<double>& returns,
        const std::vector<double>& volatilities,
        int n_states) {
        
        return estimate_hmm_parameters(returns, volatilities, n_states);
    }
};
```

Le framework de traitement des données et calibration FX LSV Markov Switching PDE dans Our project assure une calibration robuste et précise avec validation complète de la qualité des données FX et des paramètres du modèle via méthodes PDE spécialisées.
