# Model Assumptions

## Overview

Cette section décrit les hypothèses fondamentales du modèle **FX LSV Markov Switching PDE**, incluant les assumptions mathématiques, les hypothèses de marché et les limitations conceptuelles.

## Mathematical Assumptions

### Fundamental PDE Framework

#### Garman-Kohlhagen Extended PDE
Le modèle étend l'équation de Garman-Kohlhagen avec volatilité complexe :

$$\frac{\partial V}{\partial t} + (r_d - r_f)S\frac{\partial V}{\partial S} + \frac{1}{2}\sigma_{eff}^2(S,t,V,\zeta)S^2\frac{\partial^2 V}{\partial S^2} + \kappa(\theta - V)\frac{\partial V}{\partial V} + \frac{1}{2}\nu^2 V\frac{\partial^2 V}{\partial V^2} + \rho\nu\sigma_{eff}SV\frac{\partial^2 V}{\partial S \partial V} - r_d V = 0$$

#### Multi-State PDE System
Système d'EDPs couplées pour les états Markov :

$$\frac{\partial V_i}{\partial t} + \mathcal{L}_i V_i + \sum_{j \neq i} \lambda_{ij}(V_j - V_i) = 0$$

où $\mathcal{L}_i$ est l'opérateur différentiel pour l'état $i$.

### Stochastic Process Assumptions

#### FX Spot Dynamics
```cpp
// Dynamique du taux de change sous mesure risk-neutral
namespace xsigma::assumptions {
    
    class FXSpotDynamicsAssumptions {
    public:
        // Hypothèse 1: Dynamique log-normale avec drift FX
        struct LogNormalDriftAssumption {
            // dS_t = (r_d - r_f) S_t dt + σ_eff(S_t,t,V_t,ζ_t) S_t dW_t^S
            
            bool continuous_trading;           // Trading continu sans friction
            bool no_transaction_costs;         // Pas de coûts de transaction
            bool perfect_liquidity;            // Liquidité parfaite
            bool no_bid_ask_spread;           // Pas de spread bid-ask
            
            // Validation de l'hypothèse
            bool validate_assumption(const FXMarketData& market_data) const {
                // Vérification de la log-normalité des rendements
                auto returns = calculate_fx_returns(market_data);
                auto normality_test = perform_jarque_bera_test(returns);
                
                // Test de stationnarité du drift
                auto drift_stationarity = test_drift_stationarity(returns);
                
                return normality_test.p_value > 0.05 && drift_stationarity.is_stationary;
            }
        };
        
        // Hypothèse 2: Absence d'arbitrage triangulaire
        struct TriangularArbitrageAssumption {
            // Pour trois devises A, B, C: S_AC = S_AB × S_BC
            
            double tolerance;                  // Tolérance pour violations
            
            bool validate_triangular_consistency(
                const std::map<std::string, double>& fx_rates) const {
                
                // Vérification de cohérence triangulaire
                for (const auto& [pair1, rate1] : fx_rates) {
                    for (const auto& [pair2, rate2] : fx_rates) {
                        for (const auto& [pair3, rate3] : fx_rates) {
                            
                            if (forms_triangle(pair1, pair2, pair3)) {
                                double implied_rate = rate1 * rate2;
                                double market_rate = rate3;
                                
                                double arbitrage_opportunity = 
                                    std::abs(implied_rate - market_rate) / market_rate;
                                
                                if (arbitrage_opportunity > tolerance) {
                                    XSIGMA_LOG_WARNING("Arbitrage triangulaire détecté: " + 
                                                      std::to_string(arbitrage_opportunity));
                                    return false;
                                }
                            }
                        }
                    }
                }
                return true;
            }
            
        private:
            bool forms_triangle(const std::string& pair1, 
                              const std::string& pair2, 
                              const std::string& pair3) const {
                // Vérification si trois paires forment un triangle
                return true; // Implémentation simplifiée
            }
        };
    };
}
```

#### Variance Process Assumptions
```cpp
// Hypothèses sur le processus de variance
class VarianceProcessAssumptions {
public:
    // Hypothèse 3: Processus CIR pour la variance
    struct CIRProcessAssumption {
        // dV_t = κ(θ - V_t)dt + ν√V_t dW_t^V
        
        double kappa;                      // Vitesse de retour à la moyenne
        double theta;                      // Variance long terme
        double nu;                         // Vol of vol
        double correlation;                // Corrélation spot-variance
        
        // Condition de Feller pour éviter zéro
        bool feller_condition_satisfied() const {
            return 2 * kappa * theta >= nu * nu;
        }
        
        // Test de la condition de Feller
        bool validate_feller_condition() const {
            if (!feller_condition_satisfied()) {
                XSIGMA_LOG_WARNING("Condition de Feller violée: 2κθ = " + 
                                  std::to_string(2 * kappa * theta) + 
                                  " < ν² = " + std::to_string(nu * nu));
                return false;
            }
            return true;
        }
        
        // Validation empirique du processus CIR
        bool validate_cir_dynamics(const std::vector<double>& variance_history) const {
            // Test de mean reversion
            auto mean_reversion_test = test_mean_reversion(variance_history, kappa, theta);
            
            // Test de la relation variance-volatilité
            auto variance_vol_test = test_variance_volatility_relationship(variance_history, nu);
            
            return mean_reversion_test.is_significant && variance_vol_test.is_consistent;
        }
        
    private:
        struct MeanReversionTest {
            bool is_significant;
            double half_life;
            double r_squared;
        };
        
        MeanReversionTest test_mean_reversion(
            const std::vector<double>& variance_data,
            double kappa_param, double theta_param) const {
            
            MeanReversionTest result;
            
            // Régression: ΔV_t = κ(θ - V_{t-1})Δt + ε_t
            std::vector<double> delta_v;
            std::vector<double> lagged_v;
            
            for (size_t i = 1; i < variance_data.size(); ++i) {
                delta_v.push_back(variance_data[i] - variance_data[i-1]);
                lagged_v.push_back(theta_param - variance_data[i-1]);
            }
            
            // Calcul de la régression linéaire
            auto regression_result = perform_linear_regression(delta_v, lagged_v);
            
            result.is_significant = regression_result.p_value < 0.05;
            result.half_life = std::log(2) / kappa_param;
            result.r_squared = regression_result.r_squared;
            
            return result;
        }
        
        struct VarianceVolatilityTest {
            bool is_consistent;
            double estimated_nu;
            double confidence_interval;
        };
        
        VarianceVolatilityTest test_variance_volatility_relationship(
            const std::vector<double>& variance_data, double nu_param) const {
            
            VarianceVolatilityTest result;
            
            // Test de la relation: Var(ΔV) ∝ ν²V
            std::vector<double> variance_changes;
            std::vector<double> variance_levels;
            
            for (size_t i = 1; i < variance_data.size(); ++i) {
                double delta_v = variance_data[i] - variance_data[i-1];
                variance_changes.push_back(delta_v * delta_v);
                variance_levels.push_back(variance_data[i-1]);
            }
            
            // Régression: Var(ΔV) = α + β*V + ε
            auto regression = perform_linear_regression(variance_changes, variance_levels);
            
            result.estimated_nu = std::sqrt(regression.slope);
            result.is_consistent = std::abs(result.estimated_nu - nu_param) / nu_param < 0.2;
            result.confidence_interval = regression.confidence_interval;
            
            return result;
        }
        
        struct RegressionResult {
            double slope;
            double intercept;
            double r_squared;
            double p_value;
            double confidence_interval;
        };
        
        RegressionResult perform_linear_regression(
            const std::vector<double>& y, const std::vector<double>& x) const {
            
            RegressionResult result;
            
            // Calcul de régression linéaire simple
            double n = static_cast<double>(x.size());
            double sum_x = std::accumulate(x.begin(), x.end(), 0.0);
            double sum_y = std::accumulate(y.begin(), y.end(), 0.0);
            double sum_xy = 0.0, sum_xx = 0.0, sum_yy = 0.0;
            
            for (size_t i = 0; i < x.size(); ++i) {
                sum_xy += x[i] * y[i];
                sum_xx += x[i] * x[i];
                sum_yy += y[i] * y[i];
            }
            
            result.slope = (n * sum_xy - sum_x * sum_y) / (n * sum_xx - sum_x * sum_x);
            result.intercept = (sum_y - result.slope * sum_x) / n;
            
            // R²
            double ss_tot = sum_yy - sum_y * sum_y / n;
            double ss_res = 0.0;
            for (size_t i = 0; i < x.size(); ++i) {
                double predicted = result.intercept + result.slope * x[i];
                ss_res += (y[i] - predicted) * (y[i] - predicted);
            }
            result.r_squared = 1.0 - ss_res / ss_tot;
            
            // P-value (approximation)
            result.p_value = calculate_p_value(result.slope, ss_res, n);
            result.confidence_interval = calculate_confidence_interval(ss_res, n);
            
            return result;
        }
        
        double calculate_p_value(double slope, double ss_res, double n) const {
            // Calcul approximatif de p-value
            return 0.01; // Placeholder
        }
        
        double calculate_confidence_interval(double ss_res, double n) const {
            // Calcul d'intervalle de confiance
            return 0.05; // Placeholder
        }
    };
};
```

### Markov Switching Assumptions

#### Discrete State Assumption
```cpp
// Hypothèses sur les états Markov discrets
class MarkovSwitchingAssumptions {
public:
    // Hypothèse 4: États de volatilité discrets
    struct DiscreteStateAssumption {
        int number_of_states;              // Nombre d'états (typiquement 3)
        std::vector<double> state_volatilities; // Volatilités par état
        std::vector<std::vector<double>> transition_rates; // Taux de transition
        
        // Validation du nombre optimal d'états
        bool validate_optimal_number_of_states(
            const std::vector<double>& volatility_history) const {
            
            // Test de sélection de modèle via critères d'information
            std::vector<double> aic_scores;
            std::vector<double> bic_scores;
            
            for (int n_states = 2; n_states <= 6; ++n_states) {
                auto hmm_result = fit_hmm_model(volatility_history, n_states);
                
                int n_params = n_states * n_states + n_states; // Transitions + états
                double aic = -2 * hmm_result.log_likelihood + 2 * n_params;
                double bic = -2 * hmm_result.log_likelihood + 
                           n_params * std::log(volatility_history.size());
                
                aic_scores.push_back(aic);
                bic_scores.push_back(bic);
            }
            
            // Sélection du nombre d'états minimisant BIC
            auto min_bic_it = std::min_element(bic_scores.begin(), bic_scores.end());
            int optimal_states = 2 + std::distance(bic_scores.begin(), min_bic_it);
            
            return optimal_states == number_of_states;
        }
        
        // Validation de la matrice de transition
        bool validate_transition_matrix() const {
            // Vérification que les lignes somment à zéro (générateur infinitésimal)
            for (int i = 0; i < number_of_states; ++i) {
                double row_sum = 0.0;
                for (int j = 0; j < number_of_states; ++j) {
                    row_sum += transition_rates[i][j];
                }
                
                if (std::abs(row_sum) > 1e-10) {
                    XSIGMA_LOG_ERROR("Ligne " + std::to_string(i) + 
                                    " de la matrice de transition ne somme pas à zéro: " + 
                                    std::to_string(row_sum));
                    return false;
                }
            }
            
            // Vérification que les éléments diagonaux sont négatifs
            for (int i = 0; i < number_of_states; ++i) {
                if (transition_rates[i][i] >= 0.0) {
                    XSIGMA_LOG_ERROR("Élément diagonal " + std::to_string(i) + 
                                    " doit être négatif: " + 
                                    std::to_string(transition_rates[i][i]));
                    return false;
                }
            }
            
            // Vérification que les éléments hors-diagonale sont positifs
            for (int i = 0; i < number_of_states; ++i) {
                for (int j = 0; j < number_of_states; ++j) {
                    if (i != j && transition_rates[i][j] < 0.0) {
                        XSIGMA_LOG_ERROR("Élément hors-diagonal (" + 
                                        std::to_string(i) + "," + std::to_string(j) + 
                                        ") doit être positif: " + 
                                        std::to_string(transition_rates[i][j]));
                        return false;
                    }
                }
            }
            
            return true;
        }
        
    private:
        struct HMMResult {
            double log_likelihood;
            std::vector<double> state_probabilities;
            bool converged;
        };
        
        HMMResult fit_hmm_model(const std::vector<double>& data, int n_states) const {
            HMMResult result;
            
            // Algorithme EM pour estimation HMM
            // Implémentation simplifiée
            result.log_likelihood = -1000.0; // Placeholder
            result.converged = true;
            
            return result;
        }
    };
};
```

## Market Assumptions

### FX Market Structure

#### Perfect Market Assumption
- **Continuous Trading** : Marché ouvert 24h/24, 5j/7
- **Perfect Liquidity** : Exécution instantanée à prix de marché
- **No Transaction Costs** : Absence de coûts de transaction
- **No Bid-Ask Spreads** : Prix unique pour achat et vente

#### Interest Rate Assumptions
- **Constant Rates** : Taux domestique et étranger constants
- **Flat Yield Curves** : Courbes de taux plates
- **No Credit Risk** : Absence de risque de crédit
- **Perfect Collateralization** : Collatéralisation parfaite

### Regulatory and Operational Assumptions

#### Settlement Assumptions
- **T+2 Settlement** : Règlement standard à T+2
- **No Settlement Risk** : Absence de risque de règlement
- **Perfect Clearing** : Compensation parfaite
- **No Counterparty Risk** : Absence de risque de contrepartie

#### Data Assumptions
- **Real-Time Data** : Données de marché en temps réel
- **Perfect Data Quality** : Données sans erreur
- **Complete Market Data** : Couverture complète des instruments
- **Consistent Pricing** : Cohérence entre sources de données

## PDE-Specific Assumptions

### Numerical Assumptions

#### Grid Assumptions
- **Sufficient Grid Density** : Grille suffisamment fine pour convergence
- **Appropriate Boundaries** : Frontières suffisamment éloignées
- **Smooth Solutions** : Solutions suffisamment régulières
- **Stability Conditions** : Respect des conditions CFL

#### Solver Assumptions
- **Convergence** : Convergence garantie du solveur
- **Numerical Stability** : Stabilité numérique des schémas
- **Round-off Error Control** : Contrôle des erreurs d'arrondi
- **Iterative Convergence** : Convergence des méthodes itératives

### Boundary Condition Assumptions

#### Far-Field Behavior
- **Asymptotic Behavior** : Comportement asymptotique connu
- **Linear Growth** : Croissance linéaire aux frontières
- **Smooth Extrapolation** : Extrapolation lisse possible
- **No Boundary Effects** : Pas d'effets de bord significatifs

## Model Limitations

### Theoretical Limitations

#### Single-Asset Limitation
- **No Multi-Asset** : Limité aux produits single-asset
- **No Correlation Products** : Pas de produits de corrélation
- **No Basket Options** : Options sur panier non supportées
- **No Cross-Currency Swaps** : Swaps cross-currency limités

#### Volatility Model Limitations
- **Discrete States Only** : Pas de volatilité continue
- **Fixed Number of States** : Nombre d'états fixe
- **Constant Transitions** : Taux de transition constants
- **No Regime Prediction** : Pas de prédiction de régimes

### Practical Limitations

#### Computational Limitations
- **Grid Size Constraints** : Limitations de taille de grille
- **Memory Requirements** : Besoins mémoire importants
- **Computation Time** : Temps de calcul significatif
- **Parallel Scaling** : Limitations de parallélisation

#### Market Data Limitations
- **Data Quality Dependence** : Dépendance à la qualité des données
- **Calibration Frequency** : Fréquence de recalibration limitée
- **Market Stress Periods** : Performance dégradée en stress
- **Illiquid Markets** : Limitations pour marchés illiquides

## Assumption Validation Framework

### Continuous Monitoring
- **Statistical Tests** : Tests statistiques réguliers
- **Model Diagnostics** : Diagnostics de modèle automatisés
- **Performance Tracking** : Suivi de performance continu
- **Assumption Breach Alerts** : Alertes de violation d'hypothèses

### Remedial Actions
- **Parameter Adjustment** : Ajustement des paramètres
- **Model Recalibration** : Recalibration du modèle
- **Alternative Models** : Basculement vers modèles alternatifs
- **Risk Limit Adjustment** : Ajustement des limites de risque

Les hypothèses du modèle FX LSV Markov Switching PDE dans Our project sont rigoureusement définies et continuellement validées pour assurer la robustesse et la fiabilité du modèle en environnement de production.
