# Implementation / Numerical Schema Description

## Overview

Cette section décrit l'implémentation numérique du modèle **Local Volatility PDE and MC**, incluant les schémas de discrétisation PDE, les algorithmes Monte Carlo optimisés et le framework de sélection hybride.

## PDE Numerical Implementation

### Finite Difference Schemes

#### Spatial Discretization
```cpp
// Implémentation Our project des schémas de discrétisation PDE
namespace xsigma::local_vol_pde_implementation {
    
    class LocalVolatilityPDESolver {
    public:
        enum class SpatialScheme {
            CENTRAL_DIFFERENCE,      // Différences centrées
            UPWIND,                  // Schéma upwind
            WEIGHTED_UPWIND,         // Upwind pondéré
            HIGH_ORDER_COMPACT       // Différences compactes haute précision
        };
        
        enum class TimeScheme {
            EXPLICIT_EULER,          // Euler explicite
            IMPLICIT_EULER,          // Euler implicite
            CRANK_NICOLSON,          // Crank-Nicolson
            RUNGE_KUTTA_4,           // Runge-Kutta ordre 4
            ADAPTIVE_TIME_STEPPING   // Pas de temps adaptatif
        };
        
        struct PDEDiscretizationParameters {
            SpatialScheme spatial_scheme;
            TimeScheme time_scheme;
            
            // Grille spatiale
            int num_spot_points;
            double spot_min;
            double spot_max;
            bool use_adaptive_grid;
            double grid_concentration_factor;
            
            // Grille temporelle
            int num_time_steps;
            double max_time_step;
            bool use_adaptive_time_stepping;
            
            // Paramètres de stabilité
            double cfl_safety_factor;
            double theta_implicitness;  // 0=explicite, 0.5=Crank-Nicolson, 1=implicite
            
            // Conditions aux limites
            std::string lower_boundary_condition;  // "DIRICHLET", "NEUMANN", "ROBIN"
            std::string upper_boundary_condition;
            double lower_boundary_value;
            double upper_boundary_value;
        };
        
        // Construction de la grille spatiale adaptative
        std::vector<double> build_adaptive_spatial_grid(
            const PDEDiscretizationParameters& params,
            const LocalVolatilitySurface& lv_surface,
            double current_spot) {
            
            std::vector<double> grid_points;
            
            if (!params.use_adaptive_grid) {
                // Grille uniforme
                return build_uniform_grid(params.spot_min, params.spot_max, params.num_spot_points);
            }
            
            // Grille adaptative avec concentration autour du spot et des points critiques
            std::vector<double> concentration_points;
            concentration_points.push_back(current_spot);
            
            // Ajout de points de concentration basés sur la volatilité locale
            auto critical_points = identify_critical_volatility_points(lv_surface);
            concentration_points.insert(concentration_points.end(), 
                                      critical_points.begin(), critical_points.end());
            
            // Tri et suppression des doublons
            std::sort(concentration_points.begin(), concentration_points.end());
            concentration_points.erase(
                std::unique(concentration_points.begin(), concentration_points.end()),
                concentration_points.end());
            
            // Construction de la grille avec concentration
            grid_points = build_concentrated_grid(
                params.spot_min, params.spot_max, params.num_spot_points,
                concentration_points, params.grid_concentration_factor);
            
            return grid_points;
        }
        
        // Construction de la matrice de discrétisation
        Eigen::SparseMatrix<double> build_discretization_matrix(
            const PDEDiscretizationParameters& params,
            const LocalVolatilitySurface& lv_surface,
            const std::vector<double>& spatial_grid,
            double current_time) {
            
            int n = spatial_grid.size();
            Eigen::SparseMatrix<double> matrix(n, n);
            std::vector<Eigen::Triplet<double>> triplets;
            
            // Construction des coefficients pour chaque point de grille
            for (int i = 1; i < n - 1; ++i) {
                double S = spatial_grid[i];
                double h_minus = spatial_grid[i] - spatial_grid[i-1];
                double h_plus = spatial_grid[i+1] - spatial_grid[i];
                double h_avg = (h_plus + h_minus) / 2.0;
                
                // Interpolation de la volatilité locale
                double local_vol = interpolate_local_volatility(lv_surface, S, current_time);
                
                // Coefficients de l'EDP : ∂V/∂t + ½σ²S²∂²V/∂S² + rS∂V/∂S - rV = 0
                double diffusion_coeff = 0.5 * local_vol * local_vol * S * S;
                double convection_coeff = lv_surface.risk_free_rate * S;
                double reaction_coeff = -lv_surface.risk_free_rate;
                
                // Application du schéma spatial
                if (params.spatial_scheme == SpatialScheme::CENTRAL_DIFFERENCE) {
                    // Terme de diffusion (∂²V/∂S²)
                    double diff_coeff_minus = diffusion_coeff / (h_minus * h_avg);
                    double diff_coeff_plus = diffusion_coeff / (h_plus * h_avg);
                    double diff_coeff_center = -(diff_coeff_minus + diff_coeff_plus);
                    
                    triplets.emplace_back(i, i-1, diff_coeff_minus);
                    triplets.emplace_back(i, i, diff_coeff_center);
                    triplets.emplace_back(i, i+1, diff_coeff_plus);
                    
                    // Terme de convection (∂V/∂S)
                    double conv_coeff_minus = -convection_coeff / (2.0 * h_avg);
                    double conv_coeff_plus = convection_coeff / (2.0 * h_avg);
                    
                    triplets.emplace_back(i, i-1, conv_coeff_minus);
                    triplets.emplace_back(i, i+1, conv_coeff_plus);
                    
                } else if (params.spatial_scheme == SpatialScheme::UPWIND) {
                    // Schéma upwind pour la convection
                    apply_upwind_scheme(triplets, i, spatial_grid, diffusion_coeff, 
                                      convection_coeff, lv_surface.risk_free_rate);
                }
                
                // Terme de réaction
                triplets.emplace_back(i, i, reaction_coeff);
            }
            
            // Conditions aux limites
            apply_boundary_conditions(triplets, params, spatial_grid, n);
            
            matrix.setFromTriplets(triplets.begin(), triplets.end());
            return matrix;
        }
        
        // Résolution temporelle avec schéma adaptatif
        std::vector<std::vector<double>> solve_time_evolution(
            const PDEDiscretizationParameters& params,
            const LocalVolatilitySurface& lv_surface,
            const std::vector<double>& spatial_grid,
            const std::vector<double>& initial_condition,
            double maturity) {
            
            std::vector<std::vector<double>> solution_history;
            std::vector<double> current_solution = initial_condition;
            solution_history.push_back(current_solution);
            
            double current_time = 0.0;
            double dt = maturity / params.num_time_steps;
            
            while (current_time < maturity) {
                // Ajustement du pas de temps si adaptatif
                if (params.use_adaptive_time_stepping) {
                    dt = calculate_adaptive_time_step(params, lv_surface, spatial_grid, 
                                                    current_solution, current_time);
                }
                
                // Assurer qu'on n'dépasse pas la maturité
                dt = std::min(dt, maturity - current_time);
                
                // Construction de la matrice pour ce pas de temps
                auto matrix = build_discretization_matrix(params, lv_surface, spatial_grid, current_time);
                
                // Application du schéma temporel
                if (params.time_scheme == TimeScheme::IMPLICIT_EULER) {
                    current_solution = solve_implicit_euler_step(matrix, current_solution, dt);
                } else if (params.time_scheme == TimeScheme::CRANK_NICOLSON) {
                    current_solution = solve_crank_nicolson_step(matrix, current_solution, dt, params.theta_implicitness);
                } else if (params.time_scheme == TimeScheme::RUNGE_KUTTA_4) {
                    current_solution = solve_runge_kutta_4_step(matrix, current_solution, dt);
                }
                
                current_time += dt;
                solution_history.push_back(current_solution);
            }
            
            return solution_history;
        }
        
    private:
        std::vector<double> build_uniform_grid(double min_val, double max_val, int num_points) {
            std::vector<double> grid;
            double step = (max_val - min_val) / (num_points - 1);
            
            for (int i = 0; i < num_points; ++i) {
                grid.push_back(min_val + i * step);
            }
            return grid;
        }
        
        std::vector<double> identify_critical_volatility_points(const LocalVolatilitySurface& surface) {
            std::vector<double> critical_points;
            
            // Identification des points où la volatilité locale varie rapidement
            for (size_t i = 1; i < surface.strikes.size() - 1; ++i) {
                double vol_gradient = std::abs(surface.local_vol_matrix[i+1][0] - surface.local_vol_matrix[i-1][0]);
                if (vol_gradient > 0.05) { // Seuil de variation significative
                    critical_points.push_back(surface.strikes[i]);
                }
            }
            
            return critical_points;
        }
        
        std::vector<double> build_concentrated_grid(
            double min_val, double max_val, int num_points,
            const std::vector<double>& concentration_points,
            double concentration_factor) {
            
            std::vector<double> grid;
            
            // Construction d'une grille avec concentration autour des points critiques
            // Implémentation simplifiée
            return build_uniform_grid(min_val, max_val, num_points);
        }
        
        double interpolate_local_volatility(const LocalVolatilitySurface& surface,
                                           double spot, double time) {
            // Interpolation bilinéaire de la volatilité locale
            
            // Localisation dans la grille
            auto strike_it = std::lower_bound(surface.strikes.begin(), surface.strikes.end(), spot);
            auto time_it = std::lower_bound(surface.maturities.begin(), surface.maturities.end(), time);
            
            if (strike_it == surface.strikes.end() || time_it == surface.maturities.end()) {
                return 0.20; // Valeur par défaut
            }
            
            size_t i = std::distance(surface.strikes.begin(), strike_it);
            size_t j = std::distance(surface.maturities.begin(), time_it);
            
            // Interpolation bilinéaire simplifiée
            if (i < surface.local_vol_matrix.size() && j < surface.local_vol_matrix[i].size()) {
                return surface.local_vol_matrix[i][j];
            }
            
            return 0.20; // Valeur par défaut
        }
        
        void apply_upwind_scheme(std::vector<Eigen::Triplet<double>>& triplets,
                                int i, const std::vector<double>& grid,
                                double diffusion_coeff, double convection_coeff, double rate) {
            // Implémentation du schéma upwind
            double h = grid[i+1] - grid[i];
            
            // Terme de diffusion
            triplets.emplace_back(i, i-1, diffusion_coeff / (h * h));
            triplets.emplace_back(i, i, -2.0 * diffusion_coeff / (h * h));
            triplets.emplace_back(i, i+1, diffusion_coeff / (h * h));
            
            // Terme de convection upwind
            if (convection_coeff > 0) {
                triplets.emplace_back(i, i-1, -convection_coeff / h);
                triplets.emplace_back(i, i, convection_coeff / h);
            } else {
                triplets.emplace_back(i, i, -convection_coeff / h);
                triplets.emplace_back(i, i+1, convection_coeff / h);
            }
        }
        
        void apply_boundary_conditions(std::vector<Eigen::Triplet<double>>& triplets,
                                      const PDEDiscretizationParameters& params,
                                      const std::vector<double>& grid, int n) {
            // Condition aux limites inférieure
            if (params.lower_boundary_condition == "DIRICHLET") {
                triplets.emplace_back(0, 0, 1.0);
            } else if (params.lower_boundary_condition == "NEUMANN") {
                double h = grid[1] - grid[0];
                triplets.emplace_back(0, 0, -1.0 / h);
                triplets.emplace_back(0, 1, 1.0 / h);
            }
            
            // Condition aux limites supérieure
            if (params.upper_boundary_condition == "DIRICHLET") {
                triplets.emplace_back(n-1, n-1, 1.0);
            } else if (params.upper_boundary_condition == "NEUMANN") {
                double h = grid[n-1] - grid[n-2];
                triplets.emplace_back(n-1, n-2, -1.0 / h);
                triplets.emplace_back(n-1, n-1, 1.0 / h);
            }
        }
        
        double calculate_adaptive_time_step(const PDEDiscretizationParameters& params,
                                           const LocalVolatilitySurface& surface,
                                           const std::vector<double>& grid,
                                           const std::vector<double>& solution,
                                           double current_time) {
            // Calcul du pas de temps adaptatif basé sur la condition CFL
            double min_dt = std::numeric_limits<double>::max();
            
            for (size_t i = 1; i < grid.size() - 1; ++i) {
                double S = grid[i];
                double h = grid[i+1] - grid[i-1];
                double local_vol = interpolate_local_volatility(surface, S, current_time);
                
                // Condition CFL : dt ≤ h²/(σ²S²)
                double cfl_dt = params.cfl_safety_factor * h * h / (local_vol * local_vol * S * S);
                min_dt = std::min(min_dt, cfl_dt);
            }
            
            return std::min(min_dt, params.max_time_step);
        }
        
        std::vector<double> solve_implicit_euler_step(
            const Eigen::SparseMatrix<double>& matrix,
            const std::vector<double>& current_solution,
            double dt) {
            
            // Système : (I - dt*A)V^{n+1} = V^n
            Eigen::SparseMatrix<double> system_matrix = 
                Eigen::SparseMatrix<double>(matrix.rows(), matrix.cols());
            system_matrix.setIdentity();
            system_matrix -= dt * matrix;
            
            // Conversion en vecteurs Eigen
            Eigen::VectorXd rhs = Eigen::Map<const Eigen::VectorXd>(
                current_solution.data(), current_solution.size());
            
            // Résolution du système linéaire
            Eigen::SparseLU<Eigen::SparseMatrix<double>> solver;
            solver.compute(system_matrix);
            Eigen::VectorXd solution = solver.solve(rhs);
            
            // Conversion de retour
            std::vector<double> result(solution.data(), solution.data() + solution.size());
            return result;
        }
        
        std::vector<double> solve_crank_nicolson_step(
            const Eigen::SparseMatrix<double>& matrix,
            const std::vector<double>& current_solution,
            double dt, double theta) {
            
            // Système : (I - θ*dt*A)V^{n+1} = (I + (1-θ)*dt*A)V^n
            Eigen::SparseMatrix<double> lhs_matrix = 
                Eigen::SparseMatrix<double>(matrix.rows(), matrix.cols());
            lhs_matrix.setIdentity();
            lhs_matrix -= theta * dt * matrix;
            
            Eigen::SparseMatrix<double> rhs_matrix = 
                Eigen::SparseMatrix<double>(matrix.rows(), matrix.cols());
            rhs_matrix.setIdentity();
            rhs_matrix += (1.0 - theta) * dt * matrix;
            
            // Calcul du RHS
            Eigen::VectorXd current_vec = Eigen::Map<const Eigen::VectorXd>(
                current_solution.data(), current_solution.size());
            Eigen::VectorXd rhs = rhs_matrix * current_vec;
            
            // Résolution
            Eigen::SparseLU<Eigen::SparseMatrix<double>> solver;
            solver.compute(lhs_matrix);
            Eigen::VectorXd solution = solver.solve(rhs);
            
            std::vector<double> result(solution.data(), solution.data() + solution.size());
            return result;
        }
        
        std::vector<double> solve_runge_kutta_4_step(
            const Eigen::SparseMatrix<double>& matrix,
            const std::vector<double>& current_solution,
            double dt) {
            
            // Implémentation RK4 pour EDPs (plus complexe)
            // Simplification : retour à Euler explicite
            Eigen::VectorXd current_vec = Eigen::Map<const Eigen::VectorXd>(
                current_solution.data(), current_solution.size());
            Eigen::VectorXd derivative = matrix * current_vec;
            Eigen::VectorXd next_solution = current_vec + dt * derivative;
            
            std::vector<double> result(next_solution.data(), 
                                     next_solution.data() + next_solution.size());
            return result;
        }
    };
}
```

## Monte Carlo Implementation

### Path Generation with Local Volatility

#### Optimized Path Generator
```cpp
// Générateur de chemins Monte Carlo optimisé pour volatilité locale
class LocalVolatilityMCPathGenerator {
public:
    struct MCParameters {
        int num_paths;                      // Nombre de chemins
        int num_time_steps;                 // Pas de temps
        std::string random_generator;       // "MERSENNE_TWISTER", "SOBOL", "HALTON"
        bool use_antithetic_variates;       // Variables antithétiques
        bool use_control_variates;          // Variables de contrôle
        bool use_importance_sampling;       // Échantillonnage d'importance
        double time_step_adjustment_factor; // Facteur d'ajustement du pas de temps
    };
    
    // Génération de chemins avec volatilité locale
    std::vector<std::vector<double>> generate_local_volatility_paths(
        const LocalVolatilitySurface& lv_surface,
        const MCParameters& mc_params,
        double maturity) {
        
        std::vector<std::vector<double>> paths;
        paths.reserve(mc_params.num_paths);
        
        // Initialisation du générateur aléatoire
        auto rng = initialize_random_generator(mc_params.random_generator);
        
        // Grille temporelle
        double dt = maturity / mc_params.num_time_steps;
        std::vector<double> time_grid = build_time_grid(maturity, mc_params.num_time_steps);
        
        // Génération des chemins
        for (int path = 0; path < mc_params.num_paths; ++path) {
            auto single_path = generate_single_path(lv_surface, time_grid, dt, rng);
            paths.push_back(single_path);
            
            // Variables antithétiques si activées
            if (mc_params.use_antithetic_variates && path < mc_params.num_paths - 1) {
                auto antithetic_path = generate_antithetic_path(lv_surface, time_grid, dt, rng);
                paths.push_back(antithetic_path);
                path++; // Incrément supplémentaire pour les variables antithétiques
            }
        }
        
        return paths;
    }
    
private:
    std::vector<double> generate_single_path(
        const LocalVolatilitySurface& surface,
        const std::vector<double>& time_grid,
        double dt, std::mt19937& rng) {
        
        std::vector<double> path;
        path.reserve(time_grid.size());
        
        double current_spot = surface.spot_price;
        path.push_back(current_spot);
        
        std::normal_distribution<double> normal_dist(0.0, 1.0);
        
        for (size_t i = 1; i < time_grid.size(); ++i) {
            double current_time = time_grid[i-1];
            
            // Interpolation de la volatilité locale
            double local_vol = interpolate_local_volatility(surface, current_spot, current_time);
            
            // Génération du bruit gaussien
            double dW = normal_dist(rng) * std::sqrt(dt);
            
            // Évolution du spot : dS = (r-q)S dt + σ_LV(S,t)S dW
            double drift = (surface.risk_free_rate - surface.dividend_yield) * current_spot * dt;
            double diffusion = local_vol * current_spot * dW;
            
            current_spot += drift + diffusion;
            
            // Assurer que le spot reste positif
            current_spot = std::max(current_spot, 1e-6);
            
            path.push_back(current_spot);
        }
        
        return path;
    }
    
    std::vector<double> generate_antithetic_path(
        const LocalVolatilitySurface& surface,
        const std::vector<double>& time_grid,
        double dt, std::mt19937& rng) {
        
        // Génération du chemin antithétique (même logique mais avec -dW)
        std::vector<double> path;
        path.reserve(time_grid.size());
        
        double current_spot = surface.spot_price;
        path.push_back(current_spot);
        
        std::normal_distribution<double> normal_dist(0.0, 1.0);
        
        for (size_t i = 1; i < time_grid.size(); ++i) {
            double current_time = time_grid[i-1];
            double local_vol = interpolate_local_volatility(surface, current_spot, current_time);
            
            // Bruit antithétique
            double dW = -normal_dist(rng) * std::sqrt(dt);
            
            double drift = (surface.risk_free_rate - surface.dividend_yield) * current_spot * dt;
            double diffusion = local_vol * current_spot * dW;
            
            current_spot += drift + diffusion;
            current_spot = std::max(current_spot, 1e-6);
            
            path.push_back(current_spot);
        }
        
        return path;
    }
    
    std::mt19937 initialize_random_generator(const std::string& generator_type) {
        if (generator_type == "MERSENNE_TWISTER") {
            return std::mt19937(std::random_device{}());
        }
        // Autres générateurs peuvent être ajoutés
        return std::mt19937(std::random_device{}());
    }
    
    std::vector<double> build_time_grid(double maturity, int num_steps) {
        std::vector<double> grid;
        double dt = maturity / num_steps;
        
        for (int i = 0; i <= num_steps; ++i) {
            grid.push_back(i * dt);
        }
        return grid;
    }
    
    double interpolate_local_volatility(const LocalVolatilitySurface& surface,
                                       double spot, double time) {
        // Même logique d'interpolation que dans la classe PDE
        return 0.20; // Placeholder
    }
};
```

## Hybrid Framework Implementation

### Method Selection Engine
```cpp
// Moteur de sélection de méthode hybride
class HybridMethodSelectionEngine {
public:
    struct SelectionCriteria {
        double complexity_threshold;
        double precision_threshold;
        double performance_threshold;
        bool enable_cross_validation;
        bool prefer_pde_for_greeks;
    };
    
    // Sélection de méthode basée sur l'analyse du produit
    PricingMethod select_method(const ProductSpecification& product,
                               const SelectionCriteria& criteria) {
        
        // Analyse de complexité
        auto complexity_analysis = analyze_product_complexity(product);
        
        // Matrice de décision
        if (complexity_analysis.overall_score < criteria.complexity_threshold) {
            if (product.requires_fast_greeks) {
                return PricingMethod::PDE_ONLY;
            } else if (criteria.enable_cross_validation) {
                return PricingMethod::DUAL_VALIDATION;
            } else {
                return PricingMethod::PDE_ONLY;
            }
        } else {
            if (product.is_highly_path_dependent) {
                return PricingMethod::MONTE_CARLO_ONLY;
            } else if (criteria.prefer_pde_for_greeks) {
                return PricingMethod::PDE_FOR_GREEKS_MC_FOR_PRICE;
            } else {
                return PricingMethod::HYBRID_ADAPTIVE;
            }
        }
    }
    
private:
    struct ComplexityAnalysis {
        double overall_score;
        std::map<std::string, double> factor_scores;
    };
    
    ComplexityAnalysis analyze_product_complexity(const ProductSpecification& product) {
        ComplexityAnalysis analysis;
        
        // Calcul des scores par facteur
        analysis.factor_scores["payoff_smoothness"] = calculate_payoff_smoothness_score(product);
        analysis.factor_scores["path_dependency"] = calculate_path_dependency_score(product);
        analysis.factor_scores["dimensionality"] = calculate_dimensionality_score(product);
        
        // Score global pondéré
        analysis.overall_score = 
            0.4 * analysis.factor_scores["payoff_smoothness"] +
            0.4 * analysis.factor_scores["path_dependency"] +
            0.2 * analysis.factor_scores["dimensionality"];
        
        return analysis;
    }
    
    double calculate_payoff_smoothness_score(const ProductSpecification& product) {
        double score = 0.0;
        if (product.has_barriers) score += 2.0;
        if (product.has_digital_features) score += 1.5;
        if (product.has_discontinuous_payoff) score += 3.0;
        return score;
    }
    
    double calculate_path_dependency_score(const ProductSpecification& product) {
        double score = 0.0;
        if (product.is_path_dependent) {
            score += 2.0;
            score += 0.1 * product.number_of_observation_dates;
        }
        return score;
    }
    
    double calculate_dimensionality_score(const ProductSpecification& product) {
        return product.number_of_underlyings * 0.5;
    }
};
```

L'implémentation numérique du modèle Local Volatility PDE and MC dans Our project combine des schémas de discrétisation avancés, des algorithmes Monte Carlo optimisés et un framework de sélection hybride intelligent pour fournir une solution robuste et efficace adaptée à chaque type de produit.
