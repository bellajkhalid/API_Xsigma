# Calibration

## Overview

Toutes les routines de calibration sont effectuées **avant le pricing** et sont donc communes et valides pour les moteurs de pricing **PDE** et **Monte Carlo**. Cette section présente les éléments clés du processus de calibration pour le modèle LSV Markov Switching.

```cpp
// Implémentation Our project de la calibration LSV Markov Switching
namespace xsigma {
    // Classe principale pour la calibration du modèle LSV MS
    class LSVMarkovSwitchingCalibration {
    public:
        // Structure pour les données de marché
        struct MarketData {
            // Surface de volatilité implicite
            std::vector<double> strikes;                  // Strikes
            std::vector<double> maturities;               // Maturités
            std::vector<std::vector<double>> implied_vols; // Volatilités implicites
            
            // Courbes de taux
            std::vector<double> rate_tenors;              // Tenors des taux
            std::vector<double> risk_free_rates;          // Taux sans risque
            
            // Spot et dividendes
            double spot_price;                            // Prix spot
            std::vector<double> dividend_dates;           // Dates de dividendes
            std::vector<double> dividend_amounts;         // Montants de dividendes
            
            // Données pour exotiques (si disponibles)
            std::vector<double> exotic_prices;            // Prix d'exotiques observés
            std::vector<std::string> exotic_types;        // Types d'exotiques
        };
        
        // Paramètres de calibration
        struct CalibrationParameters {
            // Paramètres de volatilité stochastique
            double initial_vol_of_vol;                    // ν initial
            double initial_mean_reversion;                // κ initial
            double initial_long_term_variance;            // θ initial
            double initial_correlation;                   // ρ initial
            
            // Paramètres Markov Switching
            int number_of_states;                         // Nombre d'états
            std::vector<double> initial_state_volatilities; // Volatilités par état
            std::vector<std::vector<double>> initial_transition_rates; // Taux de transition
            
            // Contraintes de calibration
            double min_vol_of_vol;                        // ν minimum
            double max_vol_of_vol;                        // ν maximum
            double min_mean_reversion;                    // κ minimum
            double max_mean_reversion;                    // κ maximum
            double min_correlation;                       // ρ minimum
            double max_correlation;                       // ρ maximum
            
            // Paramètres d'optimisation
            double tolerance;                             // Tolérance de convergence
            int max_iterations;                           // Itérations maximales
            std::string optimization_method;              // Méthode d'optimisation
        };
        
        // Résultats de calibration
        struct CalibrationResults {
            // Paramètres calibrés
            double calibrated_vol_of_vol;                 // ν calibré
            double calibrated_mean_reversion;             // κ calibré
            double calibrated_long_term_variance;         // θ calibré
            double calibrated_correlation;                // ρ calibré
            
            // Paramètres Markov calibrés
            std::vector<double> calibrated_state_volatilities; // Volatilités par état
            std::vector<std::vector<double>> calibrated_transition_rates; // Taux de transition
            
            // Surface de volatilité locale calibrée
            std::vector<std::vector<double>> local_volatility_surface; // σ_LV(S,t)
            
            // Métriques de qualité
            double calibration_error;                     // Erreur de calibration
            double rmse_implied_vols;                     // RMSE volatilités implicites
            double max_pricing_error;                     // Erreur de pricing maximale
            int iterations_used;                          // Itérations utilisées
            bool convergence_achieved;                    // Convergence atteinte
            
            // Diagnostics
            std::vector<double> residuals;                // Résidus par instrument
            std::map<std::string, double> fit_statistics; // Statistiques d'ajustement
        };
        
        // Processus de calibration principal
        CalibrationResults calibrate_model(
            const MarketData& market_data,
            const CalibrationParameters& params) const {
            
            CalibrationResults results;
            
            try {
                // Étape 1: Calibration de la volatilité locale
                auto local_vol_surface = calibrate_local_volatility(market_data);
                results.local_volatility_surface = local_vol_surface;
                
                // Étape 2: Calibration des paramètres de volatilité stochastique
                auto sv_params = calibrate_stochastic_volatility(market_data, params);
                results.calibrated_vol_of_vol = sv_params.vol_of_vol;
                results.calibrated_mean_reversion = sv_params.mean_reversion;
                results.calibrated_long_term_variance = sv_params.long_term_variance;
                results.calibrated_correlation = sv_params.correlation;
                
                // Étape 3: Calibration des paramètres Markov Switching
                auto ms_params = calibrate_markov_switching(market_data, params, sv_params);
                results.calibrated_state_volatilities = ms_params.state_volatilities;
                results.calibrated_transition_rates = ms_params.transition_rates;
                
                // Étape 4: Validation et métriques de qualité
                validate_calibration(market_data, results);
                
                results.convergence_achieved = true;
                
            } catch (const std::exception& e) {
                XSIGMA_LOG_ERROR("Erreur lors de la calibration: " + std::string(e.what()));
                results.convergence_achieved = false;
            }
            
            return results;
        }
        
        // Calibration de la volatilité locale (Dupire)
        std::vector<std::vector<double>> calibrate_local_volatility(
            const MarketData& market_data) const {
            
            // Implémentation de l'équation de Dupire
            // ∂C/∂T = (1/2)σ_LV²(K,T)K²∂²C/∂K² - rK∂C/∂K
            
            std::vector<std::vector<double>> local_vol_surface;
            
            size_t n_strikes = market_data.strikes.size();
            size_t n_maturities = market_data.maturities.size();
            
            local_vol_surface.resize(n_strikes, std::vector<double>(n_maturities));
            
            for (size_t i = 0; i < n_strikes; ++i) {
                for (size_t j = 0; j < n_maturities; ++j) {
                    // Calcul de la volatilité locale via formule de Dupire
                    double strike = market_data.strikes[i];
                    double maturity = market_data.maturities[j];
                    double implied_vol = market_data.implied_vols[i][j];
                    
                    // Calcul des dérivées partielles des prix d'options
                    double dC_dT = calculate_price_time_derivative(strike, maturity, implied_vol);
                    double dC_dK = calculate_price_strike_derivative(strike, maturity, implied_vol);
                    double d2C_dK2 = calculate_price_strike_second_derivative(strike, maturity, implied_vol);
                    
                    // Application de la formule de Dupire
                    double numerator = dC_dT + market_data.risk_free_rates[j] * strike * dC_dK;
                    double denominator = 0.5 * strike * strike * d2C_dK2;
                    
                    if (denominator > 1e-10) {
                        local_vol_surface[i][j] = std::sqrt(std::max(numerator / denominator, 0.01));
                    } else {
                        local_vol_surface[i][j] = implied_vol; // Fallback
                    }
                }
            }
            
            return local_vol_surface;
        }
        
        // Structure pour paramètres SV calibrés
        struct StochasticVolatilityParams {
            double vol_of_vol;
            double mean_reversion;
            double long_term_variance;
            double correlation;
        };
        
        // Calibration de la volatilité stochastique
        StochasticVolatilityParams calibrate_stochastic_volatility(
            const MarketData& market_data,
            const CalibrationParameters& params) const {
            
            StochasticVolatilityParams sv_params;
            
            // Optimisation par moindres carrés des paramètres SV
            // Minimisation de l'erreur entre prix de marché et prix modèle
            
            auto objective_function = [&](const std::vector<double>& x) -> double {
                double vol_of_vol = x[0];
                double mean_reversion = x[1];
                double long_term_variance = x[2];
                double correlation = x[3];
                
                double total_error = 0.0;
                
                // Calcul de l'erreur pour chaque instrument de calibration
                for (size_t i = 0; i < market_data.strikes.size(); ++i) {
                    for (size_t j = 0; j < market_data.maturities.size(); ++j) {
                        double market_price = calculate_bs_price(
                            market_data.strikes[i],
                            market_data.maturities[j],
                            market_data.implied_vols[i][j]);
                        
                        double model_price = calculate_lsv_price(
                            market_data.strikes[i],
                            market_data.maturities[j],
                            vol_of_vol, mean_reversion, long_term_variance, correlation);
                        
                        double error = (model_price - market_price) / market_price;
                        total_error += error * error;
                    }
                }
                
                return total_error;
            };
            
            // Optimisation avec contraintes
            std::vector<double> initial_guess = {
                params.initial_vol_of_vol,
                params.initial_mean_reversion,
                params.initial_long_term_variance,
                params.initial_correlation
            };
            
            auto optimized_params = optimize_with_constraints(
                objective_function, initial_guess, params);
            
            sv_params.vol_of_vol = optimized_params[0];
            sv_params.mean_reversion = optimized_params[1];
            sv_params.long_term_variance = optimized_params[2];
            sv_params.correlation = optimized_params[3];
            
            return sv_params;
        }
        
        // Structure pour paramètres Markov Switching calibrés
        struct MarkovSwitchingParams {
            std::vector<double> state_volatilities;
            std::vector<std::vector<double>> transition_rates;
        };
        
        // Calibration des paramètres Markov Switching
        MarkovSwitchingParams calibrate_markov_switching(
            const MarketData& market_data,
            const CalibrationParameters& params,
            const StochasticVolatilityParams& sv_params) const {
            
            MarkovSwitchingParams ms_params;
            
            // Calibration des états de volatilité et taux de transition
            // Utilisation d'instruments exotiques si disponibles
            
            if (!market_data.exotic_prices.empty()) {
                // Calibration sur exotiques
                ms_params = calibrate_on_exotics(market_data, params, sv_params);
            } else {
                // Calibration sur structure de terme de volatilité
                ms_params = calibrate_on_vol_term_structure(market_data, params, sv_params);
            }
            
            return ms_params;
        }
        
        // Validation de la calibration
        void validate_calibration(
            const MarketData& market_data,
            CalibrationResults& results) const {
            
            // Calcul des métriques de qualité
            double total_squared_error = 0.0;
            double max_error = 0.0;
            int n_instruments = 0;
            
            for (size_t i = 0; i < market_data.strikes.size(); ++i) {
                for (size_t j = 0; j < market_data.maturities.size(); ++j) {
                    double market_vol = market_data.implied_vols[i][j];
                    double model_vol = calculate_model_implied_vol(
                        market_data.strikes[i],
                        market_data.maturities[j],
                        results);
                    
                    double error = std::abs(model_vol - market_vol);
                    total_squared_error += error * error;
                    max_error = std::max(max_error, error);
                    n_instruments++;
                    
                    results.residuals.push_back(error);
                }
            }
            
            results.rmse_implied_vols = std::sqrt(total_squared_error / n_instruments);
            results.max_pricing_error = max_error;
            results.calibration_error = total_squared_error;
            
            // Statistiques d'ajustement
            results.fit_statistics["RMSE"] = results.rmse_implied_vols;
            results.fit_statistics["MAX_ERROR"] = max_error;
            results.fit_statistics["MEAN_ABS_ERROR"] = calculate_mean_absolute_error(results.residuals);
            results.fit_statistics["R_SQUARED"] = calculate_r_squared(market_data, results);
        }
        
    private:
        // Méthodes utilitaires pour calculs de dérivées et optimisation
        double calculate_price_time_derivative(double strike, double maturity, double vol) const {
            // Calcul numérique de ∂C/∂T
            return 0.0; // Placeholder
        }
        
        double calculate_price_strike_derivative(double strike, double maturity, double vol) const {
            // Calcul numérique de ∂C/∂K
            return 0.0; // Placeholder
        }
        
        double calculate_price_strike_second_derivative(double strike, double maturity, double vol) const {
            // Calcul numérique de ∂²C/∂K²
            return 0.0; // Placeholder
        }
        
        double calculate_bs_price(double strike, double maturity, double vol) const {
            // Prix Black-Scholes
            return 0.0; // Placeholder
        }
        
        double calculate_lsv_price(double strike, double maturity,
                                 double vol_of_vol, double mean_reversion,
                                 double long_term_variance, double correlation) const {
            // Prix LSV via PDE ou Monte Carlo
            return 0.0; // Placeholder
        }
        
        std::vector<double> optimize_with_constraints(
            std::function<double(const std::vector<double>&)> objective,
            const std::vector<double>& initial_guess,
            const CalibrationParameters& params) const {
            
            // Optimisation avec contraintes (Levenberg-Marquardt, BFGS, etc.)
            return initial_guess; // Placeholder
        }
        
        MarkovSwitchingParams calibrate_on_exotics(
            const MarketData& market_data,
            const CalibrationParameters& params,
            const StochasticVolatilityParams& sv_params) const {
            
            MarkovSwitchingParams ms_params;
            // Implémentation spécifique pour calibration sur exotiques
            return ms_params;
        }
        
        MarkovSwitchingParams calibrate_on_vol_term_structure(
            const MarketData& market_data,
            const CalibrationParameters& params,
            const StochasticVolatilityParams& sv_params) const {
            
            MarkovSwitchingParams ms_params;
            // Implémentation spécifique pour calibration sur structure de terme
            return ms_params;
        }
        
        double calculate_model_implied_vol(
            double strike, double maturity,
            const CalibrationResults& results) const {
            
            // Calcul de la volatilité implicite du modèle calibré
            return 0.0; // Placeholder
        }
        
        double calculate_mean_absolute_error(const std::vector<double>& residuals) const {
            if (residuals.empty()) return 0.0;
            
            double sum = std::accumulate(residuals.begin(), residuals.end(), 0.0);
            return sum / residuals.size();
        }
        
        double calculate_r_squared(const MarketData& market_data,
                                 const CalibrationResults& results) const {
            // Calcul du coefficient de détermination R²
            return 0.0; // Placeholder
        }
    };
}
```
*Cette implémentation C++ dans Our project fournit un framework complet de calibration pour le modèle LSV Markov Switching avec calibration séquentielle de la volatilité locale, des paramètres stochastiques et des paramètres Markov.*

## Calibration Process

### Sequential Calibration Approach

La calibration du modèle LSV Markov Switching suit une approche **séquentielle en trois étapes** :

#### Étape 1: Calibration de la Volatilité Locale
- **Méthode** : Équation de Dupire
- **Input** : Surface de volatilité implicite de marché
- **Output** : Surface de volatilité locale $\sigma_{LV}(S,t)$
- **Formule** : $\sigma_{LV}^2(K,T) = \frac{2\frac{\partial C}{\partial T} + rK\frac{\partial C}{\partial K}}{K^2\frac{\partial^2 C}{\partial K^2}}$

#### Étape 2: Calibration de la Volatilité Stochastique
- **Paramètres** : $\nu$ (vol of vol), $\kappa$ (mean reversion), $\theta$ (long term variance), $\rho$ (correlation)
- **Méthode** : Optimisation par moindres carrés
- **Contraintes** : Condition de Feller $2\kappa\theta \geq \nu^2$
- **Objectif** : Minimisation de l'erreur entre prix de marché et prix modèle

#### Étape 3: Calibration Markov Switching
- **Paramètres** : Volatilités par état, taux de transition
- **Input** : Instruments exotiques (si disponibles) ou structure de terme
- **Méthode** : Optimisation contrainte avec validation des matrices de transition

### Calibration Quality Metrics

#### Métriques de Précision
- **RMSE** : Root Mean Square Error sur volatilités implicites
- **MAE** : Mean Absolute Error
- **Max Error** : Erreur maximale observée
- **R²** : Coefficient de détermination

#### Validation de Convergence
- **Tolérance** : Critère de convergence configurable
- **Itérations** : Nombre maximal d'itérations
- **Stabilité** : Validation de la stabilité des paramètres

### Implementation Features

#### PDE Forward Induction
- **Procédure** : Induction forward via PDE pour calibration
- **Cohérence** : Mêmes paramètres pour PDE et Monte Carlo
- **Efficacité** : Calibration rapide via méthodes PDE

#### Constraint Handling
- **Bornes** : Contraintes sur tous les paramètres
- **Feller Condition** : Respect automatique pour SV
- **Transition Matrices** : Validation des propriétés stochastiques

#### Robustness Features
- **Multiple Starting Points** : Éviter les minima locaux
- **Regularization** : Techniques de régularisation pour stabilité
- **Fallback Mechanisms** : Mécanismes de secours en cas d'échec

### Recommended Calibration Settings

#### Paramètres d'Optimisation
- **Tolérance** : 1e-6 pour convergence
- **Max Iterations** : 1000 pour robustesse
- **Method** : Levenberg-Marquardt ou BFGS

#### Contraintes Typiques
- **Vol of Vol** : [0.01, 2.0]
- **Mean Reversion** : [0.1, 10.0]
- **Correlation** : [-0.9, 0.9]
- **State Volatilities** : [0.5, 3.0]

#### Validation Criteria
- **RMSE < 1%** : Critère de qualité standard
- **Max Error < 5%** : Tolérance pour outliers
- **R² > 0.95** : Qualité d'ajustement minimale

Le processus de calibration LSV MS dans Our project assure une calibration robuste et précise du modèle avec validation complète de la qualité d'ajustement et respect de toutes les contraintes théoriques et numériques.
