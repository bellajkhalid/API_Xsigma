# Executive Summary

## üìä **Global Model Risk Assessment**

Le **Global Model Risk Assessment** pour le mod√®le DBX-ShortRate_FXSkewStochVol pr√©sente l'√©valuation suivante :

### **√âvaluation des Risques**

| Crit√®re | Rating | Justification |
|---------|--------|---------------|
| **Complexit√©** | HIGH | Jugement SME du validateur |
| **Incertitude** | HIGH | Nombre √©lev√© de trades vs limitations P-M |
| **D√©pendance** | HIGH | Les mod√®les de pricing ont une d√©pendance √©lev√©e |

### **M√©thodologie d'√âvaluation**

#### **Rating de Complexit√© - HIGH**
Le rating de complexit√© √©lev√©e est justifi√© par :
- **Mod√®le multi-facteurs** combinant taux stochastiques et volatilit√© FX locale stochastique
- **Calibration complexe** avec PIV AutoFit et DLVIR correction
- **Corr√©lations multiples** entre facteurs de risque (FX, IR domestique, IR √©tranger)
- **Impl√©mentation Monte Carlo** avec techniques avanc√©es de r√©duction de variance

#### **Rating d'Incertitude - HIGH**
Le rating d'incertitude √©lev√©e s'explique par :
- **Nombre √©lev√© de trades** vs limitations produit-mod√®le
- **Param√®tres exog√®nes** nombreux n√©cessitant un jugement d'expert
- **Calibration automatique** avec risque de sur-ajustement
- **Sensibilit√© aux corr√©lations** FX-IR difficiles √† observer

#### **Rating de D√©pendance - HIGH**
La d√©pendance √©lev√©e est due au fait que :
- Les **outputs du mod√®le d√©finissent** les m√©triques officiellement report√©es
- **Utilisation critique** pour valorisation de d√©riv√©s FX long terme
- **Pas de mod√®le alternatif** appropri√© pour ces produits complexes
- **Impact significatif** sur les mesures de risque et capital

---

## ‚úÖ **R√©sum√© des Principaux R√©sultats de Validation**

### **Objectifs du Mod√®le**
Le mod√®le **DBX-ShortRate_FXSkewStochVol** est utilis√© pour les objectifs suivants :

#### **üìà √âvaluation et Reporting**
- G√©n√©ration de **mesures de fair value** pour d√©riv√©s FX long terme
- G√©n√©ration de **sensibilit√©s de risque** complexes (Delta, Vega, Rho multi-devises)
- Alimentation des calculs de **Risk and Capital** pour expositions FX

#### **üîÑ Tests de Stress**
- Re-pricing sous **sc√©narios de stress** comme mod√®le servicer
- Tests de stress r√©glementaires (**CCAR**)
- Calculs **Interest Rate Risk in Banking Book (IRRBB)** avec FX
- **Simulations historiques** (HistSim) et Value at Risk multi-facteurs

### **D√©veloppement et Maintenance**
Le mod√®le est d√©velopp√© et maintenu par **DBAnalytics** et fourni via :
- **Moteur Monte Carlo DBX** pour performance optimis√©e
- **Python** et **Perl** pour int√©gration
- Disponible dans **Kannon** et **Risk Engine**

---

## üèóÔ∏è **Scope des Produits et Configurations**

### **Produits Approuv√©s**

#### **Long-Term FX Derivatives**
```cpp
// Impl√©mentation LTFX dans Our project
class long_term_fx_derivative : public fx_derivative_base {
private:
    struct ltfx_specification {
        std::string currency_pair;
        double strike;
        double expiry;
        bool is_call;
        double notional;
        std::vector<double> observation_dates;
        ltfx_type type; // VANILLA, DIGITAL, CONVEXITY, PAR_FORWARD
    };
    
    ltfx_specification spec_;
    
public:
    long_term_fx_derivative(const ltfx_specification& spec) : spec_(spec) {
        validate_ltfx_specification();
    }
    
    double calculate_pv(const market_data& market) const override {
        return calculate_ltfx_pv_monte_carlo(market);
    }
    
    fx_sensitivities calculate_sensitivities(const market_data& market) const override {
        fx_sensitivities sens;
        
        // Sensibilit√©s FX
        sens.fx_delta = calculate_fx_delta_mc(market);
        sens.fx_gamma = calculate_fx_gamma_mc(market);
        sens.fx_vega_local = calculate_local_vega_mc(market);
        sens.fx_vega_stochastic = calculate_stochastic_vega_mc(market);
        
        // Sensibilit√©s IR multi-devises
        sens.domestic_ir_delta = calculate_domestic_ir_delta_mc(market);
        sens.foreign_ir_delta = calculate_foreign_ir_delta_mc(market);
        sens.domestic_ir_vega = calculate_domestic_ir_vega_mc(market);
        sens.foreign_ir_vega = calculate_foreign_ir_vega_mc(market);
        
        // Sensibilit√©s crois√©es
        sens.fx_ir_correlation_sensitivity = calculate_fx_ir_correlation_sensitivity_mc(market);
        
        return sens;
    }
    
private:
    double calculate_ltfx_pv_monte_carlo(const market_data& market) const {
        const int num_simulations = 100000;
        const int num_time_steps = static_cast<int>(spec_.expiry * 252); // Daily steps
        
        // Configuration Monte Carlo
        monte_carlo_engine mc_engine(num_simulations, num_time_steps);
        
        // Mod√®les stochastiques
        auto hull_white_domestic = create_hull_white_model(market, "DOMESTIC");
        auto hull_white_foreign = create_hull_white_model(market, "FOREIGN");
        auto fx_lsv_model = create_fx_local_stochastic_vol_model(market);
        
        double payoff_sum = 0.0;
        
        for (int sim = 0; sim < num_simulations; ++sim) {
            // G√©n√©ration de path corr√©l√©
            auto correlated_path = mc_engine.generate_correlated_path(
                hull_white_domestic, hull_white_foreign, fx_lsv_model);
            
            // Calcul du payoff
            double payoff = calculate_ltfx_payoff(correlated_path);
            payoff_sum += payoff;
        }
        
        return payoff_sum / num_simulations;
    }
    
    double calculate_ltfx_payoff(const monte_carlo_path& path) const {
        // Extraction des valeurs finales
        double final_fx = path.fx_values.back();
        double final_domestic_rate = path.domestic_rates.back();
        
        // Facteur d'actualisation
        double discount_factor = calculate_discount_factor(path.domestic_rates);
        
        // Payoff selon le type
        double payoff = 0.0;
        switch (spec_.type) {
            case ltfx_type::VANILLA:
                payoff = spec_.is_call ? 
                    std::max(final_fx - spec_.strike, 0.0) :
                    std::max(spec_.strike - final_fx, 0.0);
                break;
                
            case ltfx_type::DIGITAL:
                payoff = (spec_.is_call && final_fx > spec_.strike) ||
                        (!spec_.is_call && final_fx < spec_.strike) ? 1.0 : 0.0;
                break;
                
            case ltfx_type::CONVEXITY:
                payoff = calculate_convexity_payoff(path);
                break;
                
            case ltfx_type::PAR_FORWARD:
                payoff = calculate_par_forward_payoff(path);
                break;
        }
        
        return spec_.notional * payoff * discount_factor;
    }
};
```
*Cette impl√©mentation C++ dans Our project montre la structure d'un d√©riv√© FX long terme avec pricing Monte Carlo et sensibilit√©s multi-facteurs.*

#### **PRDC Swaps (Power Reverse Dual Currency)**
```cpp
// Impl√©mentation PRDC Swap dans Our project
class prdc_swap : public ir_fx_hybrid_base {
private:
    struct prdc_specification {
        std::string domestic_currency;
        std::string foreign_currency;
        std::vector<double> payment_dates;
        std::vector<double> fx_fixing_dates;
        double leverage;
        double participation_rate;
        std::vector<double> fx_barriers;
        bool is_callable;
        std::vector<double> call_dates;
    };
    
    prdc_specification spec_;
    
public:
    double calculate_pv(const market_data& market) const override {
        return calculate_prdc_pv_monte_carlo(market);
    }
    
private:
    double calculate_prdc_pv_monte_carlo(const market_data& market) const {
        const int num_simulations = 200000; // Plus de simulations pour PRDC
        
        monte_carlo_engine mc_engine(num_simulations);
        
        // Mod√®les corr√©l√©s
        auto models = create_correlated_ir_fx_models(market);
        
        double pv_sum = 0.0;
        
        for (int sim = 0; sim < num_simulations; ++sim) {
            auto path = mc_engine.generate_full_path(models, spec_.payment_dates);
            
            double prdc_pv = 0.0;
            
            // Calcul des coupons PRDC
            for (size_t i = 0; i < spec_.payment_dates.size(); ++i) {
                double fx_fixing = path.fx_values[i];
                double foreign_rate = path.foreign_rates[i];
                
                // Coupon PRDC avec leverage et participation
                double coupon = spec_.leverage * foreign_rate * 
                              std::min(spec_.participation_rate, fx_fixing / spec_.fx_barriers[i]);
                
                // Actualisation
                double discount_factor = calculate_discount_factor_to_date(
                    path.domestic_rates, spec_.payment_dates[i]);
                
                prdc_pv += coupon * discount_factor;
            }
            
            // Gestion de la callabilit√©
            if (spec_.is_callable) {
                prdc_pv = apply_callable_feature(prdc_pv, path);
            }
            
            pv_sum += prdc_pv;
        }
        
        return pv_sum / num_simulations;
    }
};
```

### **Configurations de Mod√®le**
- **DBX-ShortRateNormal[LVMRAUTO]_FXSkewStochVol[DLVAUTO]** - Configuration compl√®te avec calibration automatique

---

## üéØ **Framework Th√©orique**

### **Mod√®le DBX-ShortRate_FXSkewStochVol**
Le mod√®le DBX combine plusieurs composants sophistiqu√©s :

#### **Composants du Mod√®le**
- **Taux stochastiques** Hull-White avec coefficients d√©pendants du temps
- **Volatilit√© FX locale** calibr√©e via PIV AutoFit
- **Volatilit√© FX stochastique** avec d√©composition Gy√∂ngy
- **Corr√©lations** entre tous les facteurs de risque

#### **Dynamiques Stochastiques**
```cpp
// Syst√®me d'√©quations stochastiques dans Our project
class dbx_stochastic_system {
public:
    struct system_state {
        vector<double> domestic_short_rates;
        vector<double> foreign_short_rates;
        double fx_rate;
        double fx_stochastic_vol_factor;
    };
    
    system_state evolve_system(double dt, 
                              const system_state& current_state,
                              const matrix<double>& correlated_randoms) const {
        
        system_state next_state;
        
        // √âvolution des taux domestiques (Hull-White)
        // dr_d = (theta_d(t) - a_d * r_d) * dt + sigma_d * dW_d
        next_state.domestic_short_rates = evolve_hull_white_rates(
            current_state.domestic_short_rates, 
            domestic_hw_params_, 
            dt, 
            correlated_randoms.column(0));
        
        // √âvolution des taux √©trangers (Hull-White)
        // dr_f = (theta_f(t) - a_f * r_f) * dt + sigma_f * dW_f
        next_state.foreign_short_rates = evolve_hull_white_rates(
            current_state.foreign_short_rates, 
            foreign_hw_params_, 
            dt, 
            correlated_randoms.column(1));
        
        // √âvolution du facteur de volatilit√© stochastique FX
        // dv = kappa * (theta_v - v) * dt + sigma_v * sqrt(v) * dW_v
        next_state.fx_stochastic_vol_factor = evolve_stochastic_volatility(
            current_state.fx_stochastic_vol_factor,
            sv_params_,
            dt,
            correlated_randoms(2, 0));
        
        // √âvolution du taux FX avec volatilit√© locale stochastique
        // dS = (r_d - r_f) * S * dt + sigma_LV(t,S) * sqrt(v) * S * dW_S
        double local_vol = local_vol_surface_->get_volatility(
            get_current_time(), current_state.fx_rate);
        
        double total_vol = local_vol * std::sqrt(next_state.fx_stochastic_vol_factor);
        
        double fx_drift = (next_state.domestic_short_rates[0] - 
                          next_state.foreign_short_rates[0]) * current_state.fx_rate * dt;
        
        double fx_diffusion = total_vol * current_state.fx_rate * 
                             std::sqrt(dt) * correlated_randoms(3, 0);
        
        next_state.fx_rate = current_state.fx_rate + fx_drift + fx_diffusion;
        
        return next_state;
    }
};
```
*Cette impl√©mentation C++ dans Our project montre le syst√®me d'√©quations stochastiques coupl√©es pour le mod√®le DBX.*

---

## üìã **Usages Recommand√©s et Validation**

### **Usages Approuv√©s**

| Usage | Recommand√© pour Utilisation (RFU) |
|-------|-----------------------------------|
| **EOD** | ‚úÖ YES |
| **HistSim** | ‚úÖ YES |
| **CCAR** | ‚úÖ YES |
| **IRRBB** | ‚úÖ YES |

### **R√©sultats de Validation**
La revue entreprise n'a r√©v√©l√© **aucun d√©faut** dans la th√©orie ou les impl√©mentations pertinentes.

#### **Points Cl√©s de Validation**
- ‚úÖ **M√©thodologie th√©orique** Hull-White et volatilit√© locale stochastique valid√©e
- ‚úÖ **Impl√©mentation Monte Carlo** v√©rifi√©e contre benchmarks
- ‚úÖ **Calibration automatique** test√©e sur donn√©es de march√©
- ‚úÖ **Stabilit√© des risques** confirm√©e sous stress
- ‚úÖ **Conformit√© r√©glementaire** √©tablie

---

## üîç **Limitations et Findings**

### **Limitations du Mod√®le**
Pour le mod√®le DBX-ShortRate_FXSkewStochVol :

#### **Limitations Identifi√©es**
1. **Param√®tres exog√®nes** - Nombreux param√®tres n√©cessitant jugement d'expert
2. **Corr√©lations constantes** - Corr√©lations FX-IR assum√©es constantes
3. **Calibration complexe** - Risque de sur-ajustement avec nombreux param√®tres
4. **Performance Monte Carlo** - Temps de calcul √©lev√© pour produits complexes

### **Validation Findings**
Aucun finding de validation n√©cessitant d'√™tre adress√© n'a √©t√© identifi√©.

### **Contr√¥les et Surveillance**
- **Conditions d'utilisation** class√©es comme Model Rule
- **Surveillance automatis√©e** via Model Parameter Monitoring
- **Enregistrement** dans MARS de toutes les conditions d'utilisation

---

## üéØ **Conclusion G√©n√©rale**

### **Recommandation d'Utilisation**
Le framework DBX-ShortRate_FXSkewStochVol est **recommand√© pour utilisation** dans tous les usages d√©finis, avec :

- **Validation compl√®te** de l'impl√©mentation Monte Carlo
- **Tests exhaustifs** sous diff√©rents sc√©narios de stress
- **Contr√¥les appropri√©s** en place
- **Surveillance continue** des param√®tres

### **Avantages Cl√©s**
- **Mod√©lisation sophistiqu√©e** des risques FX long terme
- **Calibration automatique** aux donn√©es de march√©
- **Flexibilit√©** pour produits complexes multi-devises
- **Int√©gration** native avec DBAnalytics

Le mod√®le repr√©sente une solution robuste et valid√©e pour le pricing de d√©riv√©s FX long terme avec taux stochastiques, r√©pondant aux exigences de pr√©cision et de performance pour les applications de trading et de gestion des risques.

---

*Cette section fournit un r√©sum√© ex√©cutif complet du framework DBX-ShortRate_FXSkewStochVol, int√©grant les standards de documentation de Our project avec les d√©tails techniques et les r√©sultats de validation.*
