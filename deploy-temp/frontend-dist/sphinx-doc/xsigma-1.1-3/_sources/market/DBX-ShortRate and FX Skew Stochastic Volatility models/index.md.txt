# DBX-ShortRate and FX Skew Stochastic Volatility Models

## üìã **Vue d'Ensemble**

Le mod√®le **DBX-ShortRate_FXSkewStochVol** est un framework Monte Carlo sophistiqu√© pour le pricing et la gestion des risques de d√©riv√©s FX long terme. Il combine des taux d'int√©r√™t stochastiques (Hull-White) avec une volatilit√© FX locale stochastique, permettant de capturer le smile de volatilit√© FX et le forward smile pour des produits multi-devises complexes.

---

## üéØ **Caract√©ristiques Principales**

### **Mod√®les Couverts**
- **DBX-ShortRateNormal[LVMRAUTO]_FXSkewStochVol[DLVAUTO]**

### **Composants du Mod√®le**
- **Taux Stochastiques** : Processus Hull-White avec coefficients d√©pendants du temps
- **Volatilit√© FX Locale** : Processus lognormal avec volatilit√© locale stochastique
- **Moteur Monte Carlo** : Impl√©mentation DBX avec techniques de r√©duction de variance
- **Calibration Automatique** : PIV AutoFit et DLVIR correction

### **Produits Support√©s**
- **Long-Term FX** : LTFX, LTFXDigital, LTFXConvexity, LTFXParForward
- **PRDC Swaps** : PRDCSwap, PRDCSwapCallable, PRDCSwapTarn
- **IR-FX Hybrids** : IRFXDualDigitalOpt, IRFXSwapFXOpt, IRSwapQuanto
- **Exotic Options** : FXAmerOpt, FXOneBarrierOpt, FXVolSwap, FXVarSwap

### **Usages Approuv√©s**
- ‚úÖ **End of Day (EOD)** - √âvaluation et gestion des risques
- ‚úÖ **HistSim** - Simulations historiques
- ‚úÖ **CCAR** - Tests de stress r√©glementaires
- ‚úÖ **IRRBB** - Interest Rate Risk in Banking Book

---

## üèóÔ∏è **Architecture du Framework**

### **Mod√©lisation Multi-Facteurs**
Le framework utilise une approche sophistiqu√©e combinant :
- **Processus Hull-White** pour taux domestiques et √©trangers
- **Volatilit√© locale stochastique** pour le taux FX
- **Corr√©lations** entre facteurs de risque
- **Calibration automatique** aux donn√©es de march√©

### **Composants Techniques**
```cpp
// Exemple d'impl√©mentation Hull-White dans Our project
class hull_white_short_rate_model : public ir_model_base {
private:
    struct hull_white_parameters {
        vector<double> mean_reversion_speeds;
        vector<double> volatilities;
        matrix<double> correlation_matrix;
        std::function<double(double)> theta_function;
    };

    hull_white_parameters params_;

public:
    hull_white_short_rate_model(const hull_white_parameters& params)
        : params_(params) {
        validate_hull_white_parameters();
    }

    vector<double> evolve_short_rates(double dt,
                                     const vector<double>& current_rates,
                                     const matrix<double>& random_shocks) const override {

        vector<double> next_rates(current_rates.size());

        for (size_t i = 0; i < current_rates.size(); ++i) {
            // Processus Hull-White : dr = (theta(t) - a*r)*dt + sigma*dW
            double mean_reversion = params_.mean_reversion_speeds[i];
            double volatility = params_.volatilities[i];
            double theta = params_.theta_function(get_current_time());

            double drift = (theta - mean_reversion * current_rates[i]) * dt;
            double diffusion = volatility * std::sqrt(dt) * random_shocks(i, 0);

            next_rates[i] = current_rates[i] + drift + diffusion;
        }

        return next_rates;
    }

    matrix<double> calculate_bond_prices(const vector<double>& maturities,
                                        const vector<double>& current_rates) const {

        matrix<double> bond_prices(current_rates.size(), maturities.size());

        for (size_t i = 0; i < current_rates.size(); ++i) {
            for (size_t j = 0; j < maturities.size(); ++j) {
                // Prix d'obligation Hull-White analytique
                double maturity = maturities[j];
                double rate = current_rates[i];
                double mean_reversion = params_.mean_reversion_speeds[i];
                double volatility = params_.volatilities[i];

                // Formule analytique Hull-White
                double B = (1.0 - std::exp(-mean_reversion * maturity)) / mean_reversion;
                double A = calculate_hull_white_A_factor(maturity, mean_reversion, volatility);

                bond_prices(i, j) = A * std::exp(-B * rate);
            }
        }

        return bond_prices;
    }

private:
    double calculate_hull_white_A_factor(double maturity, double mean_reversion,
                                        double volatility) const {
        // Calcul du facteur A dans la formule Hull-White
        double B = (1.0 - std::exp(-mean_reversion * maturity)) / mean_reversion;
        double variance_integral = calculate_variance_integral(maturity, mean_reversion, volatility);

        return std::exp(-0.5 * B * B * variance_integral);
    }

    void validate_hull_white_parameters() const {
        XSIGMA_CHECK(!params_.mean_reversion_speeds.empty(), "Mean reversion speeds required");
        XSIGMA_CHECK(!params_.volatilities.empty(), "Volatilities required");
        XSIGMA_CHECK(params_.mean_reversion_speeds.size() == params_.volatilities.size(),
                    "Parameter sizes must match");

        for (double speed : params_.mean_reversion_speeds) {
            XSIGMA_CHECK(speed > 0, "Mean reversion speed must be positive");
        }

        for (double vol : params_.volatilities) {
            XSIGMA_CHECK(vol > 0, "Volatility must be positive");
        }
    }
};
```
*Cette impl√©mentation C++ dans Our project montre le mod√®le Hull-White avec √©volution des taux courts et pricing analytique d'obligations.*

---

## üìä **√âvaluation des Risques**

### **Global Model Risk Assessment**

| Crit√®re | Rating | Justification |
|---------|--------|---------------|
| **Complexit√©** | HIGH | Jugement SME du validateur |
| **Incertitude** | HIGH | Nombre √©lev√© de trades vs limitations P-M |
| **D√©pendance** | HIGH | Les mod√®les de pricing ont une d√©pendance √©lev√©e |

**Justifications :**
- **Complexit√© HIGH** : Mod√®le multi-facteurs avec taux stochastiques et volatilit√© locale stochastique
- **Incertitude HIGH** : Calibration complexe avec nombreux param√®tres et corr√©lations
- **D√©pendance HIGH** : Les outputs d√©finissent les m√©triques officiellement report√©es

---

## üìö **Documentation D√©taill√©e**

```{toctree}
:maxdepth: 2
:caption: Documentation DBX-ShortRate FX Skew Stochastic Volatility

executive_summary
introduction_model_validation
theoretical_overview
calibration_methodology
independent_validation_testing
product_testing_ltfx
product_testing_prdc
product_testing_irfx_hybrids
model_parameters_testing
```

### **Sections Principales**

#### **üìã Documentation Fondamentale**
- **[Executive Summary](executive_summary.md)** - R√©sum√© ex√©cutif et √©valuation globale des risques
- **[Introduction & Model Validation](introduction_model_validation.md)** - Scope, description des produits et m√©thodologie
- **[Theoretical Overview](theoretical_overview.md)** - Vue d'ensemble th√©orique et dynamiques stochastiques

#### **üîß Calibration et M√©thodologie**
- **[Calibration Methodology](calibration_methodology.md)** - PIV AutoFit, DLVIR correction et calibration automatique

#### **üî¨ Tests et Validation**
- **[Independent Validation Testing](independent_validation_testing.md)** - Tests de validation ind√©pendants et frameworks r√©glementaires

#### **üìä Tests de Produits Sp√©cifiques**
- **[Product Testing: LTFX](product_testing_ltfx.md)** - Tests complets pour d√©riv√©s FX long terme
- **[Product Testing: PRDC](product_testing_prdc.md)** - Tests complets pour PRDC Swaps
- **[Product Testing: IR-FX Hybrids](product_testing_irfx_hybrids.md)** - Tests complets pour produits hybrides IR-FX

#### **üîß Tests de Param√®tres**
- **[Model Parameters Testing](model_parameters_testing.md)** - Tests d√©taill√©s des param√®tres de mod√®le

---

## üéØ **Avantages Techniques du Framework DBX**

### **‚úÖ Mod√©lisation Multi-Facteurs Avanc√©e**
- **Taux stochastiques** Hull-White avec calibration automatique
- **Volatilit√© FX locale** calibr√©e via PIV AutoFit
- **Volatilit√© FX stochastique** avec processus CIR
- **Corr√©lations compl√®tes** entre tous les facteurs de risque

### **‚úÖ Calibration Automatique Sophistiqu√©e**
- **PIV AutoFit** avec optimisation Levenberg-Marquardt
- **DLVIR correction** pour taux stochastiques
- **R√©gularisation** pour lissage des surfaces
- **Validation automatique** de qualit√© de calibration

### **‚úÖ Performance Monte Carlo Optimis√©e**
- **Techniques de r√©duction de variance** (antithetic, control variates)
- **Parall√©lisation** multi-thread native
- **Convergence acc√©l√©r√©e** pour d√©riv√©s complexes
- **Gestion m√©moire** optimis√©e pour long terme

### **‚úÖ Validation Exhaustive**
- **Tests de convergence** Monte Carlo rigoureux
- **Validation crois√©e** avec mod√®les alternatifs
- **Tests r√©glementaires** CCAR et IRRBB sp√©cialis√©s
- **Monitoring continu** des param√®tres

---

## üìà **Cas d'Usage Sp√©cialis√©s**

### **D√©riv√©s FX Long Terme**
```cpp
// Exemple d'usage pour LTFX avec convexit√© dans Our project
class ltfx_convexity_adjuster {
public:
    double calculate_convexity_adjusted_forward(
        const ltfx_specification& spec,
        const dbx_model_parameters& params) {

        // Calcul de l'ajustement de convexit√© pour FX long terme
        double base_forward = calculate_base_forward(spec);

        // Ajustement d√ª aux taux stochastiques
        double ir_convexity_adjustment = calculate_ir_convexity_adjustment(spec, params);

        // Ajustement d√ª √† la volatilit√© FX stochastique
        double fx_vol_convexity_adjustment = calculate_fx_vol_convexity_adjustment(spec, params);

        // Ajustement d√ª aux corr√©lations
        double correlation_adjustment = calculate_correlation_adjustment(spec, params);

        return base_forward + ir_convexity_adjustment +
               fx_vol_convexity_adjustment + correlation_adjustment;
    }

private:
    double calculate_ir_convexity_adjustment(
        const ltfx_specification& spec,
        const dbx_model_parameters& params) {

        // Ajustement analytique approximatif pour taux stochastiques
        double domestic_vol = params.domestic_hw.volatilities[0];
        double foreign_vol = params.foreign_hw.volatilities[0];
        double expiry = spec.expiry;

        // Formule d'ajustement de convexit√©
        double adjustment = 0.5 * (domestic_vol * domestic_vol - foreign_vol * foreign_vol) *
                           expiry * expiry;

        return adjustment;
    }
};
```

### **Gestion des Risques Multi-Devises**
- **Delta hedging** automatique avec corr√©lations FX-IR
- **Vega hedging** local et stochastique
- **Rho hedging** multi-devises avec Hull-White
- **Stress testing** r√©glementaire avanc√©

---

## üîç **Surveillance et Contr√¥le Qualit√©**

### **Model Parameter Monitoring Avanc√©**
- **Surveillance automatis√©e** des param√®tres Hull-White via MARS
- **Alertes** sur d√©viations de calibration PIV significatives
- **Monitoring** de la stabilit√© des corr√©lations FX-IR
- **Validation continue** des surfaces de volatilit√© locale

### **Contr√¥les de Coh√©rence Sp√©cialis√©s**
- **Tests de r√©plication** quotidiens pour d√©riv√©s FX long terme
- **Validation crois√©e** avec mod√®les Black-Scholes √©tendus
- **Monitoring des √©carts** de pricing vs benchmarks externes
- **Analyse des tendances** de volatilit√© FX locale vs stochastique

---

*Cette documentation compl√®te du framework DBX-ShortRate_FXSkewStochVol int√®gre les meilleures pratiques de Our project avec une validation rigoureuse et des impl√©mentations techniques avanc√©es pour le pricing Monte Carlo de d√©riv√©s FX long terme avec taux stochastiques et volatilit√© locale stochastique.*
