# Product Testing: InflAssetSwap

## üìä **Vue d'Ensemble du Produit InflAssetSwap**

### **Description du Trade**
Nous consid√©rons un trade **InflAssetSwap** dans un template de s√©curit√© DBA SWAP avec les caract√©ristiques suivantes :

#### **Structure du Produit**
- **Receive Leg** : Paiements semi-annuels bas√©s sur le ratio d'INFLATION avec USCPI comme sous-jacent
- **Pay Leg** : Paiements trimestriels avec Libor plus un spread
- **Date effective** : 15 juillet 2015
- **Date de fin** : 15 juillet 2025
- **Maturit√©** : 10 ans

### **Impl√©mentation dans Our project**

#### **üîß Classe InflAssetSwap**
```cpp
// Impl√©mentation du produit InflAssetSwap dans Our project
class InflAssetSwap : public inflation_product_base {
private:
    struct leg_configuration {
        payment_frequency frequency;
        std::string index_name;
        double spread;
        day_count_convention day_count;
        std::vector<datetime> payment_dates;
    };
    
    leg_configuration receive_leg_;  // Leg inflation
    leg_configuration pay_leg_;      // Leg taux fixe/flottant
    double notional_;
    datetime effective_date_;
    datetime maturity_date_;
    
public:
    InflAssetSwap(double notional,
                  const datetime& effective_date,
                  const datetime& maturity_date,
                  const leg_configuration& receive_leg,
                  const leg_configuration& pay_leg)
        : notional_(notional),
          effective_date_(effective_date),
          maturity_date_(maturity_date),
          receive_leg_(receive_leg),
          pay_leg_(pay_leg) {
        
        // G√©n√©ration des calendriers de paiement
        generate_payment_schedules();
        validate_configuration();
    }
    
    double calculate_pv(const market_data& market) const override {
        double receive_leg_pv = calculate_receive_leg_pv(market);
        double pay_leg_pv = calculate_pay_leg_pv(market);
        
        return receive_leg_pv - pay_leg_pv;
    }
    
private:
    double calculate_receive_leg_pv(const market_data& market) const {
        double total_pv = 0.0;
        
        auto inflation_curve = market.get_inflation_curve(receive_leg_.index_name);
        auto discount_curve = market.get_discount_curve("USD");
        
        for (const auto& payment_date : receive_leg_.payment_dates) {
            if (payment_date <= market.valuation_date) continue;
            
            // Calcul du ratio d'inflation
            double inflation_ratio = calculate_inflation_ratio(
                inflation_curve, payment_date);
            
            // Facteur d'actualisation
            double discount_factor = discount_curve->get_discount_factor(payment_date);
            
            // Contribution au PV
            double cashflow = notional_ * inflation_ratio * 
                            calculate_accrual_factor(payment_date);
            
            total_pv += cashflow * discount_factor;
        }
        
        return total_pv;
    }
    
    double calculate_pay_leg_pv(const market_data& market) const {
        double total_pv = 0.0;
        
        auto libor_curve = market.get_forward_curve("USD_LIBOR_3M");
        auto discount_curve = market.get_discount_curve("USD");
        
        for (const auto& payment_date : pay_leg_.payment_dates) {
            if (payment_date <= market.valuation_date) continue;
            
            // Taux forward Libor
            double forward_rate = libor_curve->get_forward_rate(
                get_fixing_date(payment_date), payment_date);
            
            // Taux total avec spread
            double total_rate = forward_rate + pay_leg_.spread;
            
            // Facteur d'actualisation
            double discount_factor = discount_curve->get_discount_factor(payment_date);
            
            // Contribution au PV
            double cashflow = notional_ * total_rate * 
                            calculate_accrual_factor(payment_date);
            
            total_pv += cashflow * discount_factor;
        }
        
        return total_pv;
    }
};
```
*Cette impl√©mentation C++ dans Our project montre la structure compl√®te d'un InflAssetSwap avec calcul s√©par√© des legs d'inflation et de taux d'int√©r√™t.*

---

## üß™ **4.2.1 EOD Testing**

### **Tests de Fin de Journ√©e**

#### **üîç 4.2.1.1 Cashflow Replication of the Trade**

##### **R√©plication des Cashflows**
```cpp
// R√©plication d√©taill√©e des cashflows pour validation
class inflassetswap_cashflow_replicator {
public:
    struct cashflow_details {
        datetime payment_date;
        datetime fixing_date;
        double inflation_ratio;
        double accrual_factor;
        double discount_factor;
        double cashflow_amount;
        double present_value;
        std::string leg_type; // "RECEIVE" ou "PAY"
    };
    
    std::vector<cashflow_details> replicate_all_cashflows(
        const InflAssetSwap& swap,
        const market_data& market) {
        
        std::vector<cashflow_details> all_cashflows;
        
        // R√©plication receive leg (inflation)
        auto receive_cashflows = replicate_receive_leg(swap, market);
        all_cashflows.insert(all_cashflows.end(), 
                           receive_cashflows.begin(), receive_cashflows.end());
        
        // R√©plication pay leg (libor + spread)
        auto pay_cashflows = replicate_pay_leg(swap, market);
        all_cashflows.insert(all_cashflows.end(),
                           pay_cashflows.begin(), pay_cashflows.end());
        
        return all_cashflows;
    }
    
private:
    std::vector<cashflow_details> replicate_receive_leg(
        const InflAssetSwap& swap,
        const market_data& market) {
        
        std::vector<cashflow_details> cashflows;
        auto inflation_curve = market.get_inflation_curve("USCPI");
        auto discount_curve = market.get_discount_curve("USD");
        
        // Dates de paiement semi-annuelles
        auto payment_dates = generate_semiannual_dates(
            swap.get_effective_date(), swap.get_maturity_date());
        
        for (const auto& payment_date : payment_dates) {
            if (payment_date <= market.valuation_date) continue;
            
            cashflow_details cf;
            cf.payment_date = payment_date;
            cf.fixing_date = get_inflation_fixing_date(payment_date);
            cf.leg_type = "RECEIVE";
            
            // Calcul du ratio d'inflation
            double base_cpi = inflation_curve->cpi(swap.get_effective_date(), tenor("2M"));
            double final_cpi = inflation_curve->cpi(cf.fixing_date, tenor("2M"));
            cf.inflation_ratio = final_cpi / base_cpi;
            
            // Facteur d'accroissement
            cf.accrual_factor = calculate_accrual_factor_30_360(
                get_previous_payment_date(payment_date), payment_date);
            
            // Facteur d'actualisation
            cf.discount_factor = discount_curve->get_discount_factor(payment_date);
            
            // Montant du cashflow
            cf.cashflow_amount = swap.get_notional() * cf.inflation_ratio;
            
            // Valeur pr√©sente
            cf.present_value = cf.cashflow_amount * cf.discount_factor;
            
            cashflows.push_back(cf);
        }
        
        return cashflows;
    }
};
```

##### **Validation de la R√©plication**
```cpp
// Validation que la somme des cashflows r√©pliqu√©s √©gale le PV DBA
void validate_cashflow_replication(const InflAssetSwap& swap,
                                  const market_data& market) {
    // PV calcul√© par DBA
    double dba_pv = swap.calculate_pv(market);
    
    // PV par r√©plication de cashflows
    inflassetswap_cashflow_replicator replicator;
    auto cashflows = replicator.replicate_all_cashflows(swap, market);
    
    double replicated_pv = 0.0;
    for (const auto& cf : cashflows) {
        if (cf.leg_type == "RECEIVE") {
            replicated_pv += cf.present_value;
        } else {
            replicated_pv -= cf.present_value;
        }
    }
    
    // Validation de la coh√©rence
    double replication_error = std::abs(dba_pv - replicated_pv);
    EXPECT_LT(replication_error, 1e-8); // Erreur < 1e-8
    
    std::cout << "DBA PV: " << dba_pv << std::endl;
    std::cout << "Replicated PV: " << replicated_pv << std::endl;
    std::cout << "Replication Error: " << replication_error << std::endl;
}
```

#### **üîç Stability Testing: USD Curve Shift**

##### **Tests de Stabilit√© sous Chocs de Courbe USD**
```cpp
// Tests de stabilit√© sous chocs parall√®les de la courbe USD
class usd_curve_stability_tester {
public:
    struct stability_results {
        std::vector<double> shock_levels;
        std::vector<double> pv_values;
        std::vector<double> usd_flat_deltas;
        std::vector<double> uscpi_flat_deltas;
        std::vector<double> usd_flat_gammas;
        std::vector<double> uscpi_flat_gammas;
    };
    
    stability_results test_usd_curve_stability(
        const InflAssetSwap& swap,
        const market_data& base_market) {
        
        stability_results results;
        
        // Niveaux de choc de -200bp √† +200bp
        for (int shock_bp = -200; shock_bp <= 200; shock_bp += 25) {
            double shock = shock_bp * 1e-4; // Conversion en d√©cimal
            results.shock_levels.push_back(shock_bp);
            
            // Application du choc √† la courbe USD
            auto shocked_market = apply_usd_curve_shock(base_market, shock);
            
            // Calcul des m√©triques
            double pv = swap.calculate_pv(shocked_market);
            results.pv_values.push_back(pv);
            
            // Calcul des sensibilit√©s
            auto sensitivities = calculate_sensitivities(swap, shocked_market);
            results.usd_flat_deltas.push_back(sensitivities.usd_flat_delta);
            results.uscpi_flat_deltas.push_back(sensitivities.uscpi_flat_delta);
            results.usd_flat_gammas.push_back(sensitivities.usd_flat_gamma);
            results.uscpi_flat_gammas.push_back(sensitivities.uscpi_flat_gamma);
        }
        
        // Validation de la stabilit√©
        validate_stability_properties(results);
        
        return results;
    }
    
private:
    void validate_stability_properties(const stability_results& results) {
        // Validation de la monotonie du PV par rapport aux chocs
        for (size_t i = 1; i < results.pv_values.size(); ++i) {
            // Le PV doit varier de mani√®re continue
            double pv_change = results.pv_values[i] - results.pv_values[i-1];
            double shock_change = results.shock_levels[i] - results.shock_levels[i-1];
            
            // Pas de discontinuit√©s majeures
            double relative_change = std::abs(pv_change) / std::abs(results.pv_values[i-1]);
            EXPECT_LT(relative_change, 0.1); // < 10% de changement par step
        }
        
        // Validation de la stabilit√© des deltas
        for (const auto& delta : results.usd_flat_deltas) {
            EXPECT_TRUE(std::isfinite(delta));
            EXPECT_LT(std::abs(delta), 1e6); // Limite raisonnable
        }
    }
};
```

#### **üîç Taylor Expansion Consistency Testing**

##### **Tests de Coh√©rence d'Expansion de Taylor**
```cpp
// Validation de la coh√©rence des approximations de Taylor
class taylor_consistency_tester {
public:
    void test_taylor_consistency(const InflAssetSwap& swap,
                                const market_data& market) {
        
        // Calcul des sensibilit√©s analytiques
        auto base_sensitivities = calculate_sensitivities(swap, market);
        double base_pv = swap.calculate_pv(market);
        
        // Test avec diff√©rentes tailles de choc
        std::vector<double> shock_sizes = {0.1e-4, 0.5e-4, 1.0e-4, 2.0e-4, 5.0e-4};
        
        for (double shock : shock_sizes) {
            // Choc de la courbe USD
            auto shocked_market_usd = apply_usd_curve_shock(market, shock);
            double pv_shocked_usd = swap.calculate_pv(shocked_market_usd);
            
            // Approximation Taylor premier ordre
            double taylor_pv_usd = base_pv + base_sensitivities.usd_flat_delta * shock;
            
            // Erreur relative
            double relative_error_usd = std::abs(pv_shocked_usd - taylor_pv_usd) / 
                                       std::abs(base_pv);
            
            // La convergence doit s'am√©liorer avec des chocs plus petits
            EXPECT_LT(relative_error_usd, tolerance_for_shock_size(shock));
            
            std::cout << "USD Shock: " << shock 
                      << ", PV Shocked: " << pv_shocked_usd
                      << ", Taylor PV: " << taylor_pv_usd
                      << ", Relative Error: " << relative_error_usd << std::endl;
            
            // Test similaire pour la courbe d'inflation
            auto shocked_market_infl = apply_inflation_curve_shock(market, shock);
            double pv_shocked_infl = swap.calculate_pv(shocked_market_infl);
            
            double taylor_pv_infl = base_pv + base_sensitivities.uscpi_flat_delta * shock;
            
            double relative_error_infl = std::abs(pv_shocked_infl - taylor_pv_infl) / 
                                        std::abs(base_pv);
            
            EXPECT_LT(relative_error_infl, tolerance_for_shock_size(shock));
        }
    }
    
private:
    double tolerance_for_shock_size(double shock) const {
        // Tol√©rance qui diminue avec la taille du choc
        return std::min(0.01, shock * 100.0); // Max 1%, proportionnel au choc
    }
};
```

---

## üèõÔ∏è **4.2.2 CCAR Testing**

### **Tests sous Sc√©narios CCAR 2023**

#### **üîç 4.2.2.1 Scenario Curves**

##### **Courbes de Sc√©narios CCAR**
```cpp
// Gestion des sc√©narios CCAR pour InflAssetSwap
class ccar_scenario_manager {
public:
    enum class ccar_scenario_type {
        BASELINE,
        SEVERELY_ADVERSE,
        ADVERSE
    };
    
    struct ccar_scenario_data {
        ccar_scenario_type scenario;
        std::vector<market_data_snapshot> quarterly_snapshots; // 9 trimestres
        std::string description;
    };
    
    std::vector<ccar_scenario_data> load_ccar_2023_scenarios() {
        std::vector<ccar_scenario_data> scenarios;
        
        // Sc√©nario Baseline
        ccar_scenario_data baseline;
        baseline.scenario = ccar_scenario_type::BASELINE;
        baseline.description = "CCAR 2023 Baseline Scenario";
        baseline.quarterly_snapshots = load_baseline_quarterly_data();
        scenarios.push_back(baseline);
        
        // Sc√©nario Severely Adverse
        ccar_scenario_data severely_adverse;
        severely_adverse.scenario = ccar_scenario_type::SEVERELY_ADVERSE;
        severely_adverse.description = "CCAR 2023 Severely Adverse Scenario";
        severely_adverse.quarterly_snapshots = load_severely_adverse_quarterly_data();
        scenarios.push_back(severely_adverse);
        
        // Sc√©nario Adverse
        ccar_scenario_data adverse;
        adverse.scenario = ccar_scenario_type::ADVERSE;
        adverse.description = "CCAR 2023 Adverse Scenario";
        adverse.quarterly_snapshots = load_adverse_quarterly_data();
        scenarios.push_back(adverse);
        
        return scenarios;
    }
    
    void plot_scenario_curves(const std::vector<ccar_scenario_data>& scenarios) {
        // G√©n√©ration de graphiques comparatifs des courbes de sc√©narios
        for (const auto& scenario : scenarios) {
            for (int quarter = 1; quarter <= 9; ++quarter) {
                const auto& market_data = scenario.quarterly_snapshots[quarter-1];
                
                // Extraction des taux zero USD
                auto usd_curve = market_data.get_discount_curve("USD");
                
                std::vector<double> maturities = {0.25, 0.5, 1, 2, 3, 5, 7, 10, 15, 20, 30};
                std::vector<double> zero_rates;
                
                for (double maturity : maturities) {
                    datetime maturity_date = market_data.valuation_date + 
                                           days(static_cast<int>(maturity * 365));
                    double zero_rate = usd_curve->get_zero_rate(maturity_date);
                    zero_rates.push_back(zero_rate);
                }
                
                // Sauvegarde pour plotting
                save_curve_data_for_plotting(scenario.description, quarter, 
                                            maturities, zero_rates);
            }
        }
    }
};
```

#### **üîç 4.2.2.2 Stability Testing: USD Curve Shift**

##### **Tests de Stabilit√© sous CCAR**
```cpp
// Tests de stabilit√© sous sc√©narios CCAR
void test_ccar_stability(const InflAssetSwap& swap) {
    ccar_scenario_manager manager;
    auto scenarios = manager.load_ccar_2023_scenarios();
    
    for (const auto& scenario : scenarios) {
        std::cout << "Testing scenario: " << scenario.description << std::endl;
        
        for (int quarter = 1; quarter <= 9; ++quarter) {
            const auto& market_data = scenario.quarterly_snapshots[quarter-1];
            
            // Tests de stabilit√© avec chocs additionnels
            for (int shock_bp = -100; shock_bp <= 100; shock_bp += 25) {
                double shock = shock_bp * 1e-4;
                
                auto shocked_market = apply_usd_curve_shock(market_data, shock);
                
                // Calcul des m√©triques
                double pv = swap.calculate_pv(shocked_market);
                auto sensitivities = calculate_sensitivities(swap, shocked_market);
                
                // Validation de stabilit√©
                EXPECT_TRUE(std::isfinite(pv));
                EXPECT_TRUE(std::isfinite(sensitivities.usd_flat_delta));
                EXPECT_TRUE(std::isfinite(sensitivities.usd_flat_gamma));
                
                // Documentation des r√©sultats
                document_ccar_stability_result(scenario.scenario, quarter, 
                                             shock_bp, pv, sensitivities);
            }
        }
    }
}
```

---

## üìä **4.2.3 IRRBB Testing**

### **Tests sous Framework IRRBB**

#### **üîç Scenario Curves et Stability Testing**
```cpp
// Tests IRRBB pour InflAssetSwap
class irrbb_testing_framework {
public:
    void run_irrbb_tests(const InflAssetSwap& swap, const market_data& base_market) {
        // Sc√©narios IRRBB standard
        std::vector<irrbb_scenario> scenarios = {
            create_parallel_up_scenario(200),      // +200bp parall√®le
            create_parallel_down_scenario(200),    // -200bp parall√®le
            create_steepener_scenario(),           // Steepener
            create_flattener_scenario(),           // Flattener
            create_short_rate_up_scenario(200),    // Short rates +200bp
            create_short_rate_down_scenario(200)   // Short rates -200bp
        };
        
        double base_eve = calculate_economic_value_equity(swap, base_market);
        
        for (const auto& scenario : scenarios) {
            auto stressed_market = apply_irrbb_scenario(base_market, scenario);
            double stressed_eve = calculate_economic_value_equity(swap, stressed_market);
            
            double delta_eve = stressed_eve - base_eve;
            double eve_ratio = std::abs(delta_eve) / base_eve;
            
            // Validation contre limites r√©glementaires
            validate_irrbb_limits(scenario.name, eve_ratio);
            
            // Tests de stabilit√© sous chocs additionnels
            test_stability_under_irrbb_scenario(swap, stressed_market, scenario);
        }
    }
};
```

---

*Cette section fournit une documentation compl√®te des tests de produit pour InflAssetSwap, int√©grant les impl√©mentations C++ de Our project avec des m√©thodologies de validation rigoureuses sous diff√©rents frameworks r√©glementaires.*
