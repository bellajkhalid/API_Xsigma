# Model Calibration & Risk Sensitivities

## üéØ **Model Calibration**

### **Approche de Calibration D√©terministe**
Les mod√®les **DBOPT-RateDeterministic_InflationDeterministic** et **DBX-RateDeterministic_InflationDeterministic** utilisent une approche de calibration simplifi√©e en raison de leur nature d√©terministe.

#### **Absence de Calibration de Volatilit√©**
√âtant donn√© que les mod√®les DBOPT-RateDeterministic_InflationDeterministic et DBX-RateDeterministic_InflationDeterministic n'utilisent aucun objet de volatilit√©, **aucune calibration de volatilit√© n'est requise**.

#### **Construction de Courbes**
Pour les d√©tails sur les m√©thodologies de construction de courbes, nous r√©f√©rons au **curve primer [3]** qui documente les approches suivantes :

### **M√©thodologies de Construction de Courbe**

#### **üîß Bootstrapping des Courbes d'Inflation**
```cpp
// Impl√©mentation de bootstrapping dans Our project
class inflation_curve_builder {
private:
    std::vector<market_instrument> instruments_;
    interpolation_enum interpolation_method_;
    
public:
    inflation_curve_builder(
        const std::vector<market_instrument>& instruments,
        interpolation_enum method = interpolation_enum::LINEAR)
        : instruments_(instruments), interpolation_method_(method) {}
    
    std::shared_ptr<inflation_curve> build_curve() {
        // Tri des instruments par maturit√©
        std::sort(instruments_.begin(), instruments_.end(),
                 [](const auto& a, const auto& b) {
                     return a.maturity < b.maturity;
                 });
        
        // Bootstrapping s√©quentiel
        std::vector<double> discount_factors;
        for (const auto& instrument : instruments_) {
            double df = bootstrap_discount_factor(instrument);
            discount_factors.push_back(df);
        }
        
        return create_interpolated_curve(discount_factors);
    }
    
private:
    double bootstrap_discount_factor(const market_instrument& instrument) {
        // Calcul du facteur d'actualisation pour l'instrument
        if (instrument.type == instrument_type::ZC_SWAP) {
            return bootstrap_zc_swap(instrument);
        } else if (instrument.type == instrument_type::YOY_SWAP) {
            return bootstrap_yoy_swap(instrument);
        }
        throw std::invalid_argument("Unsupported instrument type");
    }
};
```
*Cette impl√©mentation C++ dans Our project montre comment construire une courbe d'inflation par bootstrapping s√©quentiel des instruments de march√©, en utilisant diff√©rentes m√©thodes d'interpolation selon les besoins.*

#### **Instruments de March√© Support√©s**
- **Inflation Forwards** : Contrats √† terme sur indices d'inflation
- **Zero-Coupon Swaps** : Swaps d'inflation zero-coupon
- **Year-on-Year Swaps** : Swaps d'inflation annuels

#### **M√©thodes d'Interpolation**
| M√©thode | Description | Avantages | Inconv√©nients |
|---------|-------------|-----------|---------------|
| **LINEAR** | Interpolation lin√©aire | Simple, stable | Peut cr√©er des discontinuit√©s |
| **PWCONST_L** | Constante par morceaux (gauche) | Continuit√© garantie | Moins lisse |
| **CUBIC** | Interpolation cubique | Tr√®s lisse | Plus complexe |
| **FLAT** | Interpolation plate | Tr√®s stable | Moins pr√©cise |

---

## üìä **Risk Sensitivities**

### **Sensibilit√©s Calcul√©es par le Mod√®le**
Le tableau suivant liste les sensibilit√©s de risque retourn√©es par le mod√®le, avec leurs modes DBA correspondants :

| Sensibilit√© | Mode DBA | Description | Unit√© |
|-------------|----------|-------------|-------|
| **Delta** | DELTA | Sensibilit√© au premier ordre aux mouvements de courbe | bp |
| **Gamma** | GAMMA | Sensibilit√© au second ordre | bp¬≤ |
| **OIS Spread Delta** | OISSPREAD | Sensibilit√© aux spreads OIS | bp |
| **Discount Spread Delta** | DISCOUNTSPREAD | Sensibilit√© aux spreads de discount | bp |
| **Spot Libor Spread Delta** | LIBORSPREAD | Sensibilit√© aux spreads Libor spot | bp |
| **Inflation Delta** | INFLATIONDELTA | Sensibilit√© aux mouvements d'inflation | bp |

### **Impl√©mentation des Sensibilit√©s dans Our project**

#### **Calcul des Deltas**
```cpp
// Calcul des sensibilit√©s Delta pour produits d'inflation
class inflation_product_sensitivities {
public:
    struct sensitivity_results {
        double ir_delta;           // Delta taux d'int√©r√™t
        double inflation_delta;    // Delta inflation
        double ois_spread_delta;   // Delta spread OIS
        double discount_spread_delta; // Delta spread discount
        std::map<std::string, double> bucket_deltas; // Deltas par bucket
    };
    
    sensitivity_results calculate_sensitivities(
        const inflation_product& product,
        const market_data& market) {
        
        sensitivity_results results;
        
        // Delta taux d'int√©r√™t par diff√©rences finies
        results.ir_delta = calculate_ir_delta(product, market);
        
        // Delta inflation
        results.inflation_delta = calculate_inflation_delta(product, market);
        
        // Deltas de spreads
        results.ois_spread_delta = calculate_ois_spread_delta(product, market);
        results.discount_spread_delta = calculate_discount_spread_delta(product, market);
        
        // Deltas par bucket (par maturit√©)
        results.bucket_deltas = calculate_bucket_deltas(product, market);
        
        return results;
    }
    
private:
    double calculate_ir_delta(const inflation_product& product, 
                             const market_data& market) {
        const double shock_size = 1e-4; // 1 bp
        
        // PV avec choc positif
        auto market_up = shock_ir_curve(market, +shock_size);
        double pv_up = product.calculate_pv(market_up);
        
        // PV avec choc n√©gatif
        auto market_down = shock_ir_curve(market, -shock_size);
        double pv_down = product.calculate_pv(market_down);
        
        // Delta par diff√©rences finies centr√©es
        return (pv_up - pv_down) / (2.0 * shock_size);
    }
    
    double calculate_inflation_delta(const inflation_product& product,
                                   const market_data& market) {
        const double shock_size = 1e-4; // 1 bp
        
        auto market_up = shock_inflation_curve(market, +shock_size);
        double pv_up = product.calculate_pv(market_up);
        
        auto market_down = shock_inflation_curve(market, -shock_size);
        double pv_down = product.calculate_pv(market_down);
        
        return (pv_up - pv_down) / (2.0 * shock_size);
    }
};
```
*Cette impl√©mentation C++ dans Our project montre comment calculer les diff√©rentes sensibilit√©s de risque pour les produits d'inflation en utilisant des m√©thodes de diff√©rences finies robustes.*

#### **Calcul des Gammas**
```cpp
// Calcul des sensibilit√©s Gamma (second ordre)
double calculate_gamma(const inflation_product& product,
                      const market_data& market,
                      risk_factor_type factor_type) {
    const double shock_size = 1e-4; // 1 bp
    
    // PV central
    double pv_center = product.calculate_pv(market);
    
    // PV avec chocs
    auto market_up = shock_market(market, factor_type, +shock_size);
    auto market_down = shock_market(market, factor_type, -shock_size);
    
    double pv_up = product.calculate_pv(market_up);
    double pv_down = product.calculate_pv(market_down);
    
    // Gamma par diff√©rences finies du second ordre
    return (pv_up - 2.0 * pv_center + pv_down) / (shock_size * shock_size);
}
```

### **Validation des Sensibilit√©s**

#### **Tests de Coh√©rence Taylor**
```cpp
// Validation de la coh√©rence des sensibilit√©s via expansion de Taylor
void validate_taylor_consistency(const inflation_product& product,
                                const market_data& market) {
    auto sensitivities = calculate_sensitivities(product, market);
    
    // Test avec diff√©rentes tailles de choc
    std::vector<double> shock_sizes = {0.1e-4, 0.5e-4, 1.0e-4, 2.0e-4, 5.0e-4};
    
    for (double shock : shock_sizes) {
        // PV avec choc
        auto market_shocked = shock_ir_curve(market, shock);
        double pv_shocked = product.calculate_pv(market_shocked);
        double pv_base = product.calculate_pv(market);
        
        // Approximation Taylor au premier ordre
        double taylor_pv = pv_base + sensitivities.ir_delta * shock;
        
        // Erreur relative
        double relative_error = std::abs(pv_shocked - taylor_pv) / std::abs(pv_base);
        
        // La convergence doit s'am√©liorer avec des chocs plus petits
        EXPECT_LT(relative_error, tolerance_for_shock(shock));
        
        std::cout << "Shock: " << shock << ", Error: " << relative_error << std::endl;
    }
}
```

---

## üéØ **Model Outputs**

### **Outputs Principaux**
Le mod√®le peut extraire les outputs suivants :

#### **üìà Present Value (PV)**
- **PV total** du produit ou portefeuille
- **PV par leg** pour les swaps
- **PV par cashflow** pour analyse d√©taill√©e

#### **üìä Risk Sensitivities ("Greeks")**
- **Delta** : Sensibilit√© aux changements de param√®tres
- **Gamma** : Sensibilit√© du second ordre
- **Vega** : Non applicable (mod√®le d√©terministe)
- **Theta** : Sensibilit√© au temps

#### **üîß Sensibilit√©s Sp√©cialis√©es**
- **OIS Spread Delta** : Sensibilit√© aux spreads OIS
- **Discount Spread Delta** : Sensibilit√© aux spreads de discount
- **Spot Libor Spread Delta** : Sensibilit√© aux spreads Libor spot

### **Format des Outputs**

#### **Structure de Donn√©es**
```cpp
// Structure des outputs du mod√®le dans Our project
struct model_outputs {
    // Valeurs principales
    double present_value;
    double accrued_interest;
    
    // Sensibilit√©s de premier ordre
    std::map<std::string, double> deltas;
    
    // Sensibilit√©s de second ordre
    std::map<std::string, double> gammas;
    
    // Sensibilit√©s par bucket
    std::map<std::string, std::vector<double>> bucket_sensitivities;
    
    // M√©tadonn√©es
    datetime calculation_date;
    std::string model_version;
    std::map<std::string, std::string> parameters;
    
    // M√©thodes d'acc√®s
    double get_delta(const std::string& risk_factor) const {
        auto it = deltas.find(risk_factor);
        return (it != deltas.end()) ? it->second : 0.0;
    }
    
    double get_gamma(const std::string& risk_factor) const {
        auto it = gammas.find(risk_factor);
        return (it != gammas.end()) ? it->second : 0.0;
    }
};
```

#### **Reporting et Export**
```cpp
// Export des r√©sultats vers diff√©rents formats
class results_exporter {
public:
    void export_to_csv(const model_outputs& outputs, 
                      const std::string& filename) {
        std::ofstream file(filename);
        
        // Header
        file << "Metric,Value,Unit\n";
        
        // PV
        file << "Present Value," << outputs.present_value << ",USD\n";
        
        // Deltas
        for (const auto& [factor, delta] : outputs.deltas) {
            file << "Delta_" << factor << "," << delta << ",bp\n";
        }
        
        // Gammas
        for (const auto& [factor, gamma] : outputs.gammas) {
            file << "Gamma_" << factor << "," << gamma << ",bp^2\n";
        }
    }
    
    void export_to_json(const model_outputs& outputs,
                       const std::string& filename) {
        nlohmann::json j;
        
        j["present_value"] = outputs.present_value;
        j["calculation_date"] = outputs.calculation_date.to_string();
        j["deltas"] = outputs.deltas;
        j["gammas"] = outputs.gammas;
        j["parameters"] = outputs.parameters;
        
        std::ofstream file(filename);
        file << j.dump(4);
    }
};
```

---

## üîç **Validation et Contr√¥le Qualit√©**

### **Tests de Coh√©rence des Outputs**
```cpp
// Tests de validation des outputs
void validate_model_outputs(const model_outputs& outputs) {
    // Validation des valeurs finies
    EXPECT_TRUE(std::isfinite(outputs.present_value));
    
    // Validation des sensibilit√©s
    for (const auto& [factor, delta] : outputs.deltas) {
        EXPECT_TRUE(std::isfinite(delta));
        EXPECT_LT(std::abs(delta), MAX_REASONABLE_DELTA);
    }
    
    // Validation de coh√©rence Delta-Gamma
    for (const auto& [factor, gamma] : outputs.gammas) {
        EXPECT_TRUE(std::isfinite(gamma));
        
        // Gamma doit √™tre coh√©rent avec Delta
        if (outputs.deltas.count(factor)) {
            validate_delta_gamma_consistency(
                outputs.get_delta(factor), 
                gamma, 
                factor
            );
        }
    }
}
```

### **Monitoring des Performances**
- **Temps de calcul** : Surveillance des performances
- **Pr√©cision num√©rique** : Validation de la stabilit√©
- **Coh√©rence temporelle** : V√©rification de la continuit√©

---

*Cette section fournit une documentation compl√®te de la calibration et des sensibilit√©s de risque pour les mod√®les DBOPT, int√©grant les impl√©mentations C++ de Our project avec des m√©thodologies de validation rigoureuses.*
