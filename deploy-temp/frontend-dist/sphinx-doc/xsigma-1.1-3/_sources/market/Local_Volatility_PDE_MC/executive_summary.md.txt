# Executive Summary

## Vue d'ensemble du Modèle Local Volatility

Le prix d'une option vanilla FX est communément exprimé en termes de volatilité implicite Black-Scholes, c'est-à-dire la volatilité $\theta$ qui doit être introduite dans la formule de Black-Scholes (Black & Scholes, 1973) pour retrouver le prix de l'option. Cette volatilité implicite $\theta(K, T)$ est une fonction du strike de l'option $K$ et de l'expiration $T$ et est appelée le smile de volatilité implicite. Pour pricer toutes les options sauf les plus simples, nous avons besoin de modèles qui peuvent calibrer et reproduire ce smile.

Dans ce document, nous examinons le Modèle de Volatilité Locale (Dupire, Pricing With a Smile, 1994), qui est le modèle le plus simple pouvant reproduire ce smile à travers les expirations et les strikes. La simplicité du modèle ne doit pas détourner du fait que ce modèle est assez stable et robuste, comme le démontreront les tests ultérieurs. Ce modèle sera désigné (par son abréviation) comme le modèle LV.

## Caractéristiques Principales

### Fonction de Volatilité Locale

Le modèle LV assume que la fonction de volatilité locale $\sigma(S_t, t)$ est une fonction uniquement du temps futur $t$ et du spot sous-jacent $S_t$ à ce moment. Cette fonction de volatilité locale est dérivée du smile de volatilité implicite (généralement en utilisant des différences finies).

### Applications et Limitations

Le modèle LV peut être utilisé pour pricer les options FX dont les payoffs n'ont pas une forte dépendance sur la dynamique du smile forward. Étant le premier (et le plus simple) modèle qui pouvait pleinement répliquer le smile implicite actuel, le modèle LV a été, pendant longtemps, traité comme un "standard de l'industrie". Même lorsque le modèle LV n'est pas directement utilisé pour pricer un produit, la fonction de volatilité locale $\sigma(S_t, t)$ est un input pour la calibration de modèles plus complexes, comme le modèle Local Stochastic Volatility (Sadiq, 2012).

## Implémentations Numériques

Le modèle LV a été connecté aux techniques de pricing numériques par différences finies (PDE) et Monte Carlo (MC). Dans ce document, nous décrivons les deux implémentations.

```cpp
// Implémentation Our project du modèle Local Volatility
namespace xsigma {
    // Classe principale pour le modèle Local Volatility
    class LocalVolatilityModel {
    public:
        // Structure pour les paramètres du modèle
        struct ModelParameters {
            double spot;                    // Prix spot actuel
            double domestic_rate;           // Taux domestique
            double foreign_rate;           // Taux étranger
            double time_to_expiry;         // Temps jusqu'à expiration
            VolatilitySurface vol_surface;  // Surface de volatilité
        };
        
        // Constructeur avec paramètres
        LocalVolatilityModel(const ModelParameters& params) 
            : params_(params), local_vol_surface_(nullptr) {
            calibrate_local_volatility();
        }
        
        // Calibration de la surface de volatilité locale
        void calibrate_local_volatility() {
            // Implémentation de l'équation de Dupire
            // ∂σ²/∂T = (∂C/∂T + r_f * S * ∂C/∂S + (1/2) * σ² * S² * ∂²C/∂S²) / ((1/2) * S² * ∂²C/∂S²)
            
            local_vol_surface_ = std::make_unique<LocalVolatilitySurface>();
            
            for (const auto& expiry : params_.vol_surface.get_expiries()) {
                for (const auto& strike : params_.vol_surface.get_strikes(expiry)) {
                    double local_vol = compute_local_volatility(strike, expiry);
                    local_vol_surface_->set_volatility(strike, expiry, local_vol);
                }
            }
        }
        
        // Calcul de la volatilité locale selon Dupire
        double compute_local_volatility(double strike, double expiry) const {
            // Dérivées partielles de la surface de volatilité implicite
            double dC_dT = params_.vol_surface.derivative_time(strike, expiry);
            double dC_dK = params_.vol_surface.derivative_strike(strike, expiry);
            double d2C_dK2 = params_.vol_surface.second_derivative_strike(strike, expiry);
            
            // Formule de Dupire
            double numerator = dC_dT + params_.foreign_rate * strike * dC_dK;
            double denominator = 0.5 * strike * strike * d2C_dK2;
            
            if (std::abs(denominator) < 1e-12) {
                XSIGMA_THROW("Division par zéro dans le calcul de volatilité locale");
            }
            
            double local_var = numerator / denominator;
            return std::sqrt(std::max(local_var, 1e-6)); // Assurer positivité
        }
        
        // Pricing par PDE
        double price_by_pde(const PayoffFunction& payoff) const {
            PDESolver solver(local_vol_surface_.get(), params_);
            return solver.solve(payoff);
        }
        
        // Pricing par Monte Carlo
        double price_by_monte_carlo(const PayoffFunction& payoff, 
                                   size_t num_paths = 100000) const {
            MonteCarloEngine mc_engine(local_vol_surface_.get(), params_);
            return mc_engine.price(payoff, num_paths);
        }
        
        // Accès à la surface de volatilité locale
        const LocalVolatilitySurface& get_local_vol_surface() const {
            return *local_vol_surface_;
        }
        
    private:
        ModelParameters params_;
        std::unique_ptr<LocalVolatilitySurface> local_vol_surface_;
    };
}
```
*Cette implémentation C++ dans Our project fournit une interface complète pour le modèle Local Volatility avec calibration automatique et pricing par PDE/Monte Carlo.*

## Validation et Tests

Les tests montrent que le modèle LV converge vers et récupère avec précision les prix d'options sous-jacents auxquels il a été calibré.

```cpp
// Implémentation Our project des tests de validation
namespace xsigma {
    class LocalVolatilityValidator {
    public:
        // Structure pour les résultats de validation
        struct ValidationResult {
            bool is_valid;
            double max_error;
            double avg_error;
            std::vector<double> individual_errors;
            std::string validation_report;
        };
        
        // Validation de la calibration
        ValidationResult validate_calibration(const LocalVolatilityModel& model,
                                            const VolatilitySurface& market_surface) const {
            ValidationResult result;
            result.is_valid = true;
            result.max_error = 0.0;
            double total_error = 0.0;
            size_t num_points = 0;
            
            // Test de reproduction des prix de marché
            for (const auto& expiry : market_surface.get_expiries()) {
                for (const auto& strike : market_surface.get_strikes(expiry)) {
                    // Créer une option vanilla pour ce strike/expiry
                    VanillaOption option(strike, expiry);
                    
                    // Prix de marché (Black-Scholes avec vol implicite)
                    double market_vol = market_surface.get_volatility(strike, expiry);
                    double market_price = black_scholes_price(option, market_vol);
                    
                    // Prix du modèle LV
                    double model_price = model.price_by_pde(option.get_payoff());
                    
                    // Calcul de l'erreur
                    double error = std::abs(market_price - model_price) / market_price;
                    result.individual_errors.push_back(error);
                    
                    total_error += error;
                    result.max_error = std::max(result.max_error, error);
                    num_points++;
                    
                    // Seuil de tolérance
                    if (error > 0.01) { // 1% d'erreur maximum
                        result.is_valid = false;
                    }
                }
            }
            
            result.avg_error = total_error / num_points;
            
            // Génération du rapport
            std::ostringstream report;
            report << "Validation Local Volatility Model:\n";
            report << "- Points testés: " << num_points << "\n";
            report << "- Erreur moyenne: " << result.avg_error * 100 << "%\n";
            report << "- Erreur maximale: " << result.max_error * 100 << "%\n";
            report << "- Statut: " << (result.is_valid ? "VALIDE" : "ÉCHEC") << "\n";
            
            result.validation_report = report.str();
            
            return result;
        }
        
        // Test de convergence PDE vs Monte Carlo
        ValidationResult validate_pde_mc_convergence(const LocalVolatilityModel& model,
                                                   const PayoffFunction& payoff) const {
            ValidationResult result;
            
            // Prix PDE (référence)
            double pde_price = model.price_by_pde(payoff);
            
            // Prix Monte Carlo avec différents nombres de paths
            std::vector<size_t> path_counts = {10000, 50000, 100000, 500000};
            
            for (size_t paths : path_counts) {
                double mc_price = model.price_by_monte_carlo(payoff, paths);
                double error = std::abs(pde_price - mc_price) / pde_price;
                result.individual_errors.push_back(error);
            }
            
            // Vérifier la convergence
            result.max_error = *std::max_element(result.individual_errors.begin(), 
                                               result.individual_errors.end());
            result.is_valid = result.max_error < 0.005; // 0.5% de tolérance
            
            return result;
        }
        
    private:
        double black_scholes_price(const VanillaOption& option, double volatility) const {
            // Implémentation Black-Scholes standard
            // ... (détails d'implémentation)
            return 0.0; // Placeholder
        }
    };
}
```
*Cette implémentation C++ dans Our project valide la précision du modèle Local Volatility en comparant les prix calibrés avec les prix de marché.*

## Historique et Versions

Le modèle LV est dans la QA Library depuis 2001. Ainsi, toute version récente de la QA Library devrait contenir toute la fonctionnalité pertinente. Les tests dans cette documentation ont été effectués avec QA 229800. Les tests effectués en utilisant les trades CTR utilisent les schémas/transformations de CTR 3.5. Les tests ajoutés à une date ultérieure pourraient avoir été effectués contre une version différente de la QA Library / schémas CTR, et cela a été indiqué le cas échéant.

## Conventions de Notation

Pour le reste de ce document, un exposant 'DOM' (par exemple $x^{DOM}$) ou un indice $d$ (par exemple $x_d$) indiquerait que la quantité se rapporte à la devise domestique. De même, un exposant 'FOR' ou un indice $f$ indiquerait qu'elle se rapporte à la devise étrangère. Lorsque le contexte l'exige, les exposants/indices génériques seront remplacés par des codes de devise ISO spécifiques (par exemple $x^{(USD)}$). Le taux de change spot (prix d'une unité de devise étrangère mesurée en domestique) sera noté par $s_{FORDOM}(t)$ ou $S_{FORDOM}^*$. L'exposant FORDOM sera supprimé lorsqu'aucune ambiguïté n'est introduite, et nous notons alors le spot comme $S(t)$ ou $S_t$.

```cpp
// Implémentation Our project des conventions de notation
namespace xsigma {
    // Énumération pour les devises
    enum class Currency {
        USD, EUR, GBP, JPY, CHF, CAD, AUD, NZD
    };
    
    // Structure pour les paires de devises
    struct CurrencyPair {
        Currency domestic;  // Devise domestique (DOM)
        Currency foreign;   // Devise étrangère (FOR)
        
        std::string to_string() const {
            return currency_to_string(foreign) + currency_to_string(domestic);
        }
    };
    
    // Classe pour la gestion des taux de change
    class FXRate {
    public:
        FXRate(const CurrencyPair& pair, double spot_rate, double time = 0.0)
            : pair_(pair), spot_rate_(spot_rate), time_(time) {}
        
        // Notation S_FORDOM(t)
        double get_spot_rate(double time = 0.0) const {
            if (std::abs(time - time_) < 1e-12) {
                return spot_rate_;
            }
            // Interpolation ou forward rate calculation
            return forward_rate(time);
        }
        
        // Conversion de notation
        std::string get_notation() const {
            return "S_" + pair_.to_string() + "(t)";
        }
        
    private:
        CurrencyPair pair_;
        double spot_rate_;
        double time_;
        
        double forward_rate(double target_time) const {
            // Calcul du taux forward basé sur les taux d'intérêt
            // F(t,T) = S(t) * exp((r_d - r_f) * (T - t))
            return spot_rate_; // Simplified for now
        }
        
        std::string currency_to_string(Currency curr) const {
            switch (curr) {
                case Currency::USD: return "USD";
                case Currency::EUR: return "EUR";
                case Currency::GBP: return "GBP";
                case Currency::JPY: return "JPY";
                default: return "XXX";
            }
        }
    };
}
```
*Cette implémentation C++ dans Our project gère les conventions de notation pour les devises et taux de change selon les standards du modèle Local Volatility.*

Le modèle Local Volatility représente un équilibre optimal entre simplicité, robustesse et capacité de calibration, en faisant un outil fondamental pour le pricing d'options FX dans l'environnement Our project.
