# Independent Validation Testing

## üß™ **Model Specific Testing**

### **Vue d'Ensemble des Tests**
Cette section pr√©sente les tests de validation ind√©pendants effectu√©s pour v√©rifier le comportement du mod√®le **DBSMC-RateDeterministic_FXMarket** dans le pricing de d√©riv√©s FX avec taux d√©terministes, incluant la validation des formules analytiques et des surfaces de volatilit√©.

### **M√©thodologie de Test**
Les tests sont organis√©s en plusieurs phases sp√©cialis√©es :
1. **Tests de Formules Analytiques**
2. **Tests de Surfaces de Volatilit√©**
3. **Tests de Sensibilit√©s (Greeks)**
4. **Tests sous Frameworks R√©glementaires**

---

## üìä **Tests de Formules Analytiques**

### **üîç Test 1 : Validation Black-Scholes**

#### **Objectif**
V√©rifier l'exactitude des impl√©mentations Black-Scholes contre les formules th√©oriques.

#### **M√©thodologie**
```cpp
// Tests de validation Black-Scholes dans Our project
class black_scholes_validation_tester {
public:
    struct validation_test_case {
        double spot;
        double strike;
        double expiry;
        double dom_rate;
        double for_rate;
        double volatility;
        bool is_call;
        std::string description;
    };
    
    struct validation_results {
        std::vector<double> pricing_errors;
        std::vector<double> delta_errors;
        std::vector<double> gamma_errors;
        std::vector<double> vega_errors;
        bool all_tests_passed;
    };
    
    validation_results run_black_scholes_validation() {
        validation_results results;
        
        // Cas de test vari√©s
        std::vector<validation_test_case> test_cases = {
            {1.0, 1.0, 1.0, 0.05, 0.03, 0.2, true, "ATM Call"},
            {1.0, 1.1, 1.0, 0.05, 0.03, 0.2, true, "OTM Call"},
            {1.0, 0.9, 1.0, 0.05, 0.03, 0.2, true, "ITM Call"},
            {1.0, 1.0, 1.0, 0.05, 0.03, 0.2, false, "ATM Put"},
            {1.2, 1.0, 0.5, 0.02, 0.01, 0.15, true, "Short Expiry"},
            {0.8, 1.0, 2.0, 0.08, 0.06, 0.35, false, "Long Expiry High Vol"}
        };
        
        for (const auto& test_case : test_cases) {
            // Calcul avec notre impl√©mentation
            auto our_result = fx_black_scholes_engine::calculate_option_metrics(
                test_case.spot, test_case.strike, test_case.expiry,
                test_case.dom_rate, test_case.for_rate, test_case.volatility,
                test_case.is_call);
            
            // Calcul avec impl√©mentation de r√©f√©rence
            auto reference_result = calculate_reference_black_scholes(test_case);
            
            // Calcul des erreurs
            double price_error = std::abs(our_result.price - reference_result.price);
            double delta_error = std::abs(our_result.delta - reference_result.delta);
            double gamma_error = std::abs(our_result.gamma - reference_result.gamma);
            double vega_error = std::abs(our_result.vega - reference_result.vega);
            
            results.pricing_errors.push_back(price_error);
            results.delta_errors.push_back(delta_error);
            results.gamma_errors.push_back(gamma_error);
            results.vega_errors.push_back(vega_error);
            
            // Validation des tol√©rances
            EXPECT_LT(price_error, 1e-12);
            EXPECT_LT(delta_error, 1e-12);
            EXPECT_LT(gamma_error, 1e-10);
            EXPECT_LT(vega_error, 1e-10);
        }
        
        // Validation globale
        results.all_tests_passed = validate_all_errors_within_tolerance(results);
        
        return results;
    }
    
private:
    fx_black_scholes_engine::bs_result calculate_reference_black_scholes(
        const validation_test_case& test_case) {
        
        // Impl√©mentation de r√©f√©rence ind√©pendante
        double forward = test_case.spot * std::exp(
            (test_case.dom_rate - test_case.for_rate) * test_case.expiry);
        
        double sqrt_t = std::sqrt(test_case.expiry);
        double vol_sqrt_t = test_case.volatility * sqrt_t;
        
        double d1 = (std::log(forward / test_case.strike) + 
                    0.5 * test_case.volatility * test_case.volatility * test_case.expiry) / vol_sqrt_t;
        double d2 = d1 - vol_sqrt_t;
        
        double discount_factor = std::exp(-test_case.dom_rate * test_case.expiry);
        
        fx_black_scholes_engine::bs_result result;
        
        // Prix
        if (test_case.is_call) {
            result.price = discount_factor * (forward * normal_cdf(d1) - 
                                            test_case.strike * normal_cdf(d2));
        } else {
            result.price = discount_factor * (test_case.strike * normal_cdf(-d2) - 
                                            forward * normal_cdf(-d1));
        }
        
        // Greeks (impl√©mentation de r√©f√©rence)
        double phi_d1 = normal_pdf(d1);
        result.delta = discount_factor * normal_cdf(test_case.is_call ? d1 : -d1);
        result.gamma = discount_factor * phi_d1 / (test_case.spot * vol_sqrt_t);
        result.vega = discount_factor * forward * phi_d1 * sqrt_t;
        
        return result;
    }
};
```
*Cette impl√©mentation C++ dans Our project teste la validation Black-Scholes avec une impl√©mentation de r√©f√©rence ind√©pendante et des cas de test vari√©s.*

### **üîç Test 2 : Put-Call Parity**

#### **Tests de Coh√©rence Put-Call Parity**
```cpp
// Tests de put-call parity dans Our project
class put_call_parity_tester {
public:
    void test_put_call_parity_comprehensive() {
        // Grille de param√®tres de test
        std::vector<double> spots = {0.8, 1.0, 1.2};
        std::vector<double> strikes = {0.9, 1.0, 1.1};
        std::vector<double> expiries = {0.25, 1.0, 2.0};
        std::vector<double> dom_rates = {0.01, 0.05, 0.08};
        std::vector<double> for_rates = {0.02, 0.03, 0.06};
        std::vector<double> volatilities = {0.1, 0.2, 0.4};
        
        for (double spot : spots) {
            for (double strike : strikes) {
                for (double expiry : expiries) {
                    for (double dom_rate : dom_rates) {
                        for (double for_rate : for_rates) {
                            for (double volatility : volatilities) {
                                test_single_put_call_parity(
                                    spot, strike, expiry, dom_rate, for_rate, volatility);
                            }
                        }
                    }
                }
            }
        }
    }
    
private:
    void test_single_put_call_parity(double spot, double strike, double expiry,
                                    double dom_rate, double for_rate, double volatility) {
        
        // Prix call et put
        auto call_result = fx_black_scholes_engine::calculate_option_metrics(
            spot, strike, expiry, dom_rate, for_rate, volatility, true);
        
        auto put_result = fx_black_scholes_engine::calculate_option_metrics(
            spot, strike, expiry, dom_rate, for_rate, volatility, false);
        
        // Forward et facteur d'actualisation
        double forward = spot * std::exp((dom_rate - for_rate) * expiry);
        double discount_factor = std::exp(-dom_rate * expiry);
        
        // Put-call parity : C - P = DF * (F - K)
        double lhs = call_result.price - put_result.price;
        double rhs = discount_factor * (forward - strike);
        
        double absolute_error = std::abs(lhs - rhs);
        double relative_error = absolute_error / std::max(std::abs(rhs), 1e-10);
        
        // Validation avec tol√©rance tr√®s stricte
        EXPECT_LT(relative_error, 1e-12);
        
        // Log des cas probl√©matiques
        if (relative_error > 1e-12) {
            std::cout << "Put-Call Parity violation: "
                      << "Spot=" << spot << ", Strike=" << strike 
                      << ", Expiry=" << expiry << ", Error=" << relative_error << std::endl;
        }
    }
};
```

---

## üîÑ **Tests de Surfaces de Volatilit√©**

### **üîç Test 1 : Validation d'Interpolation**

#### **Tests d'Interpolation de Surface**
```cpp
// Tests de validation d'interpolation de surface dans Our project
class volatility_surface_interpolation_tester {
public:
    struct interpolation_test_results {
        std::vector<double> interpolation_errors;
        std::vector<double> extrapolation_errors;
        bool monotonicity_preserved;
        bool arbitrage_free;
    };
    
    interpolation_test_results test_surface_interpolation() {
        interpolation_test_results results;
        
        // Cr√©ation d'une surface de test
        auto test_surface = create_test_volatility_surface();
        
        // Tests d'interpolation aux points de grille
        test_grid_point_interpolation(test_surface, results);
        
        // Tests d'interpolation entre points
        test_between_grid_interpolation(test_surface, results);
        
        // Tests d'extrapolation
        test_extrapolation_behavior(test_surface, results);
        
        // Tests de propri√©t√©s √©conomiques
        results.monotonicity_preserved = test_monotonicity(test_surface);
        results.arbitrage_free = test_arbitrage_freedom(test_surface);
        
        return results;
    }
    
private:
    std::shared_ptr<fx_volatility_surface> create_test_volatility_surface() {
        // Grille de test
        std::vector<double> strikes = {0.8, 0.9, 1.0, 1.1, 1.2};
        std::vector<double> expiries = {0.25, 0.5, 1.0, 2.0, 5.0};
        
        // Volatilit√©s avec smile/skew r√©aliste
        matrix<double> volatilities(strikes.size(), expiries.size());
        
        for (size_t i = 0; i < strikes.size(); ++i) {
            for (size_t j = 0; j < expiries.size(); ++j) {
                double strike = strikes[i];
                double expiry = expiries[j];
                
                // Mod√®le de volatilit√© r√©aliste avec smile
                double atm_vol = 0.2 * std::sqrt(expiry / 1.0); // Term structure
                double smile_effect = 0.05 * std::pow(strike - 1.0, 2); // Smile
                double skew_effect = -0.02 * (strike - 1.0); // Skew
                
                volatilities(i, j) = atm_vol + smile_effect + skew_effect;
            }
        }
        
        volatility_grid grid{strikes, expiries, volatilities, 
                           interpolation_enum::BILINEAR,
                           extrapolation_enum::FLAT};
        
        return std::make_shared<fx_volatility_surface_interpolated>(grid);
    }
    
    void test_grid_point_interpolation(
        std::shared_ptr<fx_volatility_surface> surface,
        interpolation_test_results& results) {
        
        // Test que l'interpolation aux points de grille donne les valeurs exactes
        auto grid = surface->get_grid();
        
        for (size_t i = 0; i < grid.strikes.size(); ++i) {
            for (size_t j = 0; j < grid.expiries.size(); ++j) {
                double interpolated_vol = surface->get_volatility(
                    grid.strikes[i], grid.expiries[j]);
                double grid_vol = grid.volatilities(i, j);
                
                double error = std::abs(interpolated_vol - grid_vol);
                results.interpolation_errors.push_back(error);
                
                EXPECT_LT(error, 1e-15); // Pr√©cision machine
            }
        }
    }
    
    bool test_arbitrage_freedom(std::shared_ptr<fx_volatility_surface> surface) {
        // Test de l'absence d'arbitrage via conditions de Dupire
        
        std::vector<double> test_strikes = {0.85, 0.95, 1.05, 1.15};
        std::vector<double> test_expiries = {0.5, 1.0, 1.5};
        
        for (double expiry : test_expiries) {
            for (size_t i = 1; i < test_strikes.size() - 1; ++i) {
                double k_minus = test_strikes[i-1];
                double k = test_strikes[i];
                double k_plus = test_strikes[i+1];
                
                double vol_minus = surface->get_volatility(k_minus, expiry);
                double vol_center = surface->get_volatility(k, expiry);
                double vol_plus = surface->get_volatility(k_plus, expiry);
                
                // Test de convexit√© (condition n√©cessaire pour absence d'arbitrage)
                double second_derivative = (vol_plus - 2.0 * vol_center + vol_minus) /
                                         std::pow(k_plus - k_minus, 2);
                
                // La convexit√© doit √™tre raisonnable (pas trop n√©gative)
                if (second_derivative < -1.0) {
                    return false;
                }
            }
        }
        
        return true;
    }
};
```

### **üîç Test 2 : Validation de Mod√®les Param√©triques**

#### **Tests SA4 et LABGD**
```cpp
// Tests de validation pour mod√®les param√©triques dans Our project
class parametric_model_validation_tester {
public:
    void test_sa4_model_properties() {
        // Param√®tres SA4 de test
        sa4_volatility_model::sa4_params params{
            .vol = 0.2,
            .smile = 0.1,
            .skew = -0.05,
            .power = 1.0,
            .vol_atm = 0.2
        };
        
        sa4_volatility_model model(params);
        
        // Tests de propri√©t√©s
        test_sa4_atm_consistency(model);
        test_sa4_smile_behavior(model);
        test_sa4_skew_behavior(model);
        test_sa4_parameter_sensitivity(model);
    }
    
private:
    void test_sa4_atm_consistency(const sa4_volatility_model& model) {
        // Test que la volatilit√© ATM correspond au param√®tre vol_atm
        double forward = 1.0;
        double strike = 1.0; // ATM
        double expiry = 1.0;
        
        double atm_vol = model.calculate_volatility(forward, strike, expiry);
        
        // La volatilit√© ATM doit √™tre proche du param√®tre vol_atm
        EXPECT_NEAR(atm_vol, 0.2, 1e-6);
    }
    
    void test_sa4_smile_behavior(const sa4_volatility_model& model) {
        // Test du comportement de smile (convexit√©)
        double forward = 1.0;
        double expiry = 1.0;
        
        std::vector<double> strikes = {0.9, 1.0, 1.1};
        std::vector<double> volatilities;
        
        for (double strike : strikes) {
            double vol = model.calculate_volatility(forward, strike, expiry);
            volatilities.push_back(vol);
        }
        
        // Avec smile positif, la volatilit√© doit √™tre plus √©lev√©e OTM
        EXPECT_GT(volatilities[0], volatilities[1]); // Put OTM > ATM
        EXPECT_GT(volatilities[2], volatilities[1]); // Call OTM > ATM
    }
    
    void test_sa4_parameter_sensitivity(const sa4_volatility_model& model) {
        // Test de sensibilit√© aux param√®tres
        double forward = 1.0;
        double strike = 1.1; // OTM call
        double expiry = 1.0;
        
        double base_vol = model.calculate_volatility(forward, strike, expiry);
        
        // Test sensibilit√© au param√®tre smile
        auto params_smile_up = model.get_parameters();
        params_smile_up.smile += 0.01;
        sa4_volatility_model model_smile_up(params_smile_up);
        double vol_smile_up = model_smile_up.calculate_volatility(forward, strike, expiry);
        
        // Augmentation du smile doit augmenter la volatilit√© OTM
        EXPECT_GT(vol_smile_up, base_vol);
        
        // Test sensibilit√© au param√®tre skew
        auto params_skew_up = model.get_parameters();
        params_skew_up.skew += 0.01;
        sa4_volatility_model model_skew_up(params_skew_up);
        double vol_skew_up = model_skew_up.calculate_volatility(forward, strike, expiry);
        
        // Augmentation du skew doit augmenter la volatilit√© des calls OTM
        EXPECT_GT(vol_skew_up, base_vol);
    }
};
```

---

## üèõÔ∏è **Tests sous Frameworks R√©glementaires**

### **üîç CCAR Testing avec FX**

#### **Tests de Stress FX sous CCAR**
```cpp
// Tests CCAR pour mod√®les FX dans Our project
class ccar_fx_testing_framework {
public:
    struct ccar_fx_scenario {
        std::string scenario_name;
        std::vector<market_data_snapshot> quarterly_snapshots;
        std::map<std::string, double> fx_stress_factors;
        std::string description;
    };
    
    void run_ccar_fx_tests(const fx_derivative_base& derivative) {
        // Sc√©narios CCAR avec stress FX
        std::vector<ccar_fx_scenario> scenarios = {
            create_baseline_fx_scenario(),
            create_severely_adverse_fx_scenario(),
            create_adverse_fx_scenario()
        };
        
        for (const auto& scenario : scenarios) {
            test_derivative_under_ccar_fx_scenario(derivative, scenario);
        }
    }
    
private:
    void test_derivative_under_ccar_fx_scenario(
        const fx_derivative_base& derivative,
        const ccar_fx_scenario& scenario) {
        
        std::cout << "Testing FX derivative under: " << scenario.scenario_name << std::endl;
        
        for (int quarter = 1; quarter <= 9; ++quarter) {
            const auto& market_data = scenario.quarterly_snapshots[quarter-1];
            
            // Application du stress FX
            auto stressed_market = apply_fx_stress(market_data, scenario.fx_stress_factors);
            
            // Calcul des m√©triques sous stress
            double pv = derivative.calculate_pv(stressed_market);
            auto sensitivities = derivative.calculate_sensitivities(stressed_market);
            
            // Validation de stabilit√©
            EXPECT_TRUE(std::isfinite(pv));
            EXPECT_TRUE(validate_fx_sensitivities_finite(sensitivities));
            
            // Tests de coh√©rence FX
            validate_fx_stress_coherence(derivative, market_data, stressed_market);
            
            // Documentation des r√©sultats
            document_ccar_fx_results(scenario.scenario_name, quarter, pv, sensitivities);
        }
    }
    
    ccar_fx_scenario create_severely_adverse_fx_scenario() {
        ccar_fx_scenario scenario;
        scenario.scenario_name = "CCAR 2023 Severely Adverse with FX Stress";
        scenario.description = "Severe USD strengthening and volatility spike";
        
        // Facteurs de stress FX
        scenario.fx_stress_factors = {
            {"EURUSD", -0.20},  // EUR faiblesse de 20%
            {"GBPUSD", -0.15},  // GBP faiblesse de 15%
            {"USDJPY", +0.25},  // JPY faiblesse de 25%
            {"USDCAD", +0.10},  // CAD faiblesse de 10%
            {"AUDUSD", -0.30}   // AUD faiblesse de 30%
        };
        
        // Chargement des donn√©es de march√© CCAR
        scenario.quarterly_snapshots = load_ccar_severely_adverse_fx_data();
        
        return scenario;
    }
};
```

### **üîç IRRBB Testing avec Expositions FX**

#### **Tests IRRBB Multi-Devises**
```cpp
// Tests IRRBB pour expositions FX dans Our project
class irrbb_fx_testing_framework {
public:
    void run_irrbb_fx_tests(const fx_derivative_base& derivative,
                           const market_data& base_market) {
        
        // Sc√©narios IRRBB adapt√©s pour FX
        std::vector<irrbb_fx_scenario> scenarios = {
            create_parallel_shift_fx_scenario(200),    // +200bp toutes devises
            create_parallel_shift_fx_scenario(-200),   // -200bp toutes devises
            create_usd_steepener_scenario(),
            create_usd_flattener_scenario(),
            create_fx_volatility_stress_scenario()
        };
        
        double base_eve = calculate_economic_value_equity(derivative, base_market);
        
        for (const auto& scenario : scenarios) {
            auto stressed_market = apply_irrbb_fx_scenario(base_market, scenario);
            
            double stressed_eve = calculate_economic_value_equity(derivative, stressed_market);
            
            double delta_eve = stressed_eve - base_eve;
            double eve_ratio = std::abs(delta_eve) / base_eve;
            
            // Validation contre limites r√©glementaires
            validate_irrbb_fx_limits(scenario.name, eve_ratio);
            
            // Tests de stabilit√© FX sous stress IR
            test_fx_stability_under_ir_stress(derivative, stressed_market, scenario);
        }
    }
    
private:
    struct irrbb_fx_scenario {
        std::string name;
        std::map<std::string, double> ir_shocks; // Par devise
        std::map<std::string, double> fx_vol_shocks;
        std::map<std::string, double> fx_spot_shocks;
    };
    
    void test_fx_stability_under_ir_stress(
        const fx_derivative_base& derivative,
        const market_data& stressed_market,
        const irrbb_fx_scenario& scenario) {
        
        // V√©rification que les sensibilit√©s FX restent stables sous stress IR
        auto sensitivities = derivative.calculate_sensitivities(stressed_market);
        
        // Validation des bornes
        EXPECT_TRUE(std::isfinite(sensitivities.fx_delta));
        EXPECT_TRUE(std::isfinite(sensitivities.fx_gamma));
        EXPECT_TRUE(std::isfinite(sensitivities.vega));
        
        // Validation que les sensibilit√©s IR sont coh√©rentes
        EXPECT_TRUE(std::isfinite(sensitivities.domestic_ir_delta));
        EXPECT_TRUE(std::isfinite(sensitivities.foreign_ir_delta));
        
        // Tests de coh√©rence cross-currency
        validate_cross_currency_coherence(sensitivities, scenario);
    }
};
```

---

## üìä **Tests de Validation Crois√©e**

### **üîç Validation contre Mod√®les Alternatifs**

#### **Comparaison avec Impl√©mentations Externes**
```cpp
// Validation crois√©e avec impl√©mentations externes dans Our project
class cross_validation_fx_tester {
public:
    struct cross_validation_results {
        std::map<std::string, double> model_prices;
        std::map<std::string, fx_sensitivities> model_sensitivities;
        std::map<std::string, double> pricing_differences;
        std::string validation_status;
    };
    
    cross_validation_results compare_fx_implementations(
        const fx_derivative_base& derivative,
        const fx_market_data& market) {
        
        cross_validation_results results;
        
        // Impl√©mentations √† comparer
        std::vector<std::string> implementations = {
            "DBSMC_OUR_PROJECT",
            "QUANTLIB_REFERENCE",
            "BLOOMBERG_API",
            "MANUAL_CALCULATION"
        };
        
        for (const auto& impl_name : implementations) {
            // Pricing avec l'impl√©mentation
            double price = price_with_implementation(derivative, market, impl_name);
            results.model_prices[impl_name] = price;
            
            // Calcul des sensibilit√©s
            auto sensitivities = calculate_sensitivities_with_implementation(
                derivative, market, impl_name);
            results.model_sensitivities[impl_name] = sensitivities;
        }
        
        // Analyse des diff√©rences
        analyze_implementation_differences(results);
        
        // Validation globale
        results.validation_status = determine_validation_status(results);
        
        return results;
    }
    
private:
    void analyze_implementation_differences(cross_validation_results& results) {
        double reference_price = results.model_prices["DBSMC_OUR_PROJECT"];
        
        for (const auto& [impl_name, price] : results.model_prices) {
            if (impl_name != "DBSMC_OUR_PROJECT") {
                double relative_diff = std::abs(price - reference_price) / 
                                     std::abs(reference_price);
                results.pricing_differences[impl_name] = relative_diff;
                
                // Validation des tol√©rances
                if (impl_name == "QUANTLIB_REFERENCE") {
                    EXPECT_LT(relative_diff, 1e-10); // Tr√®s stricte pour QuantLib
                } else if (impl_name == "MANUAL_CALCULATION") {
                    EXPECT_LT(relative_diff, 1e-12); // Exactitude machine
                }
            }
        }
    }
};
```

---

*Cette section fournit une documentation compl√®te des tests de validation ind√©pendants pour le mod√®le DBSMC-RateDeterministic_FXMarket, int√©grant les impl√©mentations C++ de Our project avec des m√©thodologies de test rigoureuses pour les d√©riv√©s FX analytiques.*
