# Introduction to Model and Validation

## üéØ **Validation Scope**

### **Objectif de la Validation**
Cette section d√©finit le scope complet de la validation pour le mod√®le **DBSMC-RateDeterministic_FXMarket**, incluant les produits couverts, les m√©thodologies de validation sp√©cialis√©es pour les d√©riv√©s FX, et les frameworks de test analytiques.

### **Mod√®le dans le Scope**
- **DBSMC-RateDeterministic_FXMarket[AUTO]**
- **DBSMC-RateDeterministic_FXMarket**

### **Version du Mod√®le**
Le mod√®le a √©t√© revu pour **DBAnalytics** avec validation compl√®te des fonctionnalit√©s FX et performances analytiques.

---

## üìä **Product Description**

### **Caract√©ristiques G√©n√©rales des Produits**

#### **Propri√©t√©s Fondamentales**
Les produits couverts par ce framework partagent les caract√©ristiques suivantes :
- **D√©pendance** aux taux de change FX
- **Pricing analytique** via formules Black-Scholes
- **Taux d√©terministes** pour devises domestiques et √©trang√®res
- **Surfaces de volatilit√©** interpol√©es ou param√©triques

#### **Structure Math√©matique**
Les produits peuvent √™tre repr√©sent√©s sous la forme g√©n√©rale :

$$\text{PV} = e^{-r_d T} \mathbb{E}^{\mathbb{Q}}[\text{Payoff}(S_T)]$$

o√π $S_T$ suit un processus lognormal sous la mesure risque-neutre $\mathbb{Q}$.

### **Produits Sp√©cifiques**

#### **üîÑ FXEuroOpt - Options Europ√©ennes FX**
**Description :** Options vanilles europ√©ennes sur taux de change.

**Formule de Payoff :**
$$\text{Payoff} = N \times \max(\omega(S_T - K), 0)$$

o√π :
- $N$ = Notionnel
- $S_T$ = Taux de change √† l'expiry
- $K$ = Strike
- $\omega$ = +1 pour call, -1 pour put

#### **üí∞ FXDigitalOpt - Options Digitales FX**
**Description :** Options digitales avec payout binaire.

**Formule de Payoff :**
$$\text{Payoff} = N \times \mathbf{1}_{\{S_T > K\}}$$

o√π $\mathbf{1}_{\{\cdot\}}$ est la fonction indicatrice.

#### **üìä FXGeometricBasketOpt - Options sur Panier G√©om√©trique**
**Description :** Options sur moyenne g√©om√©trique de taux de change.

**Formule de Payoff :**
$$\text{Payoff} = N \times \max\left(\prod_{i=1}^n S_i^{w_i} - K, 0\right)$$

o√π $w_i$ sont les poids du panier et $\sum w_i = 1$.

---

## üèóÔ∏è **Model Description**

### **Framework Th√©orique**

#### **Mod√®le DBSMC-RateDeterministic_FXMarket**
Le mod√®le DBSMC est une impl√©mentation analytique ferm√©e pour pricing de d√©riv√©s FX avec taux d√©terministes.

**Composants Principaux :**
- **Taux d√©terministes** $r_d(t)$ et $r_f(t)$
- **Processus lognormal** pour FX : $dS_t = (r_d - r_f)S_t dt + \sigma(S_t, t) S_t dW_t$
- **Surfaces de volatilit√©** $\sigma(K, T)$

#### **Impl√©mentation Black-Scholes FX**
```cpp
// Impl√©mentation compl√®te du mod√®le DBSMC dans Our project
class dbsmc_fx_model : public fx_model_base {
private:
    struct model_parameters {
        std::function<double(double)> domestic_rate_curve;
        std::function<double(double)> foreign_rate_curve;
        std::shared_ptr<fx_volatility_surface> vol_surface;
        double fx_spot;
        std::string currency_pair;
    };
    
    model_parameters params_;
    
public:
    dbsmc_fx_model(const model_parameters& params) : params_(params) {
        validate_model_parameters();
    }
    
    double price_european_option(double strike, double expiry, 
                                bool is_call, double notional) const override {
        
        // Calcul du forward FX
        double dom_rate = params_.domestic_rate_curve(expiry);
        double for_rate = params_.foreign_rate_curve(expiry);
        double forward = params_.fx_spot * std::exp((dom_rate - for_rate) * expiry);
        
        // Volatilit√© Black-Scholes
        double volatility = params_.vol_surface->get_volatility(strike, expiry);
        
        // Facteur d'actualisation
        double discount_factor = std::exp(-dom_rate * expiry);
        
        // Prix Black-Scholes
        return black_scholes::price(forward, strike, expiry, volatility,
                                  discount_factor * notional, is_call ? 1.0 : -1.0);
    }
    
    double price_digital_option(double barrier, double expiry,
                               bool is_call, double payout) const {
        
        double dom_rate = params_.domestic_rate_curve(expiry);
        double for_rate = params_.foreign_rate_curve(expiry);
        double forward = params_.fx_spot * std::exp((dom_rate - for_rate) * expiry);
        
        double volatility = params_.vol_surface->get_volatility(barrier, expiry);
        
        // Probabilit√© de finir dans la monnaie
        double probability = black_scholes::probability(forward, barrier, expiry, volatility, 0.0);
        
        if (!is_call) {
            probability = 1.0 - probability;
        }
        
        double discount_factor = std::exp(-dom_rate * expiry);
        return payout * probability * discount_factor;
    }
    
    fx_sensitivities calculate_sensitivities(double strike, double expiry,
                                           bool is_call, double notional) const {
        
        fx_sensitivities sens;
        
        // Delta FX par diff√©rences finies
        const double fx_shock = 1e-4;
        double pv_base = price_european_option(strike, expiry, is_call, notional);
        
        auto params_up = params_;
        params_up.fx_spot += fx_shock;
        dbsmc_fx_model model_up(params_up);
        double pv_up = model_up.price_european_option(strike, expiry, is_call, notional);
        
        auto params_down = params_;
        params_down.fx_spot -= fx_shock;
        dbsmc_fx_model model_down(params_down);
        double pv_down = model_down.price_european_option(strike, expiry, is_call, notional);
        
        sens.fx_delta = (pv_up - pv_down) / (2.0 * fx_shock);
        
        // Gamma FX
        sens.fx_gamma = (pv_up - 2.0 * pv_base + pv_down) / (fx_shock * fx_shock);
        
        // Vega par choc de volatilit√©
        const double vol_shock = 0.01; // 1%
        auto vol_surface_up = shock_volatility_surface(params_.vol_surface, vol_shock);
        auto params_vol_up = params_;
        params_vol_up.vol_surface = vol_surface_up;
        dbsmc_fx_model model_vol_up(params_vol_up);
        double pv_vol_up = model_vol_up.price_european_option(strike, expiry, is_call, notional);
        
        sens.vega = (pv_vol_up - pv_base) / vol_shock;
        
        return sens;
    }
    
private:
    void validate_model_parameters() const {
        XSIGMA_CHECK(params_.fx_spot > 0, "FX spot must be positive");
        XSIGMA_CHECK(params_.vol_surface != nullptr, "Volatility surface required");
        XSIGMA_CHECK(!params_.currency_pair.empty(), "Currency pair required");
    }
};
```
*Cette impl√©mentation C++ dans Our project montre le mod√®le DBSMC complet avec pricing analytique et calcul de sensibilit√©s.*

### **Surfaces de Volatilit√©**

#### **Types de Surfaces Support√©es**

##### **üîß Non-Param√©trique (Interpolation/Extrapolation)**
```cpp
// Surface de volatilit√© non-param√©trique dans Our project
class fx_volatility_surface_interpolated : public fx_volatility_surface {
private:
    struct volatility_grid {
        std::vector<double> strikes;
        std::vector<double> expiries;
        matrix<double> volatilities;
        interpolation_enum interpolation_method;
        extrapolation_enum extrapolation_method;
    };
    
    volatility_grid grid_;
    
public:
    fx_volatility_surface_interpolated(const volatility_grid& grid) : grid_(grid) {
        validate_grid();
    }
    
    double get_volatility(double strike, double expiry) const override {
        // Recherche des indices d'interpolation
        auto [strike_idx, expiry_idx] = find_interpolation_indices(strike, expiry);
        
        // Interpolation bilin√©aire
        return bilinear_interpolation(strike, expiry, strike_idx, expiry_idx);
    }
    
private:
    double bilinear_interpolation(double strike, double expiry,
                                 size_t strike_idx, size_t expiry_idx) const {
        
        // Gestion des cas limites (extrapolation)
        if (strike_idx == 0 || expiry_idx == 0 ||
            strike_idx >= grid_.strikes.size() || expiry_idx >= grid_.expiries.size()) {
            return handle_extrapolation(strike, expiry);
        }
        
        // Points d'interpolation
        double k1 = grid_.strikes[strike_idx-1];
        double k2 = grid_.strikes[strike_idx];
        double t1 = grid_.expiries[expiry_idx-1];
        double t2 = grid_.expiries[expiry_idx];
        
        // Volatilit√©s aux quatre coins
        double vol_11 = grid_.volatilities(strike_idx-1, expiry_idx-1);
        double vol_12 = grid_.volatilities(strike_idx-1, expiry_idx);
        double vol_21 = grid_.volatilities(strike_idx, expiry_idx-1);
        double vol_22 = grid_.volatilities(strike_idx, expiry_idx);
        
        // Poids d'interpolation
        double w_k = (strike - k1) / (k2 - k1);
        double w_t = (expiry - t1) / (t2 - t1);
        
        // Interpolation bilin√©aire
        return (1.0 - w_k) * (1.0 - w_t) * vol_11 +
               (1.0 - w_k) * w_t * vol_12 +
               w_k * (1.0 - w_t) * vol_21 +
               w_k * w_t * vol_22;
    }
};
```

##### **üîß Param√©trique SA4**
```cpp
// Surface de volatilit√© SA4 dans Our project
class fx_volatility_surface_sa4 : public fx_volatility_surface {
private:
    struct sa4_parameters {
        double vol;
        double smile;
        double skew;
        double power;
        double vol_atm;
    };
    
    sa4_parameters params_;
    double fx_forward_;
    
public:
    fx_volatility_surface_sa4(const sa4_parameters& params, double fx_forward)
        : params_(params), fx_forward_(fx_forward) {
        validate_sa4_parameters();
    }
    
    double get_volatility(double strike, double expiry) const override {
        // Calcul du forward pour cette expiry
        double forward = fx_forward_; // Simplifi√© pour l'exemple
        
        // Mod√®le SA4
        sigma_volatility_sa4<double> sa4_model(
            params_.vol, params_.smile, params_.skew, 
            params_.power, params_.vol_atm);
        
        return sa4_model.implied_volatility(forward, strike, expiry,
                                          implied_volatility_enum::BLACK_SCHOLES);
    }
    
private:
    void validate_sa4_parameters() const {
        XSIGMA_CHECK(params_.vol > 0, "SA4 vol must be positive");
        XSIGMA_CHECK(params_.power > 0, "SA4 power must be positive");
        XSIGMA_CHECK(params_.vol_atm > 0, "SA4 vol_atm must be positive");
    }
};
```

##### **üîß Param√©trique LABGD**
```cpp
// Surface de volatilit√© LABGD dans Our project
class fx_volatility_surface_labgd : public fx_volatility_surface {
private:
    struct labgd_parameters {
        double vol;
        double smile;
        double skew;
        double power;
        double ac;
        double ap;
        double vol_atm;
    };
    
    labgd_parameters params_;
    
public:
    double get_volatility(double strike, double expiry) const override {
        double forward = fx_forward_; // Simplifi√©
        
        // Mod√®le LABGD
        sigma_volatility_la6gd<double> labgd_model(
            params_.vol, params_.smile, params_.skew, params_.power,
            params_.ac, params_.ap, params_.vol_atm);
        
        return labgd_model.implied_volatility(forward, strike, expiry,
                                            implied_volatility_enum::BLACK_SCHOLES);
    }
};
```

---

## üìà **Model Configurations**

### **Configuration Standard**

#### **DBSMC-RateDeterministic_FXMarket**
```cpp
// Configuration standard dans Our project
struct dbsmc_standard_config {
    // Param√®tres de courbe
    struct curve_params {
        std::string curve_type = "DETERMINISTIC";
        std::string interpolation = "LINEAR";
        std::string extrapolation = "FLAT";
    } rates_config;
    
    // Param√®tres de volatilit√©
    struct volatility_params {
        std::string surface_type = "INTERPOLATED"; // ou "SA4", "LABGD"
        std::string interpolation_method = "BILINEAR";
        std::string extrapolation_method = "FLAT";
    } vol_config;
    
    // Param√®tres FX
    struct fx_params {
        std::string spot_source = "MARKET";
        std::string forward_calculation = "INTEREST_RATE_PARITY";
    } fx_config;
};
```

### **Configuration AUTO**

#### **DBSMC-RateDeterministic_FXMarket[AUTO]**
```cpp
// Configuration automatique dans Our project
struct dbsmc_auto_config {
    // S√©lection automatique des param√®tres
    bool auto_volatility_surface_selection = true;
    bool auto_interpolation_method = true;
    bool auto_extrapolation_method = true;
    
    // Crit√®res de s√©lection automatique
    struct auto_selection_criteria {
        double calibration_tolerance = 1e-6;
        std::string preferred_surface_type = "SA4";
        std::string fallback_surface_type = "INTERPOLATED";
    } selection_criteria;
    
    // Validation automatique
    bool enable_auto_validation = true;
    double max_calibration_error = 1e-4;
};
```

---

## üß™ **Validation Outline**

### **M√©thodologie de Validation Sp√©cialis√©e**

#### **üîç Phase 1 : Validation Analytique**
- V√©rification des formules Black-Scholes
- Tests de coh√©rence put-call parity
- Validation des surfaces de volatilit√©

#### **üîç Phase 2 : Tests de Sensibilit√©s**
- Validation des Greeks (Delta, Gamma, Vega)
- Tests de coh√©rence Taylor
- Validation des sensibilit√©s IR

#### **üîç Phase 3 : Tests de Produits**
- Pricing d'options europ√©ennes
- Options digitales et exotiques
- Paniers g√©om√©triques FX

#### **üîç Phase 4 : Validation R√©glementaire**
- Tests CCAR avec stress FX
- IRRBB avec expositions FX
- HistSim multivari√©e

### **Crit√®res d'Acceptation Sp√©cialis√©s**
- **Pr√©cision analytique** : Erreur < 1e-10 vs formules ferm√©es
- **Stabilit√© des sensibilit√©s** : Coh√©rence sous stress
- **Performance** : Temps de calcul < 1ms par trade
- **Calibration** : Erreur de surface < 1bp

---

*Cette section fournit une introduction compl√®te au mod√®le DBSMC-RateDeterministic_FXMarket et √† sa validation, int√©grant les impl√©mentations C++ de Our project avec les m√©thodologies de validation sp√©cialis√©es pour les d√©riv√©s FX.*
