# Model Monitoring & KPIs

## üìä **Monitoring Overview**

### **Monitoring Objectives**
FX volatility surfaces monitoring aims to ensure continuous performance, stability and regulatory compliance of models in production. A robust KPI system enables early detection of degradations and continuous optimization.

### **Monitoring Domains**
- **Calibration Performance**: Quality of fitting to market data
- **Temporal Stability**: Consistency over time
- **Absence of Arbitrage**: Continuous validation of constraints
- **Operational Performance**: Calculation time and resources

---

## üîß **Calibration Performance KPIs**

### **Fit Quality Metrics**

#### **üîç Root Mean Square Error (RMSE)**
Measures the overall quality of fitting to market quotes.

$$RMSE = \sqrt{\frac{1}{N}\sum_{i=1}^{N}(vol_{market,i} - vol_{model,i})^2} \tag{11.1}$$

### **Implementation in Our Project**

#### **üîß KPI Monitoring Framework**
```cpp
// KPI monitoring framework for FX surfaces in Our project
class fx_surface_monitoring_framework {
public:
    enum class kpi_category {
        CALIBRATION_QUALITY,    // Calibration quality
        TEMPORAL_STABILITY,     // Temporal stability
        ARBITRAGE_COMPLIANCE,   // Arbitrage compliance
        OPERATIONAL_PERFORMANCE // Operational performance
    };
    
    enum class kpi_frequency {
        REAL_TIME,    // Real time
        INTRADAY,     // Multiple times per day
        DAILY,        // Daily
        WEEKLY,       // Weekly
        MONTHLY       // Monthly
    };
    
    struct kpi_specification {
        std::string kpi_name;
        kpi_category category;
        kpi_frequency frequency;
        double warning_threshold;
        double critical_threshold;
        std::string description;
        std::string calculation_method;
        bool enabled;
    };
    
    struct kpi_measurement {
        std::string kpi_name;
        double value;
        std::string timestamp;
        std::string status; // "OK", "WARNING", "CRITICAL"
        std::map<std::string, double> breakdown_metrics;
        std::string comments;
    };
    
    class calibration_quality_monitor {
    public:
        std::vector<kpi_measurement> calculate_calibration_kpis(
            const fx_volatility_surface_base& surface,
            const market_data& market_data) {
            
            std::vector<kpi_measurement> measurements;
            
            // KPI 1: Calibration RMSE
            measurements.push_back(calculate_calibration_rmse(surface, market_data));

            // KPI 2: Maximum error
            measurements.push_back(calculate_max_calibration_error(surface, market_data));

            // KPI 3: Percentage of quotes within tolerance
            measurements.push_back(calculate_quotes_within_tolerance(surface, market_data));

            // KPI 4: Calibration R-squared
            measurements.push_back(calculate_calibration_r_squared(surface, market_data));

            // KPI 5: Error by instrument category
            measurements.push_back(calculate_error_by_instrument_type(surface, market_data));
            
            return measurements;
        }
        
    private:
        kpi_measurement calculate_calibration_rmse(
            const fx_volatility_surface_base& surface,
            const market_data& market_data) {
            
            kpi_measurement measurement;
            measurement.kpi_name = "CALIBRATION_RMSE";
            measurement.timestamp = get_current_timestamp();
            
            std::vector<double> squared_errors;
            
            // Calculate errors for each quote
            for (const auto& quote : market_data.get_all_quotes()) {
                double market_vol = quote.quote_value;
                double model_vol = surface.get_volatility_for_quote(quote);

                double error = market_vol - model_vol;
                squared_errors.push_back(error * error);

                // Breakdown by instrument type
                std::string instrument_type = extract_instrument_type(quote.instrument_id);
                measurement.breakdown_metrics[instrument_type + "_ERROR"] = std::abs(error);
            }

            // Calculate RMSE
            double sum_squared = std::accumulate(squared_errors.begin(), squared_errors.end(), 0.0);
            measurement.value = std::sqrt(sum_squared / squared_errors.size());

            // Status evaluation
            if (measurement.value > 0.02) { // 2% RMSE
                measurement.status = "CRITICAL";
            } else if (measurement.value > 0.01) { // 1% RMSE
                measurement.status = "WARNING";
            } else {
                measurement.status = "OK";
            }
            
            return measurement;
        }
        
        kpi_measurement calculate_quotes_within_tolerance(
            const fx_volatility_surface_base& surface,
            const market_data& market_data) {
            
            kpi_measurement measurement;
            measurement.kpi_name = "QUOTES_WITHIN_TOLERANCE";
            measurement.timestamp = get_current_timestamp();
            
            const double TOLERANCE = 0.005; // 0.5% tolerance
            
            int total_quotes = 0;
            int quotes_within_tolerance = 0;
            
            for (const auto& quote : market_data.get_all_quotes()) {
                double market_vol = quote.quote_value;
                double model_vol = surface.get_volatility_for_quote(quote);
                
                double relative_error = std::abs(market_vol - model_vol) / market_vol;
                
                total_quotes++;
                if (relative_error <= TOLERANCE) {
                    quotes_within_tolerance++;
                }
            }
            
            // Percentage of quotes within tolerance
            measurement.value = static_cast<double>(quotes_within_tolerance) / total_quotes * 100.0;

            // Status evaluation
            if (measurement.value < 80.0) {
                measurement.status = "CRITICAL";
            } else if (measurement.value < 90.0) {
                measurement.status = "WARNING";
            } else {
                measurement.status = "OK";
            }
            
            measurement.breakdown_metrics["TOTAL_QUOTES"] = total_quotes;
            measurement.breakdown_metrics["QUOTES_IN_TOLERANCE"] = quotes_within_tolerance;
            
            return measurement;
        }
    };
    
    class temporal_stability_monitor {
    public:
        std::vector<kpi_measurement> calculate_stability_kpis(
            const std::vector<fx_volatility_surface_base>& historical_surfaces) {
            
            std::vector<kpi_measurement> measurements;
            
            // KPI 1: ATM parameter stability
            measurements.push_back(calculate_atm_parameter_stability(historical_surfaces));

            // KPI 2: Smile parameter stability
            measurements.push_back(calculate_smile_parameter_stability(historical_surfaces));

            // KPI 3: Day-to-day correlation
            measurements.push_back(calculate_day_to_day_correlation(historical_surfaces));

            // KPI 4: Parameter volatility
            measurements.push_back(calculate_parameter_volatility(historical_surfaces));
            
            return measurements;
        }
        
    private:
        kpi_measurement calculate_atm_parameter_stability(
            const std::vector<fx_volatility_surface_base>& surfaces) {
            
            kpi_measurement measurement;
            measurement.kpi_name = "ATM_PARAMETER_STABILITY";
            measurement.timestamp = get_current_timestamp();
            
            if (surfaces.size() < 2) {
                measurement.value = 1.0; // Perfectly stable by default
                measurement.status = "OK";
                return measurement;
            }

            // Calculate ATM volatility stability
            std::vector<double> tenor_grid = {0.25, 0.5, 1.0, 2.0, 5.0}; // 3M, 6M, 1Y, 2Y, 5Y
            std::vector<double> stability_scores;

            for (double tenor : tenor_grid) {
                std::vector<double> atm_vols;

                for (const auto& surface : surfaces) {
                    double atm_vol = surface.get_atm_volatility(tenor);
                    atm_vols.push_back(atm_vol);
                }

                // Calculate stability for this tenor
                double stability = calculate_time_series_stability(atm_vols);
                stability_scores.push_back(stability);

                measurement.breakdown_metrics["STABILITY_" + std::to_string(tenor) + "Y"] = stability;
            }

            // Global stability score
            measurement.value = std::accumulate(stability_scores.begin(),
                                              stability_scores.end(), 0.0) / stability_scores.size();

            // Status evaluation
            if (measurement.value < 0.7) {
                measurement.status = "CRITICAL";
            } else if (measurement.value < 0.85) {
                measurement.status = "WARNING";
            } else {
                measurement.status = "OK";
            }
            
            return measurement;
        }
        
        double calculate_time_series_stability(const std::vector<double>& values) {
            if (values.size() < 2) return 1.0;

            // Calculate stability based on relative variance
            double mean = std::accumulate(values.begin(), values.end(), 0.0) / values.size();

            double variance = 0.0;
            for (double value : values) {
                variance += (value - mean) * (value - mean);
            }
            variance /= values.size();

            double coefficient_of_variation = std::sqrt(variance) / mean;

            // Stability score (1 = perfectly stable, 0 = very unstable)
            return std::exp(-10.0 * coefficient_of_variation);
        }
    };
    
    class arbitrage_compliance_monitor {
    public:
        std::vector<kpi_measurement> calculate_arbitrage_kpis(
            const fx_volatility_surface_base& surface) {
            
            std::vector<kpi_measurement> measurements;
            
            // KPI 1: Calendar arbitrage violations
            measurements.push_back(check_calendar_arbitrage_violations(surface));

            // KPI 2: Smile arbitrage violations
            measurements.push_back(check_smile_arbitrage_violations(surface));

            // KPI 3: Variance monotonicity
            measurements.push_back(check_variance_monotonicity(surface));
            
            return measurements;
        }
        
    private:
        kpi_measurement check_calendar_arbitrage_violations(
            const fx_volatility_surface_base& surface) {
            
            kpi_measurement measurement;
            measurement.kpi_name = "CALENDAR_ARBITRAGE_VIOLATIONS";
            measurement.timestamp = get_current_timestamp();
            
            auto tenor_grid = surface.get_tenor_grid();
            int violations = 0;
            int total_checks = 0;
            
            for (size_t i = 0; i < tenor_grid.size() - 1; ++i) {
                double t1 = tenor_grid[i];
                double t2 = tenor_grid[i + 1];
                
                double vol1 = surface.get_atm_volatility(t1);
                double vol2 = surface.get_atm_volatility(t2);
                
                double var1 = vol1 * vol1 * t1;
                double var2 = vol2 * vol2 * t2;
                
                total_checks++;
                if (var2 < var1) {
                    violations++;
                }
            }
            
            measurement.value = violations;
            measurement.breakdown_metrics["TOTAL_CHECKS"] = total_checks;
            measurement.breakdown_metrics["VIOLATION_RATE"] = 
                static_cast<double>(violations) / total_checks * 100.0;
            
            // Status evaluation
            if (violations > 0) {
                measurement.status = "CRITICAL";
            } else {
                measurement.status = "OK";
            }
            
            return measurement;
        }
    };
    
    class operational_performance_monitor {
    public:
        std::vector<kpi_measurement> calculate_performance_kpis(
            const fx_volatility_surface_base& surface) {
            
            std::vector<kpi_measurement> measurements;
            
            // KPI 1: Calibration time
            measurements.push_back(measure_calibration_time(surface));

            // KPI 2: Query time
            measurements.push_back(measure_query_time(surface));

            // KPI 3: Memory usage
            measurements.push_back(measure_memory_usage(surface));

            // KPI 4: Calibration success rate
            measurements.push_back(measure_calibration_success_rate(surface));
            
            return measurements;
        }
        
    private:
        kpi_measurement measure_calibration_time(const fx_volatility_surface_base& surface) {
            kpi_measurement measurement;
            measurement.kpi_name = "CALIBRATION_TIME_MS";
            measurement.timestamp = get_current_timestamp();
            
            // Measure calibration time
            auto start = std::chrono::high_resolution_clock::now();

            // Recalibration simulation
            auto market_data = generate_test_market_data();
            auto calibrated_surface = calibrate_surface(market_data);

            auto end = std::chrono::high_resolution_clock::now();

            measurement.value = std::chrono::duration<double, std::milli>(end - start).count();

            // Status evaluation
            if (measurement.value > 5000.0) { // 5 seconds
                measurement.status = "CRITICAL";
            } else if (measurement.value > 2000.0) { // 2 seconds
                measurement.status = "WARNING";
            } else {
                measurement.status = "OK";
            }
            
            return measurement;
        }
    };
};
```
*This C++ implementation in Our project shows the complete monitoring framework with calibration, stability, arbitrage and performance KPIs.*

---

## üìà **Temporal Stability KPIs**

### **Consistency Metrics**
- **Parameter Drift**: Parameter drift over time
- **Day-to-Day Correlation**: Day-to-day surface correlation
- **Volatility of Parameters**: Volatility of calibrated parameters
- **Regime Detection**: Regime change detection

### **Alert Thresholds**
- **Warning**: Correlation < 0.95
- **Critical**: Correlation < 0.90
- **Parameter Volatility**: > 20% annualized

---

## üéØ **Arbitrage-Free KPIs**

### **Automated Controls**
- **Calendar Arbitrage**: Daily verification
- **Smile Arbitrage**: Real-time control
- **Butterfly Arbitrage**: Spread validation
- **Variance Monotonicity**: Total variance monotonicity

---

## üîß **Operational Performance KPIs**

### **Performance Metrics**
- **Calibration Time**: < 2 seconds (target)
- **Query Response Time**: < 10ms (target)
- **Memory Usage**: < 500MB per surface
- **Success Rate**: > 99.5% successful calibrations

### **Availability and Reliability**
- **Uptime**: > 99.9%
- **Error Rate**: < 0.1%
- **Recovery Time**: < 30 seconds
- **Data Quality Score**: > 95%

---

*This section details the complete monitoring and KPI system for FX volatility surfaces, integrating Our project best practices with robust metrics to ensure quality, stability and continuous performance of models in production.*
