# Control Assessment

## Ongoing Performance Monitoring

Le monitoring de performance du modèle s'appuie sur des indicateurs de performance définis par les Product Owners, les utilisateurs de modèles produits ou les fonctions de contrôle selon les besoins, pour confirmer que le modèle fonctionne comme prévu.

```cpp
// Implémentation Our project du système de contrôle et monitoring
namespace xsigma {
    // Classe principale pour l'évaluation des contrôles
    class ModelControlAssessment {
    public:
        // Énumération des types de contrôles
        enum class ControlType {
            PARAMETER_MONITORING,       // Monitoring des paramètres
            PERFORMANCE_MONITORING,     // Monitoring de performance
            RISK_MONITORING,           // Monitoring des risques
            VALIDATION_MONITORING      // Monitoring de validation
        };
        
        // Structure pour les règles de contrôle
        struct ControlRule {
            std::string rule_id;            // ID de la règle
            std::string rule_name;          // Nom de la règle
            ControlType control_type;       // Type de contrôle
            std::string business_area;      // Domaine d'activité
            std::string status;             // Statut (Released/Approved)
            std::string parameter_object;   // Objet paramètre (CURVE, VOL, etc.)
            std::string parameter_name;     // Nom du paramètre
            std::vector<std::string> allowed_values; // Valeurs autorisées
            std::string condition;          // Condition de validation
            std::string last_change_date;   // Dernière date de modification
        };
        
        // Structure pour les indicateurs de performance
        struct PerformanceIndicator {
            std::string indicator_name;     // Nom de l'indicateur
            double current_value;           // Valeur actuelle
            double threshold_warning;       // Seuil d'alerte
            double threshold_critical;      // Seuil critique
            std::string measurement_unit;   // Unité de mesure
            std::string description;        // Description
            bool is_within_limits;         // Dans les limites acceptables
        };
        
        // Système de monitoring complet
        class ModelMonitoringSystem {
        public:
            // Monitoring des paramètres du modèle
            std::vector<ControlRule> get_parameter_control_rules() const {
                return {
                    // Règles pour l'objet CURVE
                    {
                        "11920", "InflationInterpolation", ControlType::PARAMETER_MONITORING,
                        "INFLATION", "Released/Approved", "CURVE", "InflationInterpolation",
                        {"FLAT", "DIR", "LINEAR", "PWCONST_L", "DIR_10", "LINEAR_10", "FLAT_15", "PWCONST_L_15"},
                        "CURVE::InflationInterpolation in (FLAT, DIR, LINEAR, PWCONST_L, DIR_10, LINEAR_10, FLAT_15, PWCONST_L_15)",
                        "2024-03-12"
                    },
                    {
                        "11960", "AddPar", ControlType::PARAMETER_MONITORING,
                        "RATES", "Released/Approved", "CURVE", "AddPar",
                        {"NONE", "LINEAR"},
                        "CURVE::AddPar in (NONE, LINEAR)",
                        "2024-03-12"
                    },
                    {
                        "11961", "BuildMethod", ControlType::PARAMETER_MONITORING,
                        "RATES", "Released/Approved", "CURVE", "BuildMethod",
                        {"CONSTANT_FORWARD", "HYBRID_CONSTANT_FORWARD", "HYBRID_FORWARD", "LINEAR_ZERO", "QUADRATIC_FORWARD"},
                        "CURVE::BuildMethod in (CONSTANT_FORWARD, HYBRID_CONSTANT_FORWARD, HYBRID_FORWARD, LINEAR_ZERO, QUADRATIC_FORWARD)",
                        "2024-03-12"
                    },
                    {
                        "11962", "CashToFuture", ControlType::PARAMETER_MONITORING,
                        "RATES", "Released/Approved", "CURVE", "CashToFuture",
                        {"EXACT", "EXACTCASH", "EXACTCASH-1", "CASHPRIORITY", "LINEAR", "NONE"},
                        "CURVE::CashToFuture in (EXACT, EXACTCASH, EXACTCASH-1, CASHPRIORITY, LINEAR, NONE)",
                        "2024-03-12"
                    },
                    {
                        "11963", "ExtrapMethod", ControlType::PARAMETER_MONITORING,
                        "RATES", "Released/Approved", "CURVE", "ExtrapMethod",
                        {"CONSTANT_FORWARD", "CONSTANT_PAR", "CONSTANT_ZERO", "NATIVE"},
                        "CURVE::ExtrapMethod in (CONSTANT_FORWARD, CONSTANT_PAR, CONSTANT_ZERO, NATIVE)",
                        "2024-03-12"
                    }
                };
            }
            
            // Monitoring des indicateurs de performance
            std::vector<PerformanceIndicator> get_performance_indicators() const {
                return {
                    {
                        "Unexplained P&L", 0.0, 100000.0, 1000000.0, "EUR",
                        "P&L inexpliqué dû aux problèmes de modèle", true
                    },
                    {
                        "Model Reserve Size", 0.0, 0.05, 0.10, "Ratio",
                        "Taille relative des réserves modèle par rapport à la PV", true
                    },
                    {
                        "IPV Test Results", 0.98, 0.95, 0.90, "Success Rate",
                        "Résultats des tests de prix IPV par VC", true
                    },
                    {
                        "Risk Instabilities", 0, 5, 10, "Count",
                        "Nombre d'instabilités de risque produites par les modèles", true
                    },
                    {
                        "Calibration Success Rate", 1.0, 0.99, 0.95, "Ratio",
                        "Taux de succès de calibration du modèle", true
                    },
                    {
                        "Pricing Performance", 0.001, 0.01, 0.1, "Seconds",
                        "Temps moyen de pricing par transaction", true
                    }
                };
            }
            
            // Validation des paramètres en temps réel
            bool validate_parameter(const std::string& object_name,
                                  const std::string& parameter_name,
                                  const std::string& parameter_value) const {
                
                auto rules = get_parameter_control_rules();
                
                for (const auto& rule : rules) {
                    if (rule.parameter_object == object_name && 
                        rule.parameter_name == parameter_name) {
                        
                        // Vérifier si la valeur est dans les valeurs autorisées
                        auto it = std::find(rule.allowed_values.begin(), 
                                          rule.allowed_values.end(), 
                                          parameter_value);
                        
                        if (it == rule.allowed_values.end()) {
                            XSIGMA_LOG_ERROR("Paramètre " + parameter_name + 
                                            " avec valeur " + parameter_value + 
                                            " non autorisé selon la règle " + rule.rule_id);
                            return false;
                        }
                        
                        XSIGMA_LOG_DEBUG("Paramètre " + parameter_name + 
                                        " validé selon la règle " + rule.rule_id);
                        return true;
                    }
                }
                
                XSIGMA_LOG_WARNING("Aucune règle trouvée pour le paramètre " + 
                                  object_name + "::" + parameter_name);
                return true; // Pas de règle = autorisé par défaut
            }
            
            // Monitoring automatique des indicateurs
            std::map<std::string, bool> monitor_performance_indicators() const {
                std::map<std::string, bool> monitoring_results;
                auto indicators = get_performance_indicators();
                
                for (const auto& indicator : indicators) {
                    bool within_warning = indicator.current_value <= indicator.threshold_warning;
                    bool within_critical = indicator.current_value <= indicator.threshold_critical;
                    
                    if (!within_critical) {
                        XSIGMA_LOG_CRITICAL("Indicateur " + indicator.indicator_name + 
                                           " dépasse le seuil critique: " + 
                                           std::to_string(indicator.current_value));
                        monitoring_results[indicator.indicator_name] = false;
                    } else if (!within_warning) {
                        XSIGMA_LOG_WARNING("Indicateur " + indicator.indicator_name + 
                                          " dépasse le seuil d'alerte: " + 
                                          std::to_string(indicator.current_value));
                        monitoring_results[indicator.indicator_name] = false;
                    } else {
                        monitoring_results[indicator.indicator_name] = true;
                    }
                }
                
                return monitoring_results;
            }
            
            // Génération de rapport de monitoring
            std::string generate_monitoring_report() const {
                std::ostringstream report;
                
                report << "=== RAPPORT DE MONITORING MODÈLE ===\n\n";
                
                // Section paramètres
                report << "## Validation des Paramètres\n";
                auto rules = get_parameter_control_rules();
                for (const auto& rule : rules) {
                    report << "- Règle " << rule.rule_id << " (" << rule.rule_name << "): " 
                           << rule.status << "\n";
                }
                
                // Section performance
                report << "\n## Indicateurs de Performance\n";
                auto indicators = get_performance_indicators();
                for (const auto& indicator : indicators) {
                    std::string status = indicator.is_within_limits ? "✅ OK" : "❌ ALERTE";
                    report << "- " << indicator.indicator_name << ": " 
                           << indicator.current_value << " " << indicator.measurement_unit 
                           << " " << status << "\n";
                }
                
                // Section recommandations
                report << "\n## Recommandations\n";
                report << "- Continuer le monitoring automatique des paramètres\n";
                report << "- Surveiller les indicateurs de performance mensuellement\n";
                report << "- Investiguer tout dépassement de seuil immédiatement\n";
                
                return report.str();
            }
        };
        
    private:
        ModelMonitoringSystem monitoring_system_;
    };
}
```
*Cette implémentation C++ dans Our project fournit un système complet de contrôle et monitoring avec validation automatique des paramètres et surveillance des indicateurs de performance.*

### Activités de Monitoring de Performance

Les activités suivantes liées aux modèles sont incluses dans le monitoring de performance :

#### Indicateurs Clés de Performance

1. **P&L Inexpliqué** dû aux problèmes de modèle
   - Surveillance continue des écarts de P&L
   - Investigation automatique des déviations significatives

2. **Taille Relative des Réserves Modèle** au niveau paire produit-modèle
   - Relative à la PV et/ou au nombre de trades
   - Déclenchement automatique d'examen pour changements > 1M EUR mois sur mois

3. **Résultats des Tests de Prix IPV** par VC
   - Validation croisée des outputs de pricing
   - Monitoring de la cohérence inter-systèmes

4. **Identification des Instabilités de Risque** produites par les modèles
   - Détection automatique des anomalies de calcul de risque
   - Alertes en temps réel pour les déviations

### Model Parameter Monitoring Rules

#### Règles Actives de Contrôle

| ID | Rule Name | Business Area | Status | Object | Parameter | Allowed Values |
|----|-----------|---------------|--------|--------|-----------|----------------|
| **11920** | InflationInterpolation | INFLATION | Released/Approved | CURVE | InflationInterpolation | FLAT, DIR, LINEAR, PWCONST_L, DIR_10, LINEAR_10, FLAT_15, PWCONST_L_15 |
| **11960** | AddPar | RATES | Released/Approved | CURVE | AddPar | NONE, LINEAR |
| **11961** | BuildMethod | RATES | Released/Approved | CURVE | BuildMethod | CONSTANT_FORWARD, HYBRID_CONSTANT_FORWARD, HYBRID_FORWARD, LINEAR_ZERO, QUADRATIC_FORWARD |
| **11962** | CashToFuture | RATES | Released/Approved | CURVE | CashToFuture | EXACT, EXACTCASH, EXACTCASH-1, CASHPRIORITY, LINEAR, NONE |
| **11963** | ExtrapMethod | RATES | Released/Approved | CURVE | ExtrapMethod | CONSTANT_FORWARD, CONSTANT_PAR, CONSTANT_ZERO, NATIVE |

#### Conditions de Validation Automatique

**CURVE Object Parameters :**
```
Target Condition: CURVE::InflationInterpolation in (FLAT, DIR, LINEAR, PWCONST_L, DIR_10, LINEAR_10, FLAT_15, PWCONST_L_15)
Target Condition: CURVE::AddPar in (NONE, LINEAR)
Target Condition: CURVE::BuildMethod in (CONSTANT_FORWARD, HYBRID_CONSTANT_FORWARD, HYBRID_FORWARD, LINEAR_ZERO, QUADRATIC_FORWARD)
Target Condition: CURVE::CashToFuture in (EXACT, EXACTCASH, EXACTCASH-1, CASHPRIORITY, LINEAR, NONE)
```

**VOL Object Parameters :**
```
Minimum Condition: AND {DBAX_Version >= 449, VOL::VolType == CORR}
Target Condition: VOL::CorrelationInterpolationSpace != BERNSTEIN
```

**FUNDING/FUNDINGVOL Object Parameters :**
```
Target Condition: FUNDING::Type == SPOTFX
Target Condition: FUNDINGVOL::RangeOfSpreadCalcMethod == EXACT
Target Condition: FUNDINGVOL::StabMaxFraction == 0.25
Target Condition: FUNDINGVOL::FrontLatticeFreq unset
Target Condition: FUNDINGVOL::FreqTimeVec unset
Target Condition: FUNDINGVOL::DecayTime unset
```

### Automated Control Framework

#### Real-time Parameter Validation
- **Validation automatique** de tous les paramètres lors de l'initialisation du modèle
- **Alertes immédiates** pour les valeurs non conformes aux règles approuvées
- **Logging complet** de toutes les validations et violations

#### Performance Threshold Monitoring
- **Seuils d'alerte** configurables pour chaque indicateur de performance
- **Escalation automatique** des dépassements de seuils critiques
- **Rapports périodiques** de statut de performance

#### Model Rule Enforcement
- **Application stricte** des règles de paramètres via le système MARS
- **Traçabilité complète** des changements de paramètres
- **Audit trail** pour toutes les modifications de configuration

### Control Assessment Summary

#### Strengths
✅ **Système de contrôle robuste** avec validation automatique des paramètres
✅ **Monitoring en temps réel** des indicateurs de performance clés
✅ **Règles de contrôle complètes** couvrant tous les objets critiques
✅ **Intégration MARS** pour la traçabilité et l'audit
✅ **Alertes automatiques** pour les déviations et violations

#### Areas for Continuous Improvement
- **Expansion du monitoring** vers de nouveaux indicateurs de performance
- **Amélioration de l'automatisation** des réponses aux alertes
- **Renforcement de l'intégration** avec les systèmes de surveillance globaux

### Servicer Model Controls

Lorsque le modèle de pricing est utilisé comme servicer, se référer à la section du rapport de validation du modèle principal sur l'évaluation des contrôles des modèles servicer.

Le système de contrôle du modèle Rate Deterministic_InflationDeterministic dans Our project assure une surveillance continue et une validation rigoureuse de tous les aspects critiques du modèle, garantissant son fonctionnement optimal et conforme aux standards réglementaires.
