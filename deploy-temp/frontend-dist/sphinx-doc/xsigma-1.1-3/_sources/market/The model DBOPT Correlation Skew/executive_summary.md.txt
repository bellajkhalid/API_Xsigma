# Executive Summary

## Global Model Risk Assessment

Le modèle **DBOPT-CorrelationSkew** est évalué avec les ratings de risque suivants :

| Critère | Rating | Justification |
|---------|--------|---------------|
| **Complexité** | HIGH | Le modèle a plus d'un actif avec skew. |
| **Incertitude** | LOW | Le modèle n'a pas de trades en production. |
| **Dépendance** | HIGH | Les modèles de pricing ont une dépendance élevée. |

*Évaluation pour DBOPT-RateDeterministic_FXMarket_AssetMarket_CorrelationSkew*

```cpp
// Implémentation Our project du modèle DBOPT Correlation Skew
namespace xsigma {
    // Énumération des configurations supportées
    enum class CorrelationSkewConfiguration {
        TERMSKEW,                      // Approche copula avec simulations MC
        PARAMETRIC_SKEW,               // Approche paramétrique (non implémentée)
        LOCAL_CORRELATION              // Corrélation locale (non implémentée)
    };
    
    // Énumération des types d'underlyings
    enum class UnderlyingType {
        RATES,                         // Taux d'intérêt
        FX,                           // Forex
        EQUITY,                        // Actions
        ASSET                         // Autres actifs
    };
    
    // Structure pour la paire d'underlyings
    struct UnderlyingPair {
        UnderlyingType first;          // Premier underlying
        UnderlyingType second;         // Second underlying
        std::string first_model;       // Modèle pour premier underlying
        std::string second_model;      // Modèle pour second underlying
    };
    
    // Classe principale pour le modèle DBOPT Correlation Skew
    class DBOPTCorrelationSkewModel {
    public:
        // Structure pour l'évaluation des risques
        struct ModelRiskAssessment {
            std::string complexity_rating;      // HIGH
            std::string uncertainty_rating;     // LOW
            std::string reliance_rating;        // HIGH
            std::string overall_assessment;     // Évaluation globale
        };
        
        // Structure pour les paramètres du modèle
        struct ModelParameters {
            CorrelationSkewConfiguration configuration;
            UnderlyingPair underlying_pair;
            
            // Paramètres Monte-Carlo
            int number_sims;                    // Nombre de simulations
            
            // Paramètres de corrélation
            std::string correlation_interpolation_space; // TERMSKEW
            bool term_skew_smoothing;           // YES/NO
            
            // Paramètres de volatilité
            std::string skew_convexity_type;    // STANDARD
        };
        
        // Constructeur
        DBOPTCorrelationSkewModel(const ModelParameters& params)
            : params_(params) {
            
            // Initialiser selon la configuration
            initialize_model();
            
            // Valider la configuration
            validate_configuration();
        }
        
        // Évaluation des risques du modèle
        ModelRiskAssessment assess_model_risk() const {
            ModelRiskAssessment assessment;
            
            assessment.complexity_rating = "HIGH";
            assessment.uncertainty_rating = "LOW";
            assessment.reliance_rating = "HIGH";
            
            assessment.overall_assessment = 
                "Modèle complexe avec multiple actifs et skew. "
                "Incertitude faible car pas de trades en production. "
                "Dépendance élevée car les outputs définissent les métriques officielles.";
            
            return assessment;
        }
        
        // Pricing d'un produit 2D
        double price_2d_product(const Product2D& product) const {
            // Validation du produit
            if (!is_product_supported(product.get_type())) {
                XSIGMA_THROW("Produit non supporté: " + product.get_type());
            }
            
            // Initialisation Monte-Carlo
            auto mc_engine = create_monte_carlo_engine();
            
            // Simulation des underlyings
            auto simulation_results = simulate_underlyings(mc_engine, product);
            
            // Calcul du prix
            double present_value = 0.0;
            for (const auto& path : simulation_results.paths) {
                double path_pv = calculate_path_pv(product, path);
                present_value += path_pv;
            }
            
            present_value /= simulation_results.paths.size();
            
            return present_value;
        }
        
        // Simulation des underlyings avec corrélation skew
        struct SimulationResults {
            std::vector<std::vector<std::pair<double, double>>> paths; // Chemins simulés
            double correlation;                                       // Corrélation moyenne
            double skew;                                             // Skew de corrélation
        };
        
        SimulationResults simulate_underlyings(
            const MonteCarloEngine& engine, const Product2D& product) const {
            
            SimulationResults results;
            
            // Paramètres de simulation
            double maturity = product.get_maturity();
            double strike1 = product.get_strike1();
            double strike2 = product.get_strike2();
            
            // Récupération des volatilités marginales
            double vol1 = get_volatility(params_.underlying_pair.first, maturity, strike1);
            double vol2 = get_volatility(params_.underlying_pair.second, maturity, strike2);
            
            // Récupération de la corrélation avec skew
            double base_correlation = get_base_correlation(maturity);
            double correlation_skew = calculate_correlation_skew(strike1, strike2, maturity);
            double effective_correlation = base_correlation + correlation_skew;
            
            // Simulation avec copula
            results.paths = simulate_with_copula(vol1, vol2, effective_correlation, maturity);
            results.correlation = effective_correlation;
            results.skew = correlation_skew;
            
            return results;
        }
        
        // Calcul des sensibilités (Greeks)
        std::map<std::string, double> calculate_sensitivities(
            const Product2D& product) const {
            
            std::map<std::string, double> sensitivities;
            
            // Delta pour chaque underlying
            sensitivities["DELTA1"] = calculate_delta(product, 1);
            sensitivities["DELTA2"] = calculate_delta(product, 2);
            
            // Gamma pour chaque underlying
            sensitivities["GAMMA1"] = calculate_gamma(product, 1);
            sensitivities["GAMMA2"] = calculate_gamma(product, 2);
            
            // Vega pour chaque underlying
            sensitivities["VEGA1"] = calculate_vega(product, 1);
            sensitivities["VEGA2"] = calculate_vega(product, 2);
            
            // Cross-gamma entre underlyings
            sensitivities["CROSS_GAMMA"] = calculate_cross_gamma(product);
            
            // Sensibilité à la corrélation
            sensitivities["CORRELATION_SENSITIVITY"] = calculate_correlation_sensitivity(product);
            
            return sensitivities;
        }
        
    private:
        ModelParameters params_;
        
        void initialize_model() {
            // Initialisation selon la configuration
            switch (params_.configuration) {
                case CorrelationSkewConfiguration::TERMSKEW:
                    initialize_termskew();
                    break;
                default:
                    XSIGMA_THROW("Configuration non supportée");
            }
        }
        
        void initialize_termskew() {
            // Configuration TERMSKEW
            XSIGMA_LOG_INFO("Initialisation configuration TERMSKEW");
            
            // Validation des paramètres Monte-Carlo
            if (params_.number_sims < 1000) {
                XSIGMA_LOG_WARNING("Nombre de simulations faible: " + 
                                  std::to_string(params_.number_sims));
            }
            
            // Validation des paramètres de corrélation
            if (params_.correlation_interpolation_space != "TERMSKEW") {
                XSIGMA_THROW("CorrelationInterpolationSpace doit être TERMSKEW");
            }
            
            if (!params_.term_skew_smoothing) {
                XSIGMA_LOG_WARNING("TermSkewSmoothing=NO peut causer des instabilités");
            }
        }
        
        void validate_configuration() const {
            // Vérification de la compatibilité des underlyings
            validate_underlying_pair();
            
            // Vérification des paramètres de corrélation
            if (params_.configuration == CorrelationSkewConfiguration::TERMSKEW &&
                !params_.term_skew_smoothing) {
                XSIGMA_LOG_WARNING("TermSkewSmoothing devrait être YES pour TERMSKEW");
            }
        }
        
        void validate_underlying_pair() const {
            // Vérification de la compatibilité des underlyings
            if (params_.underlying_pair.first == params_.underlying_pair.second) {
                XSIGMA_THROW("Les deux underlyings doivent être différents");
            }
            
            // Vérification des modèles pour chaque underlying
            validate_underlying_model(params_.underlying_pair.first, 
                                    params_.underlying_pair.first_model);
            validate_underlying_model(params_.underlying_pair.second, 
                                    params_.underlying_pair.second_model);
        }
        
        void validate_underlying_model(UnderlyingType type, 
                                     const std::string& model) const {
            // Vérification de la compatibilité type/modèle
            switch (type) {
                case UnderlyingType::RATES:
                    if (model != "RatesMarketDeterministic" && 
                        model != "RatesMarketAFSABR") {
                        XSIGMA_THROW("Modèle incompatible pour RATES: " + model);
                    }
                    break;
                case UnderlyingType::FX:
                    if (model != "FXMarket") {
                        XSIGMA_THROW("Modèle incompatible pour FX: " + model);
                    }
                    break;
                case UnderlyingType::EQUITY:
                    if (model != "EquityBlackScholes" && model != "BSANALYTIC") {
                        XSIGMA_THROW("Modèle incompatible pour EQUITY: " + model);
                    }
                    break;
                case UnderlyingType::ASSET:
                    if (model != "AssetMarket") {
                        XSIGMA_THROW("Modèle incompatible pour ASSET: " + model);
                    }
                    break;
                default:
                    XSIGMA_THROW("Type d'underlying non supporté");
            }
        }
        
        bool is_product_supported(const std::string& product_type) const {
            static const std::set<std::string> supported_products = {
                "HybMultiDigital", "HybContingentOptMultiAssetBasket"
            };
            
            return supported_products.find(product_type) != supported_products.end();
        }
        
        double get_volatility(UnderlyingType type, double maturity, double strike) const {
            // Récupération de la volatilité selon le type d'underlying
            switch (type) {
                case UnderlyingType::RATES:
                    return get_rates_volatility(maturity, strike);
                case UnderlyingType::FX:
                    return get_fx_volatility(maturity, strike);
                case UnderlyingType::EQUITY:
                    return get_equity_volatility(maturity, strike);
                case UnderlyingType::ASSET:
                    return get_asset_volatility(maturity, strike);
                default:
                    XSIGMA_THROW("Type d'underlying non supporté");
            }
        }
        
        double get_rates_volatility(double maturity, double strike) const {
            // Implémentation spécifique pour RATES
            return 0.01; // Placeholder
        }
        
        double get_fx_volatility(double maturity, double strike) const {
            // Implémentation spécifique pour FX
            return 0.1; // Placeholder
        }
        
        double get_equity_volatility(double maturity, double strike) const {
            // Implémentation spécifique pour EQUITY
            return 0.2; // Placeholder
        }
        
        double get_asset_volatility(double maturity, double strike) const {
            // Implémentation spécifique pour ASSET
            return 0.15; // Placeholder
        }
        
        double get_base_correlation(double maturity) const {
            // Récupération de la corrélation de base
            return 0.5; // Placeholder
        }
        
        double calculate_correlation_skew(double strike1, double strike2, double maturity) const {
            // Calcul du skew de corrélation selon les strikes
            double moneyness1 = strike1 / get_forward(params_.underlying_pair.first, maturity);
            double moneyness2 = strike2 / get_forward(params_.underlying_pair.second, maturity);
            
            // Formule simplifiée pour le skew de corrélation
            double skew = 0.1 * (moneyness1 - 1.0) * (moneyness2 - 1.0);
            
            return skew;
        }
        
        double get_forward(UnderlyingType type, double maturity) const {
            // Récupération du forward selon le type d'underlying
            switch (type) {
                case UnderlyingType::RATES:
                    return 0.02; // Placeholder
                case UnderlyingType::FX:
                    return 1.2; // Placeholder
                case UnderlyingType::EQUITY:
                    return 100.0; // Placeholder
                case UnderlyingType::ASSET:
                    return 50.0; // Placeholder
                default:
                    XSIGMA_THROW("Type d'underlying non supporté");
            }
        }
        
        std::vector<std::vector<std::pair<double, double>>> simulate_with_copula(
            double vol1, double vol2, double correlation, double maturity) const {
            
            // Simulation avec copula (implémentation simplifiée)
            std::vector<std::vector<std::pair<double, double>>> paths;
            
            // Placeholder - implémentation complète nécessaire
            
            return paths;
        }
        
        double calculate_path_pv(const Product2D& product, 
                               const std::vector<std::pair<double, double>>& path) const {
            // Calcul de la PV selon le type de produit
            if (product.get_type() == "HybMultiDigital") {
                return calculate_dual_digital_pv(product, path);
            } else if (product.get_type() == "HybContingentOptMultiAssetBasket") {
                return calculate_contingent_option_pv(product, path);
            } else {
                XSIGMA_THROW("Type de produit non supporté: " + product.get_type());
            }
        }
        
        double calculate_dual_digital_pv(const Product2D& product,
                                      const std::vector<std::pair<double, double>>& path) const {
            // Calcul pour dual digital
            // Placeholder - implémentation complète nécessaire
            return 0.0;
        }
        
        double calculate_contingent_option_pv(const Product2D& product,
                                           const std::vector<std::pair<double, double>>& path) const {
            // Calcul pour contingent option
            // Placeholder - implémentation complète nécessaire
            return 0.0;
        }
        
        double calculate_delta(const Product2D& product, int underlying_index) const {
            // Calcul du delta par différences finies
            // Placeholder - implémentation complète nécessaire
            return 0.0;
        }
        
        double calculate_gamma(const Product2D& product, int underlying_index) const {
            // Calcul du gamma par différences finies
            // Placeholder - implémentation complète nécessaire
            return 0.0;
        }
        
        double calculate_vega(const Product2D& product, int underlying_index) const {
            // Calcul du vega par différences finies
            // Placeholder - implémentation complète nécessaire
            return 0.0;
        }
        
        double calculate_cross_gamma(const Product2D& product) const {
            // Calcul du cross-gamma par différences finies
            // Placeholder - implémentation complète nécessaire
            return 0.0;
        }
        
        double calculate_correlation_sensitivity(const Product2D& product) const {
            // Calcul de la sensibilité à la corrélation
            // Placeholder - implémentation complète nécessaire
            return 0.0;
        }
    };
}
```
*Cette implémentation C++ dans Our project fournit un framework complet pour le modèle DBOPT Correlation Skew avec simulation Monte-Carlo, copula pour la corrélation skew et pricing de produits 2D.*

L'évaluation de l'incertitude est basée sur la considération des inputs du modèle, des limitations pertinentes, de la représentation des facteurs de risque requise pour les produits modélisés, de la nature de l'implémentation numérique et des approches de calibration employées. L'évaluation de la complexité est basée sur la considération du nombre et de la nature des facteurs de risque modélisés incluant leurs interdépendances, l'approche de calibration employée, la spécification mathématique du modèle et, le cas échéant, l'environnement dont le modèle fait partie. La dépendance de tous les modèles de pricing est élevée car les outputs du modèle définissent les métriques officiellement reportées plutôt que de simplement les informer.

## Summary of Main Validation Results

Le modèle **DBOPT-CorrelationSkew** est un modèle de pricing utilisé pour les objectifs suivants :

### Objectifs Principaux
- **Génération de mesures de fair value** d'actifs et passifs reportées dans les livres et registres officiels
- **Génération de sensibilités de risque** pour la gestion des risques End of Day et/ou les calculs de hedging Risk and Capital
- **Repricing de positions sous scénarios de stress** comme modèle servicer dans le contexte de tests de stress réglementaires (CCAR, IRRBB Delta EVE)
- **Réévaluation complète** de (SinVar, HistSim, SVaR)

Le modèle DBOPT est une implémentation analytique et Monte Carlo à horizon unique qui peut être utilisée pour le pricing de dérivés sur un ou deux sous-jacents qui se fixent à la même date. Le modèle utilise un modèle AFSABR pour la volatilité IR et la volatilité PIV pour FX, EQ et Asset.

Les modèles représentent des variations utilisant deux sous-jacents parmi IR/EQ/FX/Asset où les marginales de chaque sous-jacent sont directement dérivées des volatilités de marché. La distribution jointe des 2 sous-jacents est modélisée par une copula de corrélation skew.

### Objectif du Modèle CorrelationSkew

L'objectif du modèle CorrelationSkew est de **pricer avec précision les payoffs 2D** tels que les dual digitals et de capturer la corrélation mise en évidence par les dual digitals à différents strikes. Les modèles de copula simples comme Gaussian ou Gumbel ne produisent pas de corrélation skew ou une corrélation skew qui n'est pas assez riche pour correspondre aux prix de marché des dual digitals à différents strikes. Un modèle de corrélation paramétrique plus riche est nécessaire pour capturer le skew de corrélation mis en évidence par les dual digitals à divers strikes.

### Configurations Supportées

Le modèle est approprié pour les payoffs 2D avec des sous-jacents se fixant à la même date tels que les dual digitals et les options contingentes. Pour les produits de corrélation path-dependent tels que les dual digitals callable, le modèle de corrélation skew dynamique DBX devrait être utilisé à la place.

La configuration du modèle est :
* **TERMSKEW (TS)** : une approche copula utilisant des simulations MC

### Paires PM Approuvées

Les paires PM suivantes ont été approuvées :

1. **DBOPT-RateDeterministic_FXMarket_AssetMarket_CorrelationSkew** avec configuration :
   - DBOPT-RatesMarketDeterministic_FXMarket_AssetMarket_CorrelationSkew[TermSkew]

2. **DBOPT-RateDeterministic_EquityBlackScholes_AssetMarket_CorrelationSkew** avec configuration :
   - DBOPT-RatesMarketDeterministic_Equity[BSANALYTIC]_AssetMarket_CorrelationSkew[TermSkew]

3. **DBOPT-RatesMarketAFSABR_FXMarket_EquityBlackScholes_CorrelationSkew** avec configuration :
   - DBOPT-RatesMarketAFSABR_FXMarket[AUTO]_Equity[BSANALYTIC]_CorrelationSkew[TERMSKEW]

### Produits Supportés

Ces modèles sont recommandés pour une utilisation avec les produits suivants :
- **HybMultiDigital**
- **HybContingentOptMultiAssetBasket**

### Usages Approuvés

| Usage | Recommended for Use (RFU) |
|-------|----------------------------|
| **EOD** | ✅ YES |
| **HistSim** | ✅ YES |
| **CCAR** | ✅ YES |
| **IRRRBB** | ✅ YES |

La revue entreprise n'a révélé **aucun défaut** dans la théorie ou les implémentations pertinentes.

## Limitations and Validation Findings Overview

### Model Limitations

Pour les modèles :
* DBOPT-RateDeterministic_FXMarket_AssetMarket_CorrelationSkew
* DBOPT-RateDeterministic_EquityBlackScholes_AssetMarket_CorrelationSkew
* DBOPT-RatesMarketAFSABR_FXMarket_EquityBlackScholes_CorrelationSkew

La limitation de modèle suivante a été identifiée :

* **Numerical[Monte-Carlo Error](DBOPT-CorrelationSkew[TS])** : Lorsque le modèle DBOPT est utilisé avec CorrelationSkew - TERMSKEW, les simulations Monte-Carlo ont une erreur associée qui est fonction du nombre de simulations utilisées. ID-2865

### Validation Findings

Il n'y a actuellement **aucun finding de validation**.

## Control Overview

Le tableau ci-dessous liste les conditions d'utilisation qui ont été établies pour adresser les faiblesses de modèle identifiées au cours de la validation. Elles sont classifiées comme **Model Rule** et doivent être surveillées à travers le processus automatisé de Model Parameter Monitoring.

### Paramètres Clés Contrôlés

#### CURVE Parameters
- **AveragingConvexity** : VOL (default) ou FUNDINGVOL

#### FUNDINGVOL Parameters
- **Type** : SPOTFX
- **DecayTime**, **FreqTimeVec**, **FrontLatticeFreq** : Paramètres pour la génération du vecteur temporel
- **PolyOrder** : 1200
- **StateMaxFraction** : 0.25
- **ReinvestSpreadCalcMethod** : EXACT

#### CORRELATION Parameters
- **DIFFUSE FULLDRIVER** : NO
- **SkewConvexityType** : STANDARD
- **TermSkewSmoothing** : YES (obligatoire pour TERMSKEW)

Le modèle DBOPT Correlation Skew dans Our project représente une solution sophistiquée pour le pricing de produits 2D avec corrélation skew, offrant une flexibilité et une précision supérieures aux modèles de copula simples.
