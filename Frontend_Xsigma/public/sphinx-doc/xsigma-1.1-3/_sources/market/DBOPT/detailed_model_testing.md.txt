# Detailed Model Testing

## üî¨ **Tests Sp√©cifiques D√©taill√©s du Mod√®le**

Cette section pr√©sente les tests d√©taill√©s effectu√©s pour valider les composants sp√©cifiques du mod√®le DBOPT-RateDeterministic_InflationDeterministic, couvrant tous les aspects techniques de l'impl√©mentation.

---

## üìä **4.1.1 Inflation Interpolation Testing**

### **M√©thodologies d'Interpolation**
Nous commen√ßons nos tests du mod√®le en nous concentrant sur la m√©thodologie d'interpolation d'inflation et son impact sur les forwards d'inflation projet√©s.

#### **Types d'Interpolation Support√©s**
DBAnalytics supporte deux types principaux d'interpolation de courbe :

##### **üîß FLAT Interpolation**
```cpp
// Impl√©mentation FLAT dans Our project
class flat_interpolation : public interpolation_base {
public:
    double interpolate(const datetime& target_date) const override {
        // Recherche du n≈ìud le plus proche (√† gauche)
        auto it = std::lower_bound(node_dates_.begin(), node_dates_.end(), target_date);
        
        if (it == node_dates_.begin()) {
            return node_values_[0];
        } else if (it == node_dates_.end()) {
            return node_values_.back();
        } else {
            // Utilisation de la valeur du n≈ìud pr√©c√©dent
            size_t index = std::distance(node_dates_.begin(), it) - 1;
            return node_values_[index];
        }
    }
    
    // √âquation (5) : Interpolation FLAT
    double get_inflation_forward_flat(const datetime& date) const {
        // Pour FLAT: I(t) = I(t_i) pour t_i ‚â§ t < t_{i+1}
        return interpolate(date);
    }
};
```
*Cette impl√©mentation C++ dans Our project montre la m√©thode d'interpolation FLAT qui maintient des valeurs constantes entre les n≈ìuds, assurant la stabilit√© num√©rique.*

##### **üîß DIR Interpolation**
```cpp
// Impl√©mentation DIR dans Our project
class dir_interpolation : public interpolation_base {
public:
    double interpolate(const datetime& target_date) const override {
        auto it = std::lower_bound(node_dates_.begin(), node_dates_.end(), target_date);
        
        if (it == node_dates_.begin()) {
            return node_values_[0];
        } else if (it == node_dates_.end()) {
            return extrapolate_beyond_last_node(target_date);
        } else {
            // Interpolation lin√©aire entre n≈ìuds
            size_t index = std::distance(node_dates_.begin(), it);
            return linear_interpolate(target_date, index - 1, index);
        }
    }
    
    // √âquation (6) : Interpolation DIR
    double get_inflation_forward_dir(const datetime& date) const {
        // Pour DIR: interpolation lin√©aire des taux d'inflation
        return interpolate(date);
    }
    
private:
    double linear_interpolate(const datetime& target, size_t i1, size_t i2) const {
        double t1 = date_to_time_fraction(node_dates_[i1]);
        double t2 = date_to_time_fraction(node_dates_[i2]);
        double t = date_to_time_fraction(target);
        
        double weight = (t - t1) / (t2 - t1);
        return node_values_[i1] * (1.0 - weight) + node_values_[i2] * weight;
    }
};
```

#### **Tests de Validation d'Interpolation**
```cpp
// Tests de validation des m√©thodes d'interpolation
void test_interpolation_methods() {
    // Configuration des donn√©es de test
    std::vector<datetime> test_dates = {
        datetime(2024, 1, 1),
        datetime(2025, 1, 1),
        datetime(2027, 1, 1),
        datetime(2030, 1, 1)
    };
    
    std::vector<double> test_rates = {0.025, 0.028, 0.032, 0.035};
    
    // Test FLAT interpolation
    flat_interpolation flat_interp(test_dates, test_rates);
    
    // Test DIR interpolation
    dir_interpolation dir_interp(test_dates, test_rates);
    
    // Validation de coh√©rence
    for (const auto& date : test_dates) {
        double flat_value = flat_interp.interpolate(date);
        double dir_value = dir_interp.interpolate(date);
        
        // Aux n≈ìuds, les deux m√©thodes doivent donner le m√™me r√©sultat
        EXPECT_NEAR(flat_value, dir_value, 1e-10);
    }
    
    // Test de comportement entre n≈ìuds
    datetime mid_date(2026, 1, 1); // Entre 2025 et 2027
    
    double flat_mid = flat_interp.interpolate(mid_date);
    double dir_mid = dir_interp.interpolate(mid_date);
    
    // FLAT doit utiliser la valeur pr√©c√©dente
    EXPECT_NEAR(flat_mid, test_rates[1], 1e-10); // 0.028
    
    // DIR doit interpoler lin√©airement
    double expected_dir = test_rates[1] + 0.5 * (test_rates[2] - test_rates[1]);
    EXPECT_NEAR(dir_mid, expected_dir, 1e-10);
}
```

---

## ‚è±Ô∏è **4.1.2 Inflation Delay Testing**

### **Param√®tre de D√©lai d'Inflation**
Le param√®tre de d√©lai d'inflation (lag) sp√©cifie le d√©calage entre la date pour laquelle la courbe d'indice d'inflation est interrog√©e et la date de fixing r√©elle de l'indice d'inflation correspondant.

#### **Impl√©mentation du D√©lai**
```cpp
// Gestion du d√©lai d'inflation dans Our project
class inflation_delay_handler {
private:
    tenor observation_lag_;  // D√©lai d'observation (ex: 2M, 3M)
    
public:
    inflation_delay_handler(const tenor& lag) : observation_lag_(lag) {}
    
    datetime get_fixing_date(const datetime& query_date) const {
        // Application du d√©lai d'observation
        return datetime_helper::add_tenor(query_date, observation_lag_, -1);
    }
    
    double get_cpi_with_delay(const datetime& query_date,
                             const inflation_curve& curve) const {
        datetime fixing_date = get_fixing_date(query_date);
        
        // R√©cup√©ration de la valeur CPI √† la date de fixing
        return curve.cpi(fixing_date, tenor("0D"));
    }
    
    // Test de validation du d√©lai
    void validate_delay_consistency() const {
        datetime test_date(2024, 6, 15);
        datetime expected_fixing = datetime(2024, 4, 15); // 2M de d√©lai
        
        datetime actual_fixing = get_fixing_date(test_date);
        
        EXPECT_EQ(actual_fixing, expected_fixing);
    }
};
```

#### **Tests de D√©lai Typiques**
```cpp
// Tests pour diff√©rents d√©lais d'inflation
void test_inflation_delays() {
    std::vector<tenor> test_lags = {
        tenor("1M"), tenor("2M"), tenor("3M"), tenor("6M")
    };
    
    datetime base_date(2024, 6, 15);
    
    for (const auto& lag : test_lags) {
        inflation_delay_handler handler(lag);
        
        datetime fixing_date = handler.get_fixing_date(base_date);
        
        // Validation que le d√©lai est correctement appliqu√©
        auto expected_date = datetime_helper::add_tenor(base_date, lag, -1);
        EXPECT_EQ(fixing_date, expected_date);
        
        // Test de coh√©rence temporelle
        EXPECT_LT(fixing_date, base_date);
        
        std::cout << "Lag: " << lag.to_string() 
                  << ", Base: " << base_date.to_string()
                  << ", Fixing: " << fixing_date.to_string() << std::endl;
    }
}
```

---

## üåø **4.1.3 Inflation Seasonality Testing**

### **Ajustements Saisonniers**
Les ajustements saisonniers permettent de mod√©liser les variations cycliques annuelles des indices d'inflation.

#### **Impl√©mentation des Ajustements Saisonniers**
```cpp
// Gestion de la saisonnalit√© dans Our project
class seasonality_adjustment_handler {
private:
    std::vector<double> monthly_adjustments_; // 12 facteurs mensuels
    bool seasonality_enabled_;
    
public:
    seasonality_adjustment_handler(const std::vector<double>& adjustments)
        : monthly_adjustments_(adjustments), 
          seasonality_enabled_(!adjustments.empty()) {
        
        // Validation des ajustements
        if (seasonality_enabled_ && adjustments.size() != 12) {
            throw std::invalid_argument("Seasonality adjustments must have 12 monthly factors");
        }
    }
    
    double apply_seasonality(double base_value, const datetime& date) const {
        if (!seasonality_enabled_) {
            return base_value;
        }
        
        // Extraction du mois (1-12)
        year_month_day ymd(date);
        int month_index = ymd.month - 1; // Conversion en index 0-11
        
        // Application du facteur saisonnier
        return base_value * monthly_adjustments_[month_index];
    }
    
    // Validation de l'√©quation (8) : Seasonality
    void validate_seasonality_equation() const {
        // Test que le ratio des courbes avec/sans saisonnalit√©
        // correspond aux facteurs saisonniers sp√©cifi√©s
        
        datetime test_date(2024, 3, 15); // Mars
        double base_value = 100.0;
        
        double adjusted_value = apply_seasonality(base_value, test_date);
        double expected_ratio = monthly_adjustments_[2]; // Mars = index 2
        
        double actual_ratio = adjusted_value / base_value;
        EXPECT_NEAR(actual_ratio, expected_ratio, 1e-10);
    }
};
```

#### **Tests de Validation de Saisonnalit√©**
```cpp
// Tests complets de saisonnalit√©
void test_seasonality_validation() {
    // Facteurs saisonniers typiques pour UKRPI
    std::vector<double> ukrpi_seasonality = {
        1.002, 0.998, 1.005, 0.995, 1.001, 0.999,
        1.003, 0.997, 1.004, 0.996, 1.002, 1.000
    };
    
    seasonality_adjustment_handler handler(ukrpi_seasonality);
    
    // Test pour chaque mois de l'ann√©e
    for (int month = 1; month <= 12; ++month) {
        datetime test_date(2024, month, 15);
        double base_value = 250.0; // Valeur CPI de base
        
        double adjusted_value = handler.apply_seasonality(base_value, test_date);
        double expected_value = base_value * ukrpi_seasonality[month - 1];
        
        EXPECT_NEAR(adjusted_value, expected_value, 1e-8);
        
        // Validation que les oscillations sont autour de la courbe non ajust√©e
        double deviation = std::abs(adjusted_value - base_value) / base_value;
        EXPECT_LT(deviation, 0.01); // D√©viations < 1%
    }
    
    // Test de conservation de la moyenne annuelle
    double annual_average = 0.0;
    for (double factor : ukrpi_seasonality) {
        annual_average += factor;
    }
    annual_average /= 12.0;
    
    EXPECT_NEAR(annual_average, 1.0, 1e-6); // Moyenne doit √™tre proche de 1
}
```

---

## üîÑ **4.1.4 Repricing Instruments Testing**

### **Validation de Repricing**
Tests de validation que les instruments de march√© utilis√©s pour construire la courbe sont correctement repric√©s.

#### **Tests UKRPI**
```cpp
// Tests de repricing pour UKRPI
class ukrpi_repricing_tests {
public:
    struct market_instrument_ukrpi {
        std::string instrument_id;
        datetime maturity;
        double market_rate;
        instrument_type type;
    };
    
    bool validate_ukrpi_repricing() {
        // Instruments de march√© UKRPI typiques
        std::vector<market_instrument_ukrpi> ukrpi_instruments = {
            {"UKRPI_1Y", datetime(2025, 8, 29), 0.026, instrument_type::ZC_SWAP},
            {"UKRPI_2Y", datetime(2026, 8, 29), 0.028, instrument_type::ZC_SWAP},
            {"UKRPI_5Y", datetime(2029, 8, 29), 0.032, instrument_type::ZC_SWAP},
            {"UKRPI_10Y", datetime(2034, 8, 29), 0.0375, instrument_type::ZC_SWAP}
        };
        
        // Construction de la courbe
        auto ukrpi_curve = build_ukrpi_curve(ukrpi_instruments);
        
        // Validation du repricing
        bool all_repriced = true;
        
        for (const auto& instrument : ukrpi_instruments) {
            double repriced_rate = calculate_instrument_rate(ukrpi_curve, instrument);
            double rate_error = std::abs(repriced_rate - instrument.market_rate);
            
            if (rate_error > REPRICING_TOLERANCE) {
                all_repriced = false;
                log_repricing_error(instrument.instrument_id, rate_error);
            }
            
            std::cout << "Instrument: " << instrument.instrument_id
                      << ", Market: " << instrument.market_rate
                      << ", Repriced: " << repriced_rate
                      << ", Error: " << rate_error << std::endl;
        }
        
        return all_repriced;
    }
    
private:
    static constexpr double REPRICING_TOLERANCE = 1e-10; // Tol√©rance tr√®s stricte
};
```

---

## üîß **4.1.5 BuildMethodCutOff Testing**

### **Propri√©t√© BuildMethodCutOff**
Investigation de la propri√©t√© body BuildMethodCutOff qui fonctionne avec InflationInterpolation FLAT.

#### **Tests de CutOff**
```cpp
// Tests de la fonctionnalit√© BuildMethodCutOff
class buildmethod_cutoff_tests {
public:
    struct cutoff_test_configuration {
        double cutoff_value;
        interpolation_enum interpolation_method;
        std::vector<datetime> test_dates;
        std::vector<double> expected_behaviors;
    };
    
    bool test_cutoff_functionality() {
        cutoff_test_configuration config;
        config.cutoff_value = 2.0; // 2 ans
        config.interpolation_method = interpolation_enum::FLAT;
        
        // Dates de test autour du cutoff
        config.test_dates = {
            datetime(2024, 8, 29), // < cutoff
            datetime(2025, 8, 29), // = cutoff
            datetime(2026, 8, 29), // > cutoff
            datetime(2027, 8, 29)  // >> cutoff
        };
        
        auto curve = build_curve_with_cutoff(config);
        
        // Validation du comportement avant/apr√®s cutoff
        for (size_t i = 0; i < config.test_dates.size(); ++i) {
            double inflation_value = curve->get_inflation_value(config.test_dates[i]);
            
            // Validation de la continuit√© au point de cutoff
            if (i > 0) {
                double prev_value = curve->get_inflation_value(config.test_dates[i-1]);
                validate_cutoff_continuity(prev_value, inflation_value, config.cutoff_value);
            }
        }
        
        return true;
    }
    
private:
    void validate_cutoff_continuity(double prev_value, double current_value, 
                                   double cutoff) const {
        // Le comportement doit changer au cutoff mais rester continu
        double relative_change = std::abs(current_value - prev_value) / prev_value;
        
        // Pas de discontinuit√©s majeures
        EXPECT_LT(relative_change, 0.1); // < 10% de changement
    }
};
```

---

## üìà **4.1.6 Build Method Comparison**

### **Comparaison des M√©thodes de Construction**
Comparaison d√©taill√©e des diff√©rentes m√©thodes de construction de courbe disponibles.

#### **M√©thodes Test√©es**
```cpp
// Comparaison compl√®te des m√©thodes de construction
class build_method_comparison {
public:
    enum class build_method {
        LINEAR_ZERO,
        CUBIC_ZERO,
        CONSTANT_FORWARD,
        HYBRID_CONSTANT_FORWARD,
        LINEAR_FORWARD,
        QUADRATIC_FORWARD,
        QUADRATIC_ZERO,
        HYBRID_FORWARD
    };
    
    struct comparison_results {
        std::map<build_method, double> pricing_accuracy;
        std::map<build_method, double> smoothness_metric;
        std::map<build_method, double> performance_time;
        std::map<build_method, double> stability_score;
    };
    
    comparison_results compare_all_methods() {
        comparison_results results;
        
        // Test de chaque m√©thode
        for (auto method : {build_method::LINEAR_ZERO,
                           build_method::CUBIC_ZERO,
                           build_method::CONSTANT_FORWARD,
                           build_method::HYBRID_CONSTANT_FORWARD,
                           build_method::LINEAR_FORWARD,
                           build_method::QUADRATIC_FORWARD,
                           build_method::QUADRATIC_ZERO,
                           build_method::HYBRID_FORWARD}) {
            
            // Construction de courbe avec la m√©thode
            auto start_time = std::chrono::high_resolution_clock::now();
            auto curve = build_curve_with_method(method);
            auto end_time = std::chrono::high_resolution_clock::now();
            
            // M√©triques de performance
            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
                end_time - start_time);
            results.performance_time[method] = duration.count();
            
            // Pr√©cision de pricing
            results.pricing_accuracy[method] = calculate_pricing_accuracy(curve);
            
            // M√©trique de lissage
            results.smoothness_metric[method] = calculate_smoothness(curve);
            
            // Score de stabilit√©
            results.stability_score[method] = calculate_stability(curve);
        }
        
        return results;
    }
    
private:
    double calculate_smoothness(const std::shared_ptr<inflation_curve>& curve) const {
        // Calcul de la d√©riv√©e seconde pour mesurer le lissage
        double smoothness = 0.0;
        
        for (double t = 0.1; t < 10.0; t += 0.1) {
            datetime date = base_date_ + days(static_cast<int>(t * 365));
            
            double val_minus = curve->get_inflation_value(date - days(1));
            double val_center = curve->get_inflation_value(date);
            double val_plus = curve->get_inflation_value(date + days(1));
            
            double second_derivative = val_plus - 2.0 * val_center + val_minus;
            smoothness += second_derivative * second_derivative;
        }
        
        return smoothness;
    }
};
```

---

*Cette section fournit une documentation d√©taill√©e des tests sp√©cifiques au mod√®le DBOPT, int√©grant les impl√©mentations C++ de Our project avec des m√©thodologies de validation rigoureuses et compl√®tes.*
