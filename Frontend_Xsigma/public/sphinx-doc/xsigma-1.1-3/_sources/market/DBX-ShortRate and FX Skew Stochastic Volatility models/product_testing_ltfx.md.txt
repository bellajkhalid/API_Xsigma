# Product Testing: Long-Term FX Options

## üìä **Vue d'Ensemble des Produits LTFX**

### **Description des Trades**
Nous consid√©rons les trades **Long-Term FX** dans le framework DBX-ShortRate_FXSkewStochVol avec les caract√©ristiques suivantes :

#### **Structure des Produits LTFX**
- **LTFX** : Options FX vanilles long terme (> 2 ans)
- **LTFXDigital** : Options digitales FX long terme
- **LTFXConvexity** : Options avec ajustement de convexit√©
- **LTFXParForward** : Forwards FX avec parit√©

### **Sp√©cificit√©s Long-Terme**
- **Maturit√©s** : 2 √† 30 ans
- **Sensibilit√© aux taux** : Impact significatif des taux stochastiques
- **Volatilit√© forward** : Capture du forward smile FX
- **Corr√©lations IR-FX** : Mod√©lisation des corr√©lations long terme

### **Impl√©mentation dans Our project**

#### **üîß Classe LTFX**
```cpp
// Impl√©mentation du produit LTFX dans Our project
class LTFX : public fx_derivative_base {
private:
    struct ltfx_specification {
        std::string currency_pair;
        double strike;
        double expiry; // Long terme : > 2 ans
        bool is_call;
        double notional;
        std::string settlement_currency;
        ltfx_type type; // VANILLA, DIGITAL, CONVEXITY, PAR_FORWARD
    };
    
    ltfx_specification spec_;
    
public:
    LTFX(const ltfx_specification& spec) : spec_(spec) {
        validate_ltfx_specification();
    }
    
    double calculate_pv(const market_data& market) const override {
        return calculate_ltfx_pv_monte_carlo(market);
    }
    
    fx_sensitivities calculate_sensitivities(const market_data& market) const override {
        fx_sensitivities sens;
        
        // Sensibilit√©s sp√©cialis√©es pour long terme
        sens.fx_delta = calculate_ltfx_delta(market);
        sens.fx_gamma = calculate_ltfx_gamma(market);
        sens.fx_vega = calculate_ltfx_vega(market);
        sens.fx_volga = calculate_ltfx_volga(market);
        
        // Sensibilit√©s aux taux (critiques pour long terme)
        sens.domestic_ir_delta = calculate_domestic_ir_delta(market);
        sens.foreign_ir_delta = calculate_foreign_ir_delta(market);
        sens.domestic_ir_vega = calculate_domestic_ir_vega(market);
        sens.foreign_ir_vega = calculate_foreign_ir_vega(market);
        
        // Sensibilit√©s aux corr√©lations
        sens.fx_ir_correlation_sensitivity = calculate_fx_ir_correlation_sensitivity(market);
        
        return sens;
    }
    
private:
    double calculate_ltfx_pv_monte_carlo(const market_data& market) const {
        const int num_simulations = 100000;
        const int num_time_steps = static_cast<int>(spec_.expiry * 252); // Daily steps
        
        // Configuration Monte Carlo
        monte_carlo_engine mc_engine(num_simulations, num_time_steps);
        
        // Mod√®les stochastiques
        auto hull_white_domestic = create_hull_white_model(market, "DOMESTIC");
        auto hull_white_foreign = create_hull_white_model(market, "FOREIGN");
        auto fx_lsv_model = create_fx_local_stochastic_vol_model(market);
        
        double payoff_sum = 0.0;
        
        for (int sim = 0; sim < num_simulations; ++sim) {
            // G√©n√©ration de path corr√©l√©
            auto correlated_path = mc_engine.generate_correlated_path(
                hull_white_domestic, hull_white_foreign, fx_lsv_model);
            
            // Calcul du payoff
            double payoff = calculate_ltfx_payoff(correlated_path);
            payoff_sum += payoff;
        }
        
        return payoff_sum / num_simulations;
    }
    
    double calculate_ltfx_payoff(const monte_carlo_path& path) const {
        // Extraction des valeurs finales
        double final_fx = path.fx_values.back();
        double final_domestic_rate = path.domestic_rates.back();
        
        // Facteur d'actualisation
        double discount_factor = calculate_discount_factor(path.domestic_rates);
        
        double payoff = 0.0;
        
        switch (spec_.type) {
            case ltfx_type::VANILLA:
                if (spec_.is_call) {
                    payoff = std::max(final_fx - spec_.strike, 0.0);
                } else {
                    payoff = std::max(spec_.strike - final_fx, 0.0);
                }
                break;
                
            case ltfx_type::DIGITAL:
                if (spec_.is_call) {
                    payoff = (final_fx >= spec_.strike) ? 1.0 : 0.0;
                } else {
                    payoff = (final_fx <= spec_.strike) ? 1.0 : 0.0;
                }
                break;
                
            case ltfx_type::CONVEXITY:
                // Ajustement de convexit√© pour long terme
                payoff = calculate_convexity_adjusted_payoff(final_fx, path);
                break;
                
            case ltfx_type::PAR_FORWARD:
                // Forward avec ajustement de parit√©
                payoff = calculate_par_forward_payoff(final_fx, path);
                break;
        }
        
        return spec_.notional * payoff * discount_factor;
    }
    
    void validate_ltfx_specification() const {
        XSIGMA_CHECK(spec_.strike > 0, "Strike must be positive");
        XSIGMA_CHECK(spec_.expiry >= 2.0, "LTFX requires expiry >= 2 years");
        XSIGMA_CHECK(spec_.expiry <= 30.0, "LTFX maximum expiry is 30 years");
        XSIGMA_CHECK(spec_.notional != 0, "Notional cannot be zero");
        XSIGMA_CHECK(!spec_.currency_pair.empty(), "Currency pair required");
    }
};
```
*Cette impl√©mentation C++ dans Our project montre la structure compl√®te d'une option FX long terme avec pricing Monte Carlo et gestion des corr√©lations IR-FX.*

---

## üß™ **EOD Testing**

### **Tests de Fin de Journ√©e**

#### **üîç Long-Term Pricing Validation**

##### **Validation du Pricing Long Terme**
```cpp
// Tests de validation du pricing long terme pour LTFX dans Our project
class ltfx_pricing_validation_tester {
public:
    struct ltfx_test_case {
        double spot;
        double strike;
        double expiry; // Long terme
        double dom_rate;
        double for_rate;
        double fx_volatility;
        double dom_ir_volatility;
        double for_ir_volatility;
        double fx_ir_correlation;
        bool is_call;
        std::string description;
    };
    
    struct validation_results {
        std::vector<double> pricing_errors;
        std::vector<double> convergence_rates;
        bool long_term_effects_captured;
        double max_pricing_error;
    };
    
    validation_results test_long_term_pricing_accuracy() {
        validation_results results;
        
        // Cas de test long terme
        std::vector<ltfx_test_case> test_cases = {
            // Cas 5 ans
            {1.0, 1.0, 5.0, 0.03, 0.02, 0.15, 0.01, 0.012, 0.3, true, "5Y ATM Call"},
            {1.0, 1.1, 5.0, 0.03, 0.02, 0.15, 0.01, 0.012, 0.3, true, "5Y OTM Call"},
            
            // Cas 10 ans
            {1.0, 1.0, 10.0, 0.035, 0.025, 0.18, 0.015, 0.018, 0.25, true, "10Y ATM Call"},
            {1.0, 0.9, 10.0, 0.035, 0.025, 0.18, 0.015, 0.018, 0.25, false, "10Y ITM Put"},
            
            // Cas 20 ans (tr√®s long terme)
            {1.0, 1.0, 20.0, 0.04, 0.03, 0.22, 0.02, 0.025, 0.2, true, "20Y ATM Call"},
            {1.0, 1.2, 20.0, 0.04, 0.03, 0.22, 0.02, 0.025, 0.2, true, "20Y Deep OTM Call"}
        };
        
        for (const auto& test_case : test_cases) {
            // Configuration de l'option LTFX
            LTFX::ltfx_specification spec;
            spec.currency_pair = "EURUSD";
            spec.strike = test_case.strike;
            spec.expiry = test_case.expiry;
            spec.is_call = test_case.is_call;
            spec.notional = 1.0;
            spec.type = ltfx_type::VANILLA;
            
            LTFX ltfx_option(spec);
            
            // Configuration du march√©
            market_data market = create_long_term_market_data(test_case);
            
            // Pricing Monte Carlo
            double calculated_pv = ltfx_option.calculate_pv(market);
            
            // Validation contre pricing de r√©f√©rence
            double reference_pv = calculate_reference_long_term_pricing(test_case);
            
            double pricing_error = std::abs(calculated_pv - reference_pv);
            double relative_error = pricing_error / std::abs(reference_pv);
            
            results.pricing_errors.push_back(relative_error);
            
            // Test de convergence Monte Carlo
            double convergence_rate = test_monte_carlo_convergence(ltfx_option, market);
            results.convergence_rates.push_back(convergence_rate);
            
            // Validation des effets long terme
            validate_long_term_effects(ltfx_option, market, test_case);
            
            // Validation avec tol√©rance adapt√©e au long terme
            EXPECT_LT(relative_error, 0.02); // 2% de tol√©rance pour long terme
        }
        
        // Analyse globale
        results.max_pricing_error = *std::max_element(results.pricing_errors.begin(), 
                                                    results.pricing_errors.end());
        results.long_term_effects_captured = validate_long_term_behavior(results);
        
        return results;
    }
    
private:
    void validate_long_term_effects(const LTFX& ltfx_option,
                                   const market_data& market,
                                   const ltfx_test_case& test_case) {
        
        // Validation que les effets long terme sont captur√©s
        auto sensitivities = ltfx_option.calculate_sensitivities(market);
        
        // Pour les options long terme, les sensibilit√©s aux taux doivent √™tre significatives
        if (test_case.expiry >= 5.0) {
            EXPECT_GT(std::abs(sensitivities.domestic_ir_delta), 0.01);
            EXPECT_GT(std::abs(sensitivities.foreign_ir_delta), 0.01);
        }
        
        // Pour les tr√®s long terme (>10 ans), sensibilit√©s aux volatilit√©s IR importantes
        if (test_case.expiry >= 10.0) {
            EXPECT_GT(std::abs(sensitivities.domestic_ir_vega), 0.001);
            EXPECT_GT(std::abs(sensitivities.foreign_ir_vega), 0.001);
        }
        
        // Corr√©lations FX-IR doivent avoir un impact mesurable
        if (test_case.expiry >= 5.0) {
            EXPECT_GT(std::abs(sensitivities.fx_ir_correlation_sensitivity), 0.001);
        }
    }
    
    double test_monte_carlo_convergence(const LTFX& ltfx_option,
                                       const market_data& market) {
        
        // Test de convergence avec diff√©rents nombres de simulations
        std::vector<int> simulation_counts = {10000, 50000, 100000, 200000};
        std::vector<double> prices;
        
        for (int num_sims : simulation_counts) {
            // Configuration Monte Carlo temporaire
            auto temp_option = ltfx_option;
            temp_option.set_monte_carlo_simulations(num_sims);
            
            double price = temp_option.calculate_pv(market);
            prices.push_back(price);
        }
        
        // Analyse de la convergence
        double convergence_rate = 0.0;
        for (size_t i = 1; i < prices.size(); ++i) {
            double price_change = std::abs(prices[i] - prices[i-1]);
            double simulation_ratio = static_cast<double>(simulation_counts[i]) / simulation_counts[i-1];
            
            if (price_change > 1e-10) {
                convergence_rate += std::log(price_change) / std::log(simulation_ratio);
            }
        }
        
        return convergence_rate / (prices.size() - 1);
    }
};
```

#### **üîç Interest Rate Sensitivity Testing**

##### **Tests de Sensibilit√© aux Taux d'Int√©r√™t**
```cpp
// Tests de sensibilit√© aux taux pour LTFX dans Our project
class ltfx_ir_sensitivity_tester {
public:
    struct ir_sensitivity_results {
        std::map<std::string, double> ir_deltas;
        std::map<std::string, double> ir_vegas;
        std::map<std::string, double> correlation_sensitivities;
        bool ir_effects_significant;
        std::string dominant_ir_factor;
    };
    
    ir_sensitivity_results test_ir_sensitivities_long_term(
        const LTFX& ltfx_option,
        const market_data& market) {
        
        ir_sensitivity_results results;
        
        // Tests de sensibilit√© aux courbes de taux
        test_yield_curve_sensitivities(ltfx_option, market, results);
        
        // Tests de sensibilit√© aux volatilit√©s de taux
        test_ir_volatility_sensitivities(ltfx_option, market, results);
        
        // Tests de sensibilit√© aux corr√©lations FX-IR
        test_fx_ir_correlation_sensitivities(ltfx_option, market, results);
        
        // Analyse des r√©sultats
        analyze_ir_sensitivity_results(results);
        
        return results;
    }
    
private:
    void test_yield_curve_sensitivities(const LTFX& ltfx_option,
                                       const market_data& market,
                                       ir_sensitivity_results& results) {
        
        const double rate_shock = 0.0001; // 1bp
        
        // PV de base
        double pv_base = ltfx_option.calculate_pv(market);
        
        // Chocs de courbe domestique
        auto market_dom_up = shock_domestic_curve(market, +rate_shock);
        auto market_dom_down = shock_domestic_curve(market, -rate_shock);
        
        double pv_dom_up = ltfx_option.calculate_pv(market_dom_up);
        double pv_dom_down = ltfx_option.calculate_pv(market_dom_down);
        
        double domestic_ir_delta = (pv_dom_up - pv_dom_down) / (2.0 * rate_shock);
        results.ir_deltas["DOMESTIC"] = domestic_ir_delta;
        
        // Chocs de courbe √©trang√®re
        auto market_for_up = shock_foreign_curve(market, +rate_shock);
        auto market_for_down = shock_foreign_curve(market, -rate_shock);
        
        double pv_for_up = ltfx_option.calculate_pv(market_for_up);
        double pv_for_down = ltfx_option.calculate_pv(market_for_down);
        
        double foreign_ir_delta = (pv_for_up - pv_for_down) / (2.0 * rate_shock);
        results.ir_deltas["FOREIGN"] = foreign_ir_delta;
        
        // Validation que les sensibilit√©s IR sont significatives pour long terme
        auto spec = ltfx_option.get_specification();
        if (spec.expiry >= 5.0) {
            EXPECT_GT(std::abs(domestic_ir_delta), 0.01);
            EXPECT_GT(std::abs(foreign_ir_delta), 0.01);
        }
    }
    
    void test_ir_volatility_sensitivities(const LTFX& ltfx_option,
                                         const market_data& market,
                                         ir_sensitivity_results& results) {
        
        const double vol_shock = 0.01; // 1% de volatilit√©
        
        // PV de base
        double pv_base = ltfx_option.calculate_pv(market);
        
        // Chocs de volatilit√© domestique
        auto market_dom_vol_up = shock_domestic_ir_volatility(market, +vol_shock);
        double pv_dom_vol_up = ltfx_option.calculate_pv(market_dom_vol_up);
        
        double domestic_ir_vega = (pv_dom_vol_up - pv_base) / vol_shock;
        results.ir_vegas["DOMESTIC"] = domestic_ir_vega;
        
        // Chocs de volatilit√© √©trang√®re
        auto market_for_vol_up = shock_foreign_ir_volatility(market, +vol_shock);
        double pv_for_vol_up = ltfx_option.calculate_pv(market_for_vol_up);
        
        double foreign_ir_vega = (pv_for_vol_up - pv_base) / vol_shock;
        results.ir_vegas["FOREIGN"] = foreign_ir_vega;
        
        // Validation que les vegas IR sont mesurables pour long terme
        auto spec = ltfx_option.get_specification();
        if (spec.expiry >= 10.0) {
            EXPECT_GT(std::abs(domestic_ir_vega), 0.001);
            EXPECT_GT(std::abs(foreign_ir_vega), 0.001);
        }
    }
};
```

---

## üèõÔ∏è **Stability Testing**

### **Tests de Stabilit√© sous Stress**

#### **üîç Long-Term Market Stress Testing**

##### **Tests de Stress Long Terme**
```cpp
// Tests de stress long terme pour LTFX dans Our project
class ltfx_long_term_stress_tester {
public:
    void test_long_term_stress_scenarios(const LTFX& ltfx_option,
                                        const market_data& base_market) {
        
        // Tests de stress sp√©cifiques au long terme
        test_yield_curve_inversion_stress(ltfx_option, base_market);
        test_volatility_term_structure_stress(ltfx_option, base_market);
        test_correlation_breakdown_stress(ltfx_option, base_market);
        test_extreme_long_term_scenarios(ltfx_option, base_market);
    }
    
private:
    void test_yield_curve_inversion_stress(const LTFX& ltfx_option,
                                          const market_data& base_market) {
        
        std::cout << "=== Yield Curve Inversion Stress Testing ===" << std::endl;
        
        // Sc√©narios d'inversion de courbe
        std::vector<curve_inversion_scenario> scenarios = {
            {"MILD_INVERSION", create_mild_inversion_scenario()},
            {"SEVERE_INVERSION", create_severe_inversion_scenario()},
            {"PERSISTENT_INVERSION", create_persistent_inversion_scenario()}
        };
        
        for (const auto& scenario : scenarios) {
            auto stressed_market = apply_curve_inversion(base_market, scenario);
            
            // Calcul des m√©triques sous stress
            double pv = ltfx_option.calculate_pv(stressed_market);
            auto sensitivities = ltfx_option.calculate_sensitivities(stressed_market);
            
            // Validation de stabilit√©
            EXPECT_TRUE(std::isfinite(pv));
            EXPECT_GE(pv, 0.0);
            
            // Validation des sensibilit√©s sous inversion
            validate_sensitivities_under_inversion(sensitivities, scenario);
            
            std::cout << "Inversion Scenario: " << scenario.name 
                      << ", PV: " << pv 
                      << ", Dom IR Delta: " << sensitivities.domestic_ir_delta << std::endl;
        }
    }
    
    void test_extreme_long_term_scenarios(const LTFX& ltfx_option,
                                         const market_data& base_market) {
        
        std::cout << "=== Extreme Long-Term Scenarios Testing ===" << std::endl;
        
        // Sc√©narios extr√™mes long terme
        std::vector<extreme_scenario> scenarios = {
            {"HYPERINFLATION", create_hyperinflation_scenario()},
            {"DEFLATION_SPIRAL", create_deflation_scenario()},
            {"CURRENCY_CRISIS", create_currency_crisis_scenario()},
            {"INTEREST_RATE_SHOCK", create_ir_shock_scenario()}
        };
        
        for (const auto& scenario : scenarios) {
            auto stressed_market = apply_extreme_scenario(base_market, scenario);
            
            double pv = ltfx_option.calculate_pv(stressed_market);
            auto sensitivities = ltfx_option.calculate_sensitivities(stressed_market);
            
            // Validation de robustesse
            EXPECT_TRUE(std::isfinite(pv));
            
            // Tests de coh√©rence √©conomique sous stress extr√™me
            validate_economic_coherence_under_extreme_stress(
                ltfx_option, stressed_market, scenario);
            
            std::cout << "Extreme Scenario: " << scenario.name 
                      << ", PV: " << pv << std::endl;
        }
    }
};
```

---

*Cette section fournit une documentation compl√®te des tests de produit pour LTFX (Long-Term FX Options), int√©grant les impl√©mentations C++ de Our project avec des m√©thodologies de validation sp√©cialis√©es pour les d√©riv√©s FX long terme, incluant les tests de pricing Monte Carlo, sensibilit√©s aux taux d'int√©r√™t et stabilit√© sous stress long terme.*
