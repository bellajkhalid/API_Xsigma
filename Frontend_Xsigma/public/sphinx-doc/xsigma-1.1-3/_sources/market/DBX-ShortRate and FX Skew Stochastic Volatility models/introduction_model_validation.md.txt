# Introduction to Model and Validation

## üéØ **Validation Scope**

### **Objectif de la Validation**
Cette section d√©finit le scope complet de la validation pour le mod√®le **DBX-ShortRate_FXSkewStochVol**, incluant les produits couverts, les m√©thodologies de validation sp√©cialis√©es pour les d√©riv√©s FX long terme avec taux stochastiques, et les frameworks de test Monte Carlo.

### **Mod√®le dans le Scope**
- **DBX-ShortRateNormal[LVMRAUTO]_FXSkewStochVol[DLVAUTO]**

### **Version du Mod√®le**
Le mod√®le a √©t√© revu pour **DBAnalytics** avec validation compl√®te des fonctionnalit√©s Monte Carlo et performances de calibration automatique.

---

## üìä **Product Description**

### **Caract√©ristiques G√©n√©rales des Produits**

#### **Propri√©t√©s Fondamentales**
Les produits couverts par ce framework partagent les caract√©ristiques suivantes :
- **D√©pendance** aux taux de change FX et taux d'int√©r√™t multi-devises
- **Pricing Monte Carlo** via simulation de processus stochastiques corr√©l√©s
- **Maturit√©s longues** n√©cessitant mod√©lisation de taux stochastiques
- **Volatilit√© locale stochastique** pour capture du smile FX

#### **Structure Math√©matique**
Les produits peuvent √™tre repr√©sent√©s sous la forme g√©n√©rale :

$$\text{PV} = \mathbb{E}^{\mathbb{Q}}\left[\int_0^T e^{-\int_0^t r_d(s) ds} \text{Payoff}(S_t, r_d(t), r_f(t)) dt\right]$$

o√π les processus suivent des dynamiques stochastiques coupl√©es sous la mesure risque-neutre $\mathbb{Q}$.

### **Produits Sp√©cifiques**

#### **üîÑ Long-Term FX Derivatives**
**Description :** D√©riv√©s FX avec maturit√©s √©tendues n√©cessitant mod√©lisation de taux stochastiques.

**Types Couverts :**
- **LTFX** : Options vanilles long terme
- **LTFXDigital** : Options digitales long terme
- **LTFXConvexity** : Produits avec ajustement de convexit√©
- **LTFXParForward** : Forwards par avec ajustements

#### **üí∞ PRDC Swaps**
**Description :** Power Reverse Dual Currency swaps avec leverage et participation.

**Formule de Coupon :**
$$\text{Coupon}_i = L \times r_f(T_i) \times \min\left(P, \frac{S(T_i)}{B_i}\right)$$

o√π $L$ est le leverage, $P$ la participation rate, et $B_i$ la barri√®re FX.

#### **üìä IR-FX Hybrid Products**
**Description :** Produits hybrides combinant expositions taux et FX.

**Exemples :**
- **IRFXDualDigitalOpt** : Options digitales sur IR et FX
- **IRFXSwapFXOpt** : Swaps avec options FX int√©gr√©es
- **IRSwapQuanto** : Swaps avec protection de change

---

## üèóÔ∏è **Model Description**

### **Framework Th√©orique**

#### **Mod√®le DBX-ShortRate_FXSkewStochVol**
Le mod√®le DBX combine plusieurs composants stochastiques pour une mod√©lisation compl√®te des risques FX long terme.

**Composants Principaux :**
- **Taux stochastiques** Hull-White : $dr = (\theta(t) - ar) dt + \sigma dW_r$
- **Volatilit√© FX locale** : $\sigma_{LV}(t, S)$ calibr√©e via PIV AutoFit
- **Volatilit√© FX stochastique** : $dv = \kappa(\theta_v - v) dt + \sigma_v \sqrt{v} dW_v$
- **Corr√©lations** : $d\langle W_r, W_S \rangle = \rho_{r,S} dt$

#### **Impl√©mentation Monte Carlo Compl√®te**
```cpp
// Impl√©mentation compl√®te du mod√®le DBX dans Our project
class dbx_shortrate_fx_skew_stochvol_model : public monte_carlo_model_base {
private:
    struct dbx_model_parameters {
        // Param√®tres Hull-White domestiques
        hull_white_parameters domestic_hw;
        
        // Param√®tres Hull-White √©trangers
        hull_white_parameters foreign_hw;
        
        // Surface de volatilit√© locale FX
        std::shared_ptr<fx_local_volatility_surface> fx_local_vol_surface;
        
        // Param√®tres de volatilit√© stochastique FX
        stochastic_volatility_parameters fx_sv_params;
        
        // Matrice de corr√©lation compl√®te
        matrix<double> correlation_matrix; // [r_d, r_f, S, v]
        
        // Configuration Monte Carlo
        monte_carlo_configuration mc_config;
    };
    
    dbx_model_parameters params_;
    std::unique_ptr<monte_carlo_engine> mc_engine_;
    
public:
    dbx_shortrate_fx_skew_stochvol_model(const dbx_model_parameters& params) 
        : params_(params) {
        
        validate_dbx_parameters();
        initialize_monte_carlo_engine();
    }
    
    double price_derivative(const fx_derivative_base& derivative,
                           const market_data& market) const override {
        
        const int num_simulations = params_.mc_config.num_simulations;
        const int num_time_steps = calculate_time_steps(derivative.get_expiry());
        
        double pv_sum = 0.0;
        
        // Simulation Monte Carlo parall√©lis√©e
        #pragma omp parallel for reduction(+:pv_sum)
        for (int sim = 0; sim < num_simulations; ++sim) {
            // G√©n√©ration de path corr√©l√©
            auto path = generate_correlated_path(derivative, market, sim);
            
            // Calcul du payoff
            double payoff = derivative.calculate_payoff(path);
            
            pv_sum += payoff;
        }
        
        return pv_sum / num_simulations;
    }
    
    fx_sensitivities calculate_sensitivities(const fx_derivative_base& derivative,
                                           const market_data& market) const override {
        
        fx_sensitivities sens;
        
        // Delta FX par diff√©rences finies Monte Carlo
        sens.fx_delta = calculate_fx_delta_mc(derivative, market);
        
        // Vega local volatility
        sens.local_vega = calculate_local_vega_mc(derivative, market);
        
        // Vega stochastic volatility
        sens.sv_vega = calculate_sv_vega_mc(derivative, market);
        
        // Sensibilit√©s IR multi-devises
        sens.domestic_ir_delta = calculate_domestic_ir_delta_mc(derivative, market);
        sens.foreign_ir_delta = calculate_foreign_ir_delta_mc(derivative, market);
        sens.domestic_ir_vega = calculate_domestic_ir_vega_mc(derivative, market);
        sens.foreign_ir_vega = calculate_foreign_ir_vega_mc(derivative, market);
        
        // Sensibilit√©s crois√©es
        sens.fx_ir_correlation_sensitivity = calculate_fx_ir_correlation_sensitivity_mc(
            derivative, market);
        
        return sens;
    }
    
private:
    monte_carlo_path generate_correlated_path(const fx_derivative_base& derivative,
                                             const market_data& market,
                                             int simulation_index) const {
        
        monte_carlo_path path;
        
        // Initialisation des √©tats
        auto current_state = initialize_system_state(market);
        
        // G√©n√©rateur de nombres al√©atoires corr√©l√©s
        auto rng = mc_engine_->get_correlated_random_generator(simulation_index);
        
        double dt = derivative.get_expiry() / params_.mc_config.num_time_steps;
        
        for (int step = 0; step < params_.mc_config.num_time_steps; ++step) {
            // G√©n√©ration de randoms corr√©l√©s
            auto correlated_randoms = rng.generate_correlated_normals(
                params_.correlation_matrix);
            
            // √âvolution du syst√®me stochastique
            current_state = evolve_system_state(current_state, dt, correlated_randoms);
            
            // Stockage dans le path
            path.times.push_back((step + 1) * dt);
            path.domestic_rates.push_back(current_state.domestic_short_rates[0]);
            path.foreign_rates.push_back(current_state.foreign_short_rates[0]);
            path.fx_rates.push_back(current_state.fx_rate);
            path.fx_local_volatilities.push_back(current_state.fx_local_vol);
            path.fx_stochastic_vol_factors.push_back(current_state.fx_sv_factor);
        }
        
        return path;
    }
    
    system_state evolve_system_state(const system_state& current_state,
                                    double dt,
                                    const matrix<double>& correlated_randoms) const {
        
        system_state next_state;
        
        // √âvolution Hull-White domestique
        next_state.domestic_short_rates = evolve_hull_white_process(
            current_state.domestic_short_rates,
            params_.domestic_hw,
            dt,
            correlated_randoms.column(0));
        
        // √âvolution Hull-White √©tranger
        next_state.foreign_short_rates = evolve_hull_white_process(
            current_state.foreign_short_rates,
            params_.foreign_hw,
            dt,
            correlated_randoms.column(1));
        
        // √âvolution volatilit√© stochastique FX
        next_state.fx_sv_factor = evolve_stochastic_volatility_process(
            current_state.fx_sv_factor,
            params_.fx_sv_params,
            dt,
            correlated_randoms(2, 0));
        
        // Volatilit√© locale FX
        double current_time = get_current_time();
        next_state.fx_local_vol = params_.fx_local_vol_surface->get_volatility(
            current_time, current_state.fx_rate);
        
        // √âvolution FX avec volatilit√© locale stochastique
        double total_fx_vol = next_state.fx_local_vol * std::sqrt(next_state.fx_sv_factor);
        
        double fx_drift = (next_state.domestic_short_rates[0] - 
                          next_state.foreign_short_rates[0]) * current_state.fx_rate * dt;
        
        double fx_diffusion = total_fx_vol * current_state.fx_rate * 
                             std::sqrt(dt) * correlated_randoms(3, 0);
        
        next_state.fx_rate = current_state.fx_rate + fx_drift + fx_diffusion;
        
        return next_state;
    }
    
    void validate_dbx_parameters() const {
        // Validation des param√®tres Hull-White
        XSIGMA_CHECK(!params_.domestic_hw.mean_reversion_speeds.empty(),
                    "Domestic Hull-White parameters required");
        XSIGMA_CHECK(!params_.foreign_hw.mean_reversion_speeds.empty(),
                    "Foreign Hull-White parameters required");
        
        // Validation de la surface de volatilit√© locale
        XSIGMA_CHECK(params_.fx_local_vol_surface != nullptr,
                    "FX local volatility surface required");
        
        // Validation des param√®tres de volatilit√© stochastique
        XSIGMA_CHECK(params_.fx_sv_params.kappa > 0,
                    "SV mean reversion speed must be positive");
        XSIGMA_CHECK(params_.fx_sv_params.theta > 0,
                    "SV long-term mean must be positive");
        XSIGMA_CHECK(params_.fx_sv_params.sigma > 0,
                    "SV volatility must be positive");
        
        // Validation de la matrice de corr√©lation
        validate_correlation_matrix(params_.correlation_matrix);
        
        // Validation de la configuration Monte Carlo
        XSIGMA_CHECK(params_.mc_config.num_simulations > 0,
                    "Number of simulations must be positive");
        XSIGMA_CHECK(params_.mc_config.num_time_steps > 0,
                    "Number of time steps must be positive");
    }
};
```
*Cette impl√©mentation C++ dans Our project montre le mod√®le DBX complet avec simulation Monte Carlo corr√©l√©e et calcul de sensibilit√©s multi-facteurs.*

### **Calibration Automatique**

#### **PIV AutoFit**
```cpp
// Calibration automatique PIV dans Our project
class piv_autofit_calibrator {
public:
    struct piv_calibration_result {
        std::shared_ptr<fx_local_volatility_surface> calibrated_surface;
        std::vector<double> calibration_errors;
        double max_error;
        bool calibration_successful;
    };
    
    piv_calibration_result calibrate_local_volatility_surface(
        const std::vector<fx_option_quote>& market_quotes,
        const dbx_model_parameters& model_params) {
        
        piv_calibration_result result;
        
        // Configuration de l'optimisation
        levenberg_marquardt_optimizer optimizer;
        optimizer.set_max_iterations(100);
        optimizer.set_tolerance(1e-6);
        
        // Fonction objectif pour calibration PIV
        auto objective_function = [&](const vector<double>& surface_params) -> double {
            
            auto test_surface = create_local_vol_surface_from_params(surface_params);
            
            double total_error = 0.0;
            
            for (const auto& quote : market_quotes) {
                // Prix mod√®le avec surface de test
                double model_price = calculate_model_price(quote, test_surface, model_params);
                
                // Erreur vs march√©
                double error = std::pow(model_price - quote.market_price, 2);
                total_error += error;
            }
            
            return total_error;
        };
        
        // Param√®tres initiaux
        vector<double> initial_params = generate_initial_surface_parameters(market_quotes);
        
        // Optimisation
        auto optimization_result = optimizer.minimize(objective_function, initial_params);
        
        // Construction de la surface calibr√©e
        result.calibrated_surface = create_local_vol_surface_from_params(
            optimization_result.optimal_parameters);
        
        // Validation de la calibration
        result.calibration_errors = calculate_calibration_errors(
            market_quotes, result.calibrated_surface, model_params);
        
        result.max_error = *std::max_element(result.calibration_errors.begin(),
                                           result.calibration_errors.end());
        
        result.calibration_successful = (result.max_error < 1e-4); // 1bp tolerance
        
        return result;
    }
};
```

#### **DLVIR Correction**
```cpp
// Correction DLVIR dans Our project
class dlvir_correction_engine {
public:
    std::shared_ptr<fx_local_volatility_surface> apply_dlvir_correction(
        std::shared_ptr<fx_local_volatility_surface> base_surface,
        const dbx_model_parameters& model_params) {
        
        // Correction pour tenir compte des taux stochastiques
        // dans la volatilit√© locale FX
        
        auto corrected_surface = std::make_shared<fx_local_volatility_surface_corrected>();
        
        // Grille de correction
        auto time_grid = base_surface->get_time_grid();
        auto strike_grid = base_surface->get_strike_grid();
        
        for (double time : time_grid) {
            for (double strike : strike_grid) {
                
                double base_vol = base_surface->get_volatility(time, strike);
                
                // Calcul du facteur de correction DLVIR
                double correction_factor = calculate_dlvir_correction_factor(
                    time, strike, model_params);
                
                double corrected_vol = base_vol * correction_factor;
                
                corrected_surface->set_volatility(time, strike, corrected_vol);
            }
        }
        
        return corrected_surface;
    }
    
private:
    double calculate_dlvir_correction_factor(double time, double strike,
                                           const dbx_model_parameters& model_params) {
        
        // Facteur de correction tenant compte de l'impact des taux stochastiques
        // sur la volatilit√© locale FX
        
        double domestic_vol = model_params.domestic_hw.volatilities[0];
        double foreign_vol = model_params.foreign_hw.volatilities[0];
        double fx_ir_correlation = model_params.correlation_matrix(0, 3);
        
        // Approximation analytique du facteur de correction
        double correction = 1.0 + fx_ir_correlation * (domestic_vol - foreign_vol) * 
                           std::sqrt(time) * (strike - 1.0);
        
        return std::max(correction, 0.1); // Borne inf√©rieure pour stabilit√©
    }
};
```

---

## üìà **Model Configurations**

### **Configuration Compl√®te**

#### **DBX-ShortRateNormal[LVMRAUTO]_FXSkewStochVol[DLVAUTO]**
```cpp
// Configuration compl√®te DBX dans Our project
struct dbx_complete_configuration {
    // Configuration Hull-White
    struct hull_white_config {
        std::string model_type = "NORMAL"; // ou "LOGNORMAL"
        std::string calibration_method = "LVMRAUTO";
        std::vector<double> pillar_maturities = {0.25, 0.5, 1.0, 2.0, 5.0, 10.0};
        bool auto_mean_reversion = true;
        double mean_reversion_bounds[2] = {0.01, 0.5};
    } hw_config;
    
    // Configuration FX Skew Stochastic Volatility
    struct fx_skew_stochvol_config {
        std::string calibration_method = "DLVAUTO";
        bool enable_local_volatility = true;
        bool enable_stochastic_volatility = true;
        std::string sv_model_type = "HESTON"; // ou "SABR"
        bool auto_correlation_calibration = true;
    } fx_sv_config;
    
    // Configuration Monte Carlo
    struct monte_carlo_config {
        int num_simulations = 100000;
        int num_time_steps_per_year = 252;
        std::string random_number_generator = "MERSENNE_TWISTER";
        bool enable_antithetic_variates = true;
        bool enable_control_variates = true;
        int num_threads = std::thread::hardware_concurrency();
    } mc_config;
    
    // Configuration de validation
    struct validation_config {
        bool enable_auto_validation = true;
        double calibration_tolerance = 1e-4;
        double pricing_tolerance = 1e-6;
        bool enable_stress_testing = true;
    } validation_config;
};
```

---

## üß™ **Validation Outline**

### **M√©thodologie de Validation Sp√©cialis√©e**

#### **üîç Phase 1 : Validation Monte Carlo**
- V√©rification de la convergence Monte Carlo
- Tests de variance et biais
- Validation des techniques de r√©duction de variance

#### **üîç Phase 2 : Validation de Calibration**
- Tests PIV AutoFit avec donn√©es de march√©
- Validation DLVIR correction
- Tests de stabilit√© de calibration

#### **üîç Phase 3 : Tests de Produits**
- Pricing de d√©riv√©s FX long terme
- PRDC swaps avec features complexes
- Produits hybrides IR-FX

#### **üîç Phase 4 : Validation R√©glementaire**
- Tests CCAR avec stress multi-facteurs
- IRRBB avec expositions FX long terme
- HistSim avec corr√©lations dynamiques

### **Crit√®res d'Acceptation Sp√©cialis√©s**
- **Convergence Monte Carlo** : Erreur standard < 0.1% du prix
- **Calibration PIV** : Erreur < 1bp sur piliers
- **Performance** : Temps de calcul < 10s par trade complexe
- **Stabilit√©** : Sensibilit√©s coh√©rentes sous stress

---

*Cette section fournit une introduction compl√®te au mod√®le DBX-ShortRate_FXSkewStochVol et √† sa validation, int√©grant les impl√©mentations C++ de Our project avec les m√©thodologies de validation sp√©cialis√©es pour les d√©riv√©s FX long terme avec taux stochastiques.*
