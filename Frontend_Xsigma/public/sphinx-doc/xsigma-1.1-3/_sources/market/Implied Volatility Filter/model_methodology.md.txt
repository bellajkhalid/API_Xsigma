# Model / Methodology
## Advanced ASV Mathematical Framework and Implementation

![ASV Mathematical Framework](Fig/4.png)

### üéØ **Methodology Excellence Overview**

This section presents the **production-grade mathematical framework** underlying Our project's ASV volatility surface construction system. The methodology combines theoretical rigor with practical market requirements, delivering institutional-quality volatility surface calibration for global options markets.

### üßÆ **Mathematical Innovation Foundation**

The **ASV volatility fitter model** provides an efficient and robust framework for volatility surface calibration, validated through extensive backtests and stress tests across multiple market regimes. This sophisticated system transforms market option quotes into mathematically consistent volatility surfaces essential for pricing and risk management applications.

#### **üé™ Advanced Processing Pipeline**

The methodology employs a **sophisticated multi-stage process** ensuring optimal calibration quality:

1. **üìä Optional Repo Fitting**: Adjusts implicit forward levels for each maturity
2. **üîÑ Premium Inversion**: Converts option prices to implied volatilities
3. **üéØ Parameter Fitting**: Optimizes ASV parameters with constraint enforcement
4. **‚úÖ Quality Validation**: Comprehensive post-fitting quality assurance

**Repo fitting** is strategically performed to adjust the implicit forward levels for each maturity implied by the options market, ensuring smooth transitions from OTM put implied volatilities to OTM call implied volatilities near ATM strikes, thereby eliminating arbitrage opportunities and enhancing pricing consistency.

#### **üéõÔ∏è Enterprise-Grade Implementation Architecture**

```cpp
namespace xsigma {
    /**
     * @brief Advanced ASV calibration engine for institutional volatility surface construction
     *
     * This enterprise-grade calibration system provides sophisticated volatility surface
     * fitting with mathematical guarantees of arbitrage-free construction, comprehensive
     * quality control, and production-ready performance for institutional trading operations.
     */
    class ASVCalibrationEngine {
    public:
        // Advanced calibration configuration with institutional features
        struct CalibrationConfig {
            // Core fitting options
            bool enable_repo_fitting = true;              // Implicit forward calibration
            bool enable_term_structure_fitting = true;    // Cross-maturity consistency
            bool enable_global_fitting = true;            // Global optimization

            // Arbitrage constraint weights
            double calendar_arbitrage_weight = 1.0;       // Calendar spread constraints
            double butterfly_arbitrage_weight = 1.0;      // Butterfly spread constraints
            double convexity_constraint_weight = 0.5;     // Convexity preservation

            // Quality control parameters
            double max_pricing_error = 1e-6;              // Maximum acceptable error
            int max_optimization_iterations = 10000;      // Convergence limit
            bool enable_real_time_monitoring = true;      // Live quality tracking

            // Performance optimization
            bool parallel_processing = true;              // Multi-threaded execution
            bool vectorized_computations = true;          // SIMD optimization
            int thread_pool_size = std::thread::hardware_concurrency();
        };

        // Comprehensive calibration result with quality metrics
        struct CalibrationResult {
            ASVParameters fitted_parameters;              // Optimized ASV parameters
            double calibration_rmse;                      // Root mean square error
            double max_individual_error;                  // Maximum single point error
            bool arbitrage_free_validated;                // Arbitrage validation result
            std::chrono::milliseconds calibration_time;   // Performance timing
            QualityMetrics quality_assessment;            // Comprehensive quality report
            std::vector<std::string> warnings;            // Quality warnings
        };

        /**
         * @brief Advanced calibration with comprehensive quality assurance
         *
         * Performs sophisticated ASV parameter fitting with mathematical guarantees
         * of arbitrage-free construction and institutional-grade quality control.
         *
         * @param quotes Market option quotes (European/American, Call/Put)
         * @param initial_forward_curve Initial forward rate curve
         * @param config Advanced calibration configuration
         * @return Comprehensive calibration result with quality metrics
         */
        CalibrationResult calibrate(
            const std::vector<OptionQuote>& quotes,
            const ForwardCurve& initial_forward_curve,
            const CalibrationConfig& config) {
            
            CalibrationResult result;
            
            // Step 1: Optional repo fitting
            if (config.enable_repo_fitting) {
                result.repo_curve = fitRepoCurve(quotes, initial_forward_curve);
            } else {
                result.repo_curve = initial_forward_curve;
            }

            // Step 2: Premium inversion
            auto implied_vols = invertPremiums(quotes, result.repo_curve);

            // Step 3: ASV parameter fitting
            result.asv_parameters = fitASVParameters(implied_vols, config);

            // Step 4: Validation and post-fitting controls
            result.validation_report = validateCalibration(result);
            
            return result;
        }
        
    private:
        RepoCurve fitRepoCurve(const std::vector<OptionQuote>& quotes, 
                              const ForwardCurve& initial_curve);
        std::vector<ImpliedVolPoint> invertPremiums(const std::vector<OptionQuote>& quotes,
                                                   const RepoCurve& repo_curve);
        ASVParameters fitASVParameters(const std::vector<ImpliedVolPoint>& vol_points,
                                      const CalibrationConfig& config);
    };
}
```
*This C++ implementation in Our project shows the main structure of the ASV calibration engine with all key steps.*

### Parameter Fitting Phases

The parameter fitting phase begins with the local fitting process during which ASV parameters are fitted per maturity under calendar and butterfly arbitrage constraints. To make parameter value curves smooth on the time axis, term structure fittings per parameter are performed.

#### Fitting Sequence

1. **Local fitting** (per maturity, cross strikes)
2. **Term structure fitting** (per parameter, optional)
3. **Global fitting** (all maturities together, optional)
4. **Interpolation/extrapolation** for additional maturities

## Detailed Description

### Process Overview

The volatility fitter model performs the following steps to fit ASV parameters:

#### 1. Implicit Repo Calibration
Adjusts the forward curve through the repo curve to the implicit forward levels of the options market (see section 4.1.2)

#### 2. Volatility Inversion
Inverts option prices to Black-Scholes implied volatilities and generates target mid volatilities (see section 4.1.3)

#### 3. Volatility Surface Parameter Fitting
Fits parameterized ASV curves to target mid volatilities (see section 4.1.4)

#### 4. Two-Step Fitting (Optional)
Fits parameterized ASV curves to target mid volatilities, generates new quotes with the fitted volatility surface, then fits parameterized ASV curves to the new quotes with different market data (see section 4.1.5)

## Implicit Repo Calibration

### Objective

The objective is to adjust the forward curve through the repo curve so that the implied volatilities of call and put options with the same strike and maturity match. Repo fitting can be ignored by setting the forward curve source to "Input Forward" in the fitting instructions.

### Forward Curve Sources

The forward curve source can be one of the following:

- **Implied Forward** : Fits the repo curve and uses the new forward curve for premium inversion and volatility surface anchor strikes
- **Input Forward** : No repo fitting
- **Input Forward For Anchoring Only** : Fits the repo curve and uses the new forward curve for premium inversion only
- **Forward With Averaged Repo** : Fits the repo curve and uses the new forward curve with averaged repo curve
- **Forward With Transformed Repo** : Uses the forward curve with transformed repo curve

```cpp
// Our project implementation of different forward curve sources
namespace xsigma {
    enum class ForwardCurveSource {
        IMPLIED_FORWARD,
        INPUT_FORWARD,
        INPUT_FORWARD_FOR_ANCHORING_ONLY,
        FORWARD_WITH_AVERAGED_REPO,
        FORWARD_WITH_TRANSFORMED_REPO
    };
    
    class RepoCalibrator {
    public:
        ForwardCurve calibrateRepo(
            const std::vector<OptionQuote>& quotes,
            const ForwardCurve& initial_curve,
            ForwardCurveSource source) {
            
            switch (source) {
                case ForwardCurveSource::IMPLIED_FORWARD:
                    return calibrateImpliedForward(quotes, initial_curve);
                    
                case ForwardCurveSource::INPUT_FORWARD:
                    return initial_curve;  // Pas de calibration
                    
                case ForwardCurveSource::INPUT_FORWARD_FOR_ANCHORING_ONLY:
                    return calibrateForAnchoringOnly(quotes, initial_curve);
                    
                case ForwardCurveSource::FORWARD_WITH_AVERAGED_REPO:
                    return calibrateWithAveragedRepo(quotes, initial_curve);
                    
                case ForwardCurveSource::FORWARD_WITH_TRANSFORMED_REPO:
                    return applyTransformedRepo(initial_curve);
            }
        }
        
    private:
        ForwardCurve calibrateImpliedForward(const std::vector<OptionQuote>& quotes,
                                           const ForwardCurve& initial_curve) {
            // Complete repo calibration implementation
            // Uses Brent algorithm for each maturity
            // ...
        }
    };
}
```
*This C++ implementation in Our project handles different repo curve calibration strategies according to the configured source.*

### Start Maturity Control

A threshold `repo_fit_start_offset` (default 0) controls the start maturity. Repo fitting is ignored if the maturity is less than or equal to the pricing date plus the `repo_fit_start_offset`.

### Reference Strike Selection

Since at each maturity different quotes may imply different forward levels, only the most accurate option quotes are used. Given that quotes with strikes closest to the "at the money" (ATM) level are more accurate, the target forward level is calculated as the average of `num_strikes_for_repo_fit` forward values implied by put/call pairs with strikes closest to the switching strike.

#### Selection Methodology

- **Switching strike** : Smallest listed strike satisfying two requirements:
  - Price lower than mid put price
  - Call Vega greater than 20% of put Vega
- **Number of strikes** : `num_strikes_for_repo_fit` (default: 2)
- **Distribution** : Half above, half below the switching strike

### Bracketing Strike Selection

#### Strike Above ATM
The strike above ATM is calculated using mid premiums, i.e., the first strike for which valid call option quotes exist or the corresponding put strike above - assuming strikes in ascending order.

#### Edge Case Handling
- If no common strike between put and call: ATM determined as the highest strike for which a valid put quote exists
- Otherwise: based on previous forward curve (smallest strike above input forward level)

### European vs American Options

#### European Options
For European options, the implicit forward level is calculated using the call/put parity formula:

$$F_t = \frac{Call_t - Put_t}{DF_t} + K_t$$

Where:
- $F_t$ is the implicit forward at time t
- $Call_t$ and $Put_t$ are call and put prices
- $DF_t$ is the discount factor
- $K_t$ is the exercise price at time t

#### American Options
For American options, the repo rate is calibrated so that the implied volatilities of put and call options match within a tolerance. The Brent root-finding algorithm is used to find the zero of the function:

$$f(repo) = \sigma_{put} - \sigma_{call}$$

```cpp
// Our project implementation for American options repo calibration
namespace xsigma {
    class AmericanRepoCalibrator {
    public:
        double calibrateRepoRate(
            const PutCallPair& quotes,
            double initial_repo,
            double tolerance = 1e-8) {
            
            // Objective function for Brent
            auto objective = [&](double repo) -> double {
                // Put inversion with current repo
                double put_vol = invertAmericanOption(
                    quotes.put_price, quotes.strike, quotes.expiry,
                    quotes.forward, repo, false);

                // Call inversion with current repo
                double call_vol = invertAmericanOption(
                    quotes.call_price, quotes.strike, quotes.expiry,
                    quotes.forward, repo, true);

                return put_vol - call_vol;
            };

            // Root finding with Brent
            return brent_solver_.solve(objective, repo_min_, repo_max_, tolerance);
        }
        
    private:
        double invertAmericanOption(double price, double strike, double expiry,
                                  double forward, double repo, bool is_call) {
            // Uses Our project American options pricer
            // with Brent algorithm for volatility inversion
            // ...
        }
        
        BrentSolver brent_solver_;
        double repo_min_ = -0.5;  // -50% minimum
        double repo_max_ = 0.5;   // +50% maximum
    };
}
```
*This C++ implementation in Our project shows repo rate calibration for American options with put/call implied volatility equalization.*

## Volatility Inversion

### Robust Inversion Process

The volatility inversion process provides an efficient and robust method for converting option prices to implied volatilities, validated by extensive testing. It follows the same steps for European and American options where all quotes must have the same type.

### Supported Quote Types

Quotes can be of one of the following types:
- **Volatility** : Direct volatility quotes
- **Price** : Price quotes
- **Forward Price** : Forward price quotes

#### Handling by Quote Type

- **Volatility Type** : The fitter ignores repo and premium inversion steps, performs only parameter fitting
- **Forward Price Type** : Discounted using market data discount curve, then same steps as Price type

```cpp
// Our project implementation for handling different quote types
namespace xsigma {
    enum class QuoteType {
        VOLATILITY,
        PRICE,
        FORWARD_PRICE
    };

    class VolatilityInverter {
    public:
        std::vector<ImpliedVolPoint> invertQuotes(
            const std::vector<OptionQuote>& quotes,
            const DiscountCurve& discount_curve) {

            std::vector<ImpliedVolPoint> vol_points;

            for (const auto& quote : quotes) {
                switch (quote.type) {
                    case QuoteType::VOLATILITY:
                        // Direct volatility usage
                        vol_points.emplace_back(quote.strike, quote.expiry, quote.volatility);
                        break;

                    case QuoteType::PRICE:
                        // Price to volatility inversion
                        vol_points.emplace_back(quote.strike, quote.expiry,
                            invertPriceToVolatility(quote));
                        break;

                    case QuoteType::FORWARD_PRICE:
                        // Actualisation puis inversion
                        double discounted_price = quote.forward_price *
                            discount_curve.discount_factor(quote.expiry);
                        OptionQuote price_quote = quote;
                        price_quote.price = discounted_price;
                        price_quote.type = QuoteType::PRICE;
                        vol_points.emplace_back(quote.strike, quote.expiry,
                            invertPriceToVolatility(price_quote));
                        break;
                }
            }

            return vol_points;
        }

    private:
        double invertPriceToVolatility(const OptionQuote& quote) {
            // Uses Brent algorithm for inversion
            auto objective = [&](double vol) -> double {
                double theoretical_price = calculateOptionPrice(quote, vol);
                return theoretical_price - quote.price;
            };

            return brent_solver_.solve(objective, vol_min_, vol_max_, tolerance_);
        }
    };
}
```
*This C++ implementation in Our project handles different quote types with appropriate conversion to implied volatilities.*

### Target Mid Volatility Calculation

The target implied volatilities are the **mid volatilities** calculated by:
- **Mid quote inversion** (average of bid/ask quotes), or
- **Average of bid/ask implied volatilities**

### Brent Inversion Algorithm

Inversion is performed using the Brent root-finding algorithm to find the zero of the function:

$$f(\sigma) = Q - P(\sigma)$$

Where:
- $Q$ is the option quote
- $P(\sigma)$ is the option price as a function of volatility

The Brent algorithm provides robust and efficient convergence, with detailed implementation available in the references. Failed inversions are handled by adjusting search bounds and retrying with modified parameters.

### Option Price Calculation and Parameters

To calculate the option price for a given volatility value, we specify through quote inversion instructions:
- **Pricing engine parameters**
- **Exchange code** including exchange calendar, premium payment date, interest rate convention
- **Exercise type** for American options (e.g., German exercise)
- **Expiration rule**

### Vega Calculation and Weighting

Once the Brent algorithm is completed and the root returned for the f(vol) function, the **option Vega** is approximated using finite differences with a 1 basis point bump. These Vega values are used later for quote weighting during fitting.

```cpp
// Our project implementation for Vega calculation using finite differences
namespace xsigma {
    class VegaCalculator {
    public:
        double calculateVega(
            const OptionContract& contract,
            double base_volatility,
            double bump_size = 0.0001) {  // 1 bp

            // Price with base volatility
            double price_base = pricing_engine_.price(contract, base_volatility);

            // Price with bumped volatility
            double price_bumped = pricing_engine_.price(contract, base_volatility + bump_size);

            // Vega = finite difference derivative
            return (price_bumped - price_base) / bump_size;
        }

        // Vectorized calculation for efficiency
        std::vector<double> calculateVegaVector(
            const std::vector<OptionContract>& contracts,
            const std::vector<double>& volatilities,
            double bump_size = 0.0001) {

            std::vector<double> vegas;
            vegas.reserve(contracts.size());

            for (size_t i = 0; i < contracts.size(); ++i) {
                vegas.push_back(calculateVega(contracts[i], volatilities[i], bump_size));
            }

            return vegas;
        }

    private:
        OptionPricingEngine pricing_engine_;
    };
}
```
*This C++ implementation in Our project calculates Vega using finite differences for quote weighting in ASV fitting.*

### Weight Adjustment by Standard Deviation

Quotes also have an optional **standard deviation** input. These are used as weight adjustment factors during fitting. Their usage is described in the quote filtering section.

## ASV Volatility Surface Fitting

### Process Overview

This section describes the ASV volatility surface parameter fitting process, which employs advanced optimization techniques to ensure robust and accurate results.

### Input Data

The input data for the process includes:
- **Initial volatility surface**
- **Forward curve** with previous or newly fitted repo curve
- **Pricing date**
- **Liquid maturity dates**
- **Implied volatilities** (bid, ask and mid)
- **Corresponding strikes and weights**
- **Fitting instructions** specifying fitting procedure details
- **Optional quality instructions**

### Phases Principales du Processus

#### Phase 1: Preprocessing
- **Quote filtering** : Removes outliers and invalid quotes
- **Initial configuration** : Re-anchors initial volatility surface and configures weights
- **Local fitting by liquid maturity** : Fits parameters per maturity
- **Interpolation for sparse maturities** : Interpolates parameter values

#### Phase 2: Main Fitting
- **Optional term structure fitting** : Fits TS curves for each ASV parameter
- **Optional global fitting** : Refines TS curves through constrained minimization
- **Quality-based smoothing** : Applies kernel smoothing to ASV parameters
- **Parameter interpolation/extrapolation** : Handles additional non-liquid maturities

#### Phase 3: Post-processing
- **Optional volatility grid generation** : Creates grids for downstream systems
- **Calendar volatility conversion** : Handles calendar-specific adjustments
- **Optional overlay volatility surface generation** : Creates additional surfaces
- **Optional post-fitting checks** : Performs quality assurance and validation

```cpp
// Our project implementation of complete ASV fitting process
namespace xsigma {
    class ASVSurfaceFitter {
    public:
        struct FittingPhases {
            bool enable_preprocessing = true;
            bool enable_quote_filtering = true;
            bool enable_local_fitting = true;
            bool enable_term_structure_fitting = false;
            bool enable_global_fitting = false;
            bool enable_postprocessing = true;
        };

        ASVSurface fitSurface(
            const std::vector<ImpliedVolPoint>& vol_points,
            const ASVSurface& initial_surface,
            const FittingPhases& phases) {

            ASVSurface result = initial_surface;

            // Phase 1: Preprocessing
            if (phases.enable_preprocessing) {
                auto filtered_points = preprocessData(vol_points, phases);
                result = performLocalFitting(filtered_points, result);
            }

            // Phase 2: Ajustement principal
            if (phases.enable_term_structure_fitting) {
                result = performTermStructureFitting(result);
            }

            if (phases.enable_global_fitting) {
                result = performGlobalFitting(result);
            }

            // Phase 3: Post-processing
            if (phases.enable_postprocessing) {
                result = performPostProcessing(result);
            }

            return result;
        }

    private:
        std::vector<ImpliedVolPoint> preprocessData(
            const std::vector<ImpliedVolPoint>& vol_points,
            const FittingPhases& phases);
        ASVSurface performLocalFitting(
            const std::vector<ImpliedVolPoint>& vol_points,
            const ASVSurface& initial_surface);
        ASVSurface performTermStructureFitting(const ASVSurface& surface);
        ASVSurface performGlobalFitting(const ASVSurface& surface);
        ASVSurface performPostProcessing(const ASVSurface& surface);
    };
}
```
*This C++ implementation in Our project structures the complete ASV surface fitting process in configurable phases.*
