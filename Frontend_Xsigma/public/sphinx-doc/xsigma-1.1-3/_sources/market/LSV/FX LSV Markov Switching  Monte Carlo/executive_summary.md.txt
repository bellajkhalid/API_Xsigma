# Executive Summary

## Overview

Le modèle **FX LSV Markov Switching Monte Carlo** représente une extension spécialisée du modèle LSV Markov Switching pour les **marchés de change (FX)**, combinant volatilité locale, volatilité stochastique et switching de régimes avec des caractéristiques spécifiques au FX.

```cpp
// Implémentation Our project du modèle FX LSV Markov Switching Monte Carlo
namespace xsigma {
    // Classe principale pour le modèle FX LSV Markov Switching Monte Carlo
    class FXLSVMarkovSwitchingMC {
    public:
        // Énumération des paires de devises supportées
        enum class CurrencyPair {
            EURUSD,                       // EUR/USD
            GBPUSD,                       // GBP/USD
            USDJPY,                       // USD/JPY
            USDCHF,                       // USD/CHF
            AUDUSD,                       // AUD/USD
            USDCAD,                       // USD/CAD
            NZDUSD,                       // NZD/USD
            EURGBP,                       // EUR/GBP
            EURJPY,                       // EUR/JPY
            GBPJPY                        // GBP/JPY
        };
        
        // Structure pour les paramètres spécifiques FX
        struct FXModelParameters {
            // Paramètres de base LSV MS
            double vol_of_vol;                            // ν (vol of vol)
            double mean_reversion_speed;                  // κ (mean reversion)
            double long_term_variance;                    // θ (long term variance)
            double correlation;                           // ρ (correlation spot-vol)
            
            // Paramètres Markov Switching
            int number_of_states;                         // Nombre d'états
            std::vector<double> state_volatilities;      // Volatilités par état
            std::vector<std::vector<double>> transition_rates; // Taux de transition
            
            // Paramètres spécifiques FX
            CurrencyPair currency_pair;                   // Paire de devises
            double domestic_rate;                         // Taux domestique
            double foreign_rate;                          // Taux étranger
            double spot_fx_rate;                          // Taux de change spot
            
            // Caractéristiques FX
            std::string market_convention;                // Convention de marché
            std::string quotation_style;                 // Style de cotation
            double pip_size;                              // Taille du pip
            int decimal_places;                           // Nombre de décimales
            
            // Paramètres de volatilité FX
            bool use_fx_smile;                            // Utilisation du smile FX
            std::vector<double> fx_smile_strikes;         // Strikes du smile FX
            std::vector<double> fx_smile_vols;            // Volatilités du smile FX
            
            // Paramètres de corrélation FX
            std::map<std::string, double> cross_correlations; // Corrélations croisées
            bool use_triangular_arbitrage;                // Arbitrage triangulaire
            
            // Paramètres Monte Carlo
            int monte_carlo_paths;                        // Nombre de chemins MC
            int time_steps_per_year;                      // Pas de temps par année
            bool use_antithetic_variates;                 // Variables antithétiques
            bool use_control_variates;                    // Variables de contrôle
            std::string random_number_generator;          // Générateur de nombres aléatoires
        };
        
        // Structure pour les résultats de pricing FX
        struct FXPricingResult {
            double present_value_domestic;                // Valeur présente en devise domestique
            double present_value_foreign;                 // Valeur présente en devise étrangère
            double present_value_usd;                     // Valeur présente en USD
            
            // Greeks FX
            double delta_spot;                            // Delta par rapport au spot FX
            double gamma_spot;                            // Gamma par rapport au spot FX
            double vega_total;                            // Vega total
            double theta;                                 // Theta
            double rho_domestic;                          // Rho taux domestique
            double rho_foreign;                           // Rho taux étranger
            
            // Greeks spécifiques FX
            double delta_domestic_rate;                   // Delta taux domestique
            double delta_foreign_rate;                    // Delta taux étranger
            double cross_gamma;                           // Gamma croisé
            double correlation_sensitivity;               // Sensibilité corrélation
            
            // Métriques de qualité Monte Carlo
            double standard_error;                        // Erreur standard MC
            double confidence_interval_95;               // Intervalle de confiance 95%
            int paths_used;                               // Chemins utilisés
            double convergence_indicator;                 // Indicateur de convergence
        };
        
        // Constructeur
        FXLSVMarkovSwitchingMC(const FXModelParameters& params)
            : params_(params) {
            
            // Validation des paramètres FX
            validate_fx_parameters();
            
            // Initialisation des générateurs de nombres aléatoires
            initialize_random_generators();
            
            // Configuration des corrélations FX
            setup_fx_correlations();
            
            // Préparation de la calibration FX
            prepare_fx_calibration();
        }
        
        // Pricing d'une option FX via Monte Carlo
        FXPricingResult price_fx_option(
            const FXOptionSpecification& option) const {
            
            FXPricingResult result;
            
            try {
                // Validation de l'option FX
                validate_fx_option(option);
                
                // Génération des chemins Monte Carlo FX
                auto fx_paths = generate_fx_monte_carlo_paths(option);
                
                // Calcul des payoffs FX
                auto payoffs = calculate_fx_payoffs(fx_paths, option);
                
                // Actualisation avec taux FX appropriés
                result.present_value_domestic = discount_fx_payoffs(payoffs, 
                                                                   params_.domestic_rate, 
                                                                   option.maturity);
                
                result.present_value_foreign = convert_to_foreign_currency(
                    result.present_value_domestic, params_.spot_fx_rate);
                
                result.present_value_usd = convert_to_usd(
                    result.present_value_domestic, params_.currency_pair);
                
                // Calcul des Greeks FX
                result.delta_spot = calculate_fx_delta(fx_paths, option);
                result.gamma_spot = calculate_fx_gamma(fx_paths, option);
                result.vega_total = calculate_fx_vega(fx_paths, option);
                result.theta = calculate_fx_theta(fx_paths, option);
                result.rho_domestic = calculate_fx_rho_domestic(fx_paths, option);
                result.rho_foreign = calculate_fx_rho_foreign(fx_paths, option);
                
                // Greeks spécifiques FX
                result.delta_domestic_rate = calculate_fx_delta_domestic_rate(fx_paths, option);
                result.delta_foreign_rate = calculate_fx_delta_foreign_rate(fx_paths, option);
                result.cross_gamma = calculate_fx_cross_gamma(fx_paths, option);
                result.correlation_sensitivity = calculate_fx_correlation_sensitivity(fx_paths, option);
                
                // Métriques de qualité
                result.standard_error = calculate_monte_carlo_error(payoffs);
                result.confidence_interval_95 = 1.96 * result.standard_error;
                result.paths_used = params_.monte_carlo_paths;
                result.convergence_indicator = assess_convergence(payoffs);
                
            } catch (const std::exception& e) {
                XSIGMA_LOG_ERROR("Erreur lors du pricing FX: " + std::string(e.what()));
                throw;
            }
            
            return result;
        }
        
        // Structure pour la spécification d'option FX
        struct FXOptionSpecification {
            std::string option_type;                      // "CALL", "PUT", "DIGITAL", etc.
            double strike;                                // Strike en termes de taux de change
            double maturity;                              // Maturité en années
            double notional_domestic;                     // Notionnel en devise domestique
            double notional_foreign;                      // Notionnel en devise étrangère
            
            // Caractéristiques FX spécifiques
            std::string settlement_currency;              // Devise de règlement
            std::string barrier_type;                     // Type de barrière si applicable
            std::vector<double> barrier_levels;           // Niveaux de barrière
            std::vector<double> monitoring_dates;         // Dates de monitoring
            
            // Paramètres de payoff FX
            bool is_quanto;                               // Option quanto
            std::string quanto_currency;                  // Devise quanto
            double quanto_correlation;                    // Corrélation quanto
            
            // Paramètres de règlement
            int settlement_lag;                           // Délai de règlement (jours)
            std::string settlement_convention;            // Convention de règlement
        };
        
        // Génération de chemins Monte Carlo FX
        struct FXMonteCarloPath {
            std::vector<double> fx_rates;                 // Taux de change
            std::vector<double> variances;                // Variances
            std::vector<int> volatility_states;           // États de volatilité
            std::vector<double> domestic_rates;           // Taux domestiques
            std::vector<double> foreign_rates;            // Taux étrangers
            std::vector<double> times;                    // Grille temporelle
        };
        
        std::vector<FXMonteCarloPath> generate_fx_monte_carlo_paths(
            const FXOptionSpecification& option) const {
            
            std::vector<FXMonteCarloPath> paths;
            paths.reserve(params_.monte_carlo_paths);
            
            // Configuration de la grille temporelle
            int n_steps = static_cast<int>(option.maturity * params_.time_steps_per_year);
            double dt = option.maturity / n_steps;
            
            // Générateur de nombres aléatoires corrélés
            FXCorrelatedRandomGenerator rng(params_.correlation, 12345);
            
            for (int path = 0; path < params_.monte_carlo_paths; ++path) {
                FXMonteCarloPath mc_path;
                mc_path.fx_rates.reserve(n_steps + 1);
                mc_path.variances.reserve(n_steps + 1);
                mc_path.volatility_states.reserve(n_steps + 1);
                mc_path.times.reserve(n_steps + 1);
                
                // Conditions initiales
                mc_path.fx_rates.push_back(params_.spot_fx_rate);
                mc_path.variances.push_back(params_.long_term_variance);
                mc_path.volatility_states.push_back(0); // État initial
                mc_path.times.push_back(0.0);
                
                // Simulation du chemin
                for (int step = 0; step < n_steps; ++step) {
                    double current_time = step * dt;
                    double current_fx = mc_path.fx_rates.back();
                    double current_var = mc_path.variances.back();
                    int current_state = mc_path.volatility_states.back();
                    
                    // Génération des innovations aléatoires corrélées
                    auto [dW_fx, dW_var] = rng.generate_correlated_normals(dt);
                    
                    // Évolution du taux de change (modèle Garman-Kohlhagen modifié)
                    double local_vol = interpolate_fx_local_volatility(current_fx, current_time);
                    double state_vol = params_.state_volatilities[current_state];
                    double effective_vol = local_vol * std::sqrt(current_var) * state_vol;
                    
                    double fx_drift = (params_.domestic_rate - params_.foreign_rate) * dt;
                    double fx_diffusion = effective_vol * dW_fx;
                    
                    double new_fx = current_fx * std::exp(fx_drift - 0.5 * effective_vol * effective_vol * dt + fx_diffusion);
                    
                    // Évolution de la variance (processus CIR)
                    double var_drift = params_.mean_reversion_speed * (params_.long_term_variance - current_var) * dt;
                    double var_diffusion = params_.vol_of_vol * std::sqrt(std::max(current_var, 0.0)) * dW_var;
                    double new_var = std::max(current_var + var_drift + var_diffusion, 0.0);
                    
                    // Évolution de l'état de volatilité (chaîne de Markov)
                    int new_state = evolve_volatility_state(current_state, dt);
                    
                    // Stockage des nouvelles valeurs
                    mc_path.fx_rates.push_back(new_fx);
                    mc_path.variances.push_back(new_var);
                    mc_path.volatility_states.push_back(new_state);
                    mc_path.times.push_back(current_time + dt);
                }
                
                paths.push_back(std::move(mc_path));
            }
            
            return paths;
        }
        
        // Générateur de nombres aléatoires corrélés pour FX
        class FXCorrelatedRandomGenerator {
        public:
            FXCorrelatedRandomGenerator(double correlation, int seed)
                : correlation_(correlation), rng_(seed) {
                
                if (std::abs(correlation) >= 1.0) {
                    XSIGMA_THROW("Corrélation FX doit être dans ]-1, 1[");
                }
            }
            
            std::pair<double, double> generate_correlated_normals(double dt) {
                std::normal_distribution<> normal(0.0, std::sqrt(dt));
                
                double z1 = normal(rng_);
                double z2 = normal(rng_);
                
                double w_fx = z1;
                double w_var = correlation_ * z1 + std::sqrt(1.0 - correlation_ * correlation_) * z2;
                
                return {w_fx, w_var};
            }
            
        private:
            double correlation_;
            mutable std::mt19937 rng_;
        };
        
    private:
        FXModelParameters params_;
        
        void validate_fx_parameters() const {
            // Validation spécifique aux paramètres FX
            if (params_.domestic_rate < -0.1 || params_.domestic_rate > 0.2) {
                XSIGMA_THROW("Taux domestique hors limites raisonnables");
            }
            
            if (params_.foreign_rate < -0.1 || params_.foreign_rate > 0.2) {
                XSIGMA_THROW("Taux étranger hors limites raisonnables");
            }
            
            if (params_.spot_fx_rate <= 0.0) {
                XSIGMA_THROW("Taux de change spot doit être positif");
            }
            
            // Validation de la paire de devises
            validate_currency_pair();
        }
        
        void validate_currency_pair() const {
            // Validation des conventions de marché pour la paire
            switch (params_.currency_pair) {
                case CurrencyPair::EURUSD:
                    if (params_.pip_size != 0.0001) {
                        XSIGMA_LOG_WARNING("Taille de pip non standard pour EUR/USD");
                    }
                    break;
                case CurrencyPair::USDJPY:
                    if (params_.pip_size != 0.01) {
                        XSIGMA_LOG_WARNING("Taille de pip non standard pour USD/JPY");
                    }
                    break;
                // Autres paires...
                default:
                    break;
            }
        }
        
        void initialize_random_generators() {
            // Initialisation des générateurs selon le type spécifié
            XSIGMA_LOG_INFO("Initialisation des générateurs aléatoires FX: " + 
                           params_.random_number_generator);
        }
        
        void setup_fx_correlations() {
            // Configuration des corrélations FX spécifiques
            XSIGMA_LOG_INFO("Configuration des corrélations FX pour " + 
                           currency_pair_to_string(params_.currency_pair));
        }
        
        void prepare_fx_calibration() {
            // Préparation de la calibration spécifique FX
            XSIGMA_LOG_INFO("Préparation de la calibration FX");
        }
        
        std::string currency_pair_to_string(CurrencyPair pair) const {
            switch (pair) {
                case CurrencyPair::EURUSD: return "EUR/USD";
                case CurrencyPair::GBPUSD: return "GBP/USD";
                case CurrencyPair::USDJPY: return "USD/JPY";
                case CurrencyPair::USDCHF: return "USD/CHF";
                case CurrencyPair::AUDUSD: return "AUD/USD";
                case CurrencyPair::USDCAD: return "USD/CAD";
                case CurrencyPair::NZDUSD: return "NZD/USD";
                case CurrencyPair::EURGBP: return "EUR/GBP";
                case CurrencyPair::EURJPY: return "EUR/JPY";
                case CurrencyPair::GBPJPY: return "GBP/JPY";
                default: return "UNKNOWN";
            }
        }
        
        // Méthodes utilitaires (placeholders)
        void validate_fx_option(const FXOptionSpecification& option) const {
            // Validation spécifique aux options FX
        }
        
        double interpolate_fx_local_volatility(double fx_rate, double time) const {
            // Interpolation de la volatilité locale FX
            return 0.15; // Placeholder
        }
        
        int evolve_volatility_state(int current_state, double dt) const {
            // Évolution de l'état de volatilité
            return current_state; // Placeholder
        }
        
        std::vector<double> calculate_fx_payoffs(
            const std::vector<FXMonteCarloPath>& paths,
            const FXOptionSpecification& option) const {
            // Calcul des payoffs FX
            return std::vector<double>(paths.size(), 0.0); // Placeholder
        }
        
        double discount_fx_payoffs(const std::vector<double>& payoffs,
                                  double rate, double maturity) const {
            // Actualisation des payoffs
            return 0.0; // Placeholder
        }
        
        double convert_to_foreign_currency(double domestic_value, double fx_rate) const {
            return domestic_value / fx_rate;
        }
        
        double convert_to_usd(double value, CurrencyPair pair) const {
            // Conversion vers USD selon la paire
            return value; // Placeholder
        }
        
        // Méthodes de calcul des Greeks (placeholders)
        double calculate_fx_delta(const std::vector<FXMonteCarloPath>& paths,
                                 const FXOptionSpecification& option) const {
            return 0.0; // Placeholder
        }
        
        double calculate_fx_gamma(const std::vector<FXMonteCarloPath>& paths,
                                 const FXOptionSpecification& option) const {
            return 0.0; // Placeholder
        }
        
        double calculate_fx_vega(const std::vector<FXMonteCarloPath>& paths,
                                const FXOptionSpecification& option) const {
            return 0.0; // Placeholder
        }
        
        double calculate_fx_theta(const std::vector<FXMonteCarloPath>& paths,
                                 const FXOptionSpecification& option) const {
            return 0.0; // Placeholder
        }
        
        double calculate_fx_rho_domestic(const std::vector<FXMonteCarloPath>& paths,
                                        const FXOptionSpecification& option) const {
            return 0.0; // Placeholder
        }
        
        double calculate_fx_rho_foreign(const std::vector<FXMonteCarloPath>& paths,
                                       const FXOptionSpecification& option) const {
            return 0.0; // Placeholder
        }
        
        double calculate_fx_delta_domestic_rate(const std::vector<FXMonteCarloPath>& paths,
                                               const FXOptionSpecification& option) const {
            return 0.0; // Placeholder
        }
        
        double calculate_fx_delta_foreign_rate(const std::vector<FXMonteCarloPath>& paths,
                                              const FXOptionSpecification& option) const {
            return 0.0; // Placeholder
        }
        
        double calculate_fx_cross_gamma(const std::vector<FXMonteCarloPath>& paths,
                                       const FXOptionSpecification& option) const {
            return 0.0; // Placeholder
        }
        
        double calculate_fx_correlation_sensitivity(const std::vector<FXMonteCarloPath>& paths,
                                                   const FXOptionSpecification& option) const {
            return 0.0; // Placeholder
        }
        
        double calculate_monte_carlo_error(const std::vector<double>& payoffs) const {
            if (payoffs.size() <= 1) return 0.0;
            
            double mean = std::accumulate(payoffs.begin(), payoffs.end(), 0.0) / payoffs.size();
            double variance = 0.0;
            
            for (double payoff : payoffs) {
                double diff = payoff - mean;
                variance += diff * diff;
            }
            
            variance /= (payoffs.size() - 1);
            return std::sqrt(variance / payoffs.size());
        }
        
        double assess_convergence(const std::vector<double>& payoffs) const {
            // Évaluation de la convergence Monte Carlo
            return 0.95; // Placeholder
        }
    };
}
```
*Cette implémentation C++ dans Our project fournit un framework complet pour le modèle FX LSV Markov Switching Monte Carlo avec gestion spécialisée des devises, corrélations FX et Greeks spécifiques au change.*

## Key Model Features

### FX-Specific Enhancements

Le modèle **FX LSV Markov Switching Monte Carlo** étend le modèle LSV MS standard avec des caractéristiques spécifiques aux **marchés de change** :

#### Garman-Kohlhagen Framework
- **Dual Interest Rates** : Taux domestique et étranger
- **FX Forward Drift** : $(r_d - r_f)$ dans la dynamique
- **Currency Conventions** : Respect des conventions de marché FX
- **Settlement Features** : Gestion des délais de règlement FX

#### Multi-Currency Support
- **Major Pairs** : EUR/USD, GBP/USD, USD/JPY, etc.
- **Cross Rates** : EUR/GBP, EUR/JPY, GBP/JPY
- **Exotic Pairs** : Paires avec devises émergentes
- **Triangular Arbitrage** : Cohérence des taux croisés

#### FX-Specific Greeks
- **Delta FX** : Sensibilité au taux de change spot
- **Rho Domestic/Foreign** : Sensibilités aux taux d'intérêt
- **Cross Gamma** : Convexité croisée taux-spot
- **Correlation Sensitivity** : Impact des corrélations FX

### Advanced FX Features

#### Quanto Options
- **Quanto Mechanism** : Élimination du risque de change
- **Quanto Correlation** : Corrélation spot-taux de change
- **Multi-Currency Payoffs** : Payoffs dans différentes devises

#### FX Smile Integration
- **Market Smile** : Intégration du smile de volatilité FX
- **Strike-Dependent Vol** : Volatilité dépendante du strike
- **Term Structure** : Structure de terme de volatilité FX

### Performance Characteristics

#### Computational Efficiency
- **FX-Optimized Paths** : Génération optimisée pour FX
- **Correlation Handling** : Gestion efficace des corrélations
- **Multi-Currency Pricing** : Pricing simultané multi-devises
- **Memory Management** : Optimisation pour gros portfolios FX

#### Accuracy Features
- **FX Conventions** : Respect strict des conventions de marché
- **Precision Control** : Contrôle de précision adapté au FX
- **Validation Framework** : Tests contre pricers FX de référence

### Market Data Integration

#### FX Market Data
- **Spot Rates** : Taux de change en temps réel
- **Forward Points** : Points de terme FX
- **Volatility Surfaces** : Surfaces de volatilité FX
- **Interest Rate Curves** : Courbes de taux multi-devises

#### Calibration Framework
- **FX Smile Calibration** : Calibration sur smile FX
- **Cross-Currency Consistency** : Cohérence entre paires
- **Real-Time Updates** : Mise à jour temps réel des paramètres

Le modèle FX LSV Markov Switching Monte Carlo dans Our project offre une solution complète et spécialisée pour le pricing d'options FX avec volatilité locale, stochastique et switching de régimes, optimisée pour les spécificités des marchés de change.
