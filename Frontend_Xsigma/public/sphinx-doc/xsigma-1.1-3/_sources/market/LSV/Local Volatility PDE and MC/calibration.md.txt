# Calibration

## Overview

Cette section décrit les procédures de calibration du modèle **Local Volatility PDE and MC**, incluant la calibration de la surface de volatilité locale via l'équation de Dupire et l'optimisation des paramètres numériques pour les méthodes hybrides.

## Local Volatility Surface Calibration

### Market Data Processing

#### Option Price Data Validation
```cpp
// Implémentation Our project de la calibration Local Volatility
namespace xsigma::local_vol_calibration {
    
    class LocalVolatilityCalibrator {
    public:
        struct MarketOptionData {
            std::vector<double> strikes;           // Strikes des options
            std::vector<double> maturities;        // Maturités
            std::vector<std::vector<double>> call_prices;  // Prix des calls
            std::vector<std::vector<double>> put_prices;   // Prix des puts
            std::vector<std::vector<double>> bid_ask_spreads; // Spreads bid-ask
            std::vector<std::vector<double>> volumes;      // Volumes de trading
            double spot_price;                     // Prix spot
            double risk_free_rate;                 // Taux sans risque
            double dividend_yield;                 // Rendement dividende
            std::string data_timestamp;            // Timestamp des données
        };
        
        struct CalibrationParameters {
            double smoothing_factor;               // Facteur de lissage
            int max_iterations;                    // Itérations maximales
            double convergence_tolerance;          // Tolérance de convergence
            bool enforce_no_arbitrage;             // Forcer l'absence d'arbitrage
            bool use_bid_ask_weighting;            // Pondération bid-ask
            std::string interpolation_method;      // Méthode d'interpolation
            double regularization_parameter;       // Paramètre de régularisation
        };
        
        // Validation et nettoyage des données de marché
        MarketOptionData validate_and_clean_market_data(const MarketOptionData& raw_data) {
            MarketOptionData cleaned_data = raw_data;
            
            // Validation de cohérence put-call parity
            validate_put_call_parity(cleaned_data);
            
            // Suppression des prix aberrants
            remove_outlier_prices(cleaned_data);
            
            // Validation d'absence d'arbitrage
            validate_no_arbitrage_conditions(cleaned_data);
            
            // Interpolation des prix manquants
            interpolate_missing_prices(cleaned_data);
            
            return cleaned_data;
        }
        
        // Calibration de la surface de volatilité locale
        LocalVolatilitySurface calibrate_local_volatility_surface(
            const MarketOptionData& market_data,
            const CalibrationParameters& calib_params) {
            
            LocalVolatilitySurface surface;
            
            try {
                // Initialisation de la surface
                initialize_surface_grid(surface, market_data);
                
                // Calcul des volatilités implicites initiales
                auto implied_vol_surface = calculate_implied_volatility_surface(market_data);
                
                // Application de l'équation de Dupire
                surface = apply_dupire_calibration(market_data, implied_vol_surface, calib_params);
                
                // Lissage et régularisation
                surface = apply_smoothing_and_regularization(surface, calib_params);
                
                // Validation finale
                validate_calibrated_surface(surface, market_data);
                
                XSIGMA_LOG_INFO("Calibration de volatilité locale terminée avec succès");
                
            } catch (const std::exception& e) {
                XSIGMA_LOG_ERROR("Erreur lors de la calibration: " + std::string(e.what()));
                throw;
            }
            
            return surface;
        }
        
    private:
        void validate_put_call_parity(MarketOptionData& data) {
            for (size_t i = 0; i < data.strikes.size(); ++i) {
                for (size_t j = 0; j < data.maturities.size(); ++j) {
                    double K = data.strikes[i];
                    double T = data.maturities[j];
                    double S = data.spot_price;
                    double r = data.risk_free_rate;
                    double q = data.dividend_yield;
                    
                    double call_price = data.call_prices[i][j];
                    double put_price = data.put_prices[i][j];
                    
                    // Put-call parity: C - P = S*e^(-qT) - K*e^(-rT)
                    double theoretical_diff = S * std::exp(-q * T) - K * std::exp(-r * T);
                    double actual_diff = call_price - put_price;
                    double parity_error = std::abs(actual_diff - theoretical_diff);
                    
                    if (parity_error > 0.01 * S) { // Tolérance de 1% du spot
                        XSIGMA_LOG_WARNING("Violation put-call parity détectée: K=" + 
                                          std::to_string(K) + ", T=" + std::to_string(T));
                        
                        // Correction basée sur la moyenne
                        double avg_price = (call_price + put_price + theoretical_diff) / 2.0;
                        data.call_prices[i][j] = avg_price;
                        data.put_prices[i][j] = avg_price - theoretical_diff;
                    }
                }
            }
        }
        
        void remove_outlier_prices(MarketOptionData& data) {
            // Détection et suppression des prix aberrants
            for (size_t i = 0; i < data.strikes.size(); ++i) {
                for (size_t j = 0; j < data.maturities.size(); ++j) {
                    
                    // Vérification de la valeur intrinsèque
                    double K = data.strikes[i];
                    double S = data.spot_price;
                    double intrinsic_call = std::max(S - K, 0.0);
                    double intrinsic_put = std::max(K - S, 0.0);
                    
                    // Les prix ne peuvent pas être inférieurs à la valeur intrinsèque
                    if (data.call_prices[i][j] < intrinsic_call) {
                        XSIGMA_LOG_WARNING("Prix call inférieur à la valeur intrinsèque corrigé");
                        data.call_prices[i][j] = intrinsic_call + 0.001; // Petite marge
                    }
                    
                    if (data.put_prices[i][j] < intrinsic_put) {
                        XSIGMA_LOG_WARNING("Prix put inférieur à la valeur intrinsèque corrigé");
                        data.put_prices[i][j] = intrinsic_put + 0.001;
                    }
                    
                    // Vérification de cohérence avec les prix voisins
                    if (is_price_outlier(data, i, j)) {
                        interpolate_outlier_price(data, i, j);
                    }
                }
            }
        }
        
        void validate_no_arbitrage_conditions(const MarketOptionData& data) {
            // Validation des conditions d'absence d'arbitrage
            
            // 1. Monotonie en strike pour calls (décroissante) et puts (croissante)
            for (size_t j = 0; j < data.maturities.size(); ++j) {
                for (size_t i = 1; i < data.strikes.size(); ++i) {
                    
                    // Calls doivent être décroissants en strike
                    if (data.call_prices[i][j] > data.call_prices[i-1][j]) {
                        XSIGMA_LOG_WARNING("Violation monotonie calls en strike détectée");
                    }
                    
                    // Puts doivent être croissants en strike
                    if (data.put_prices[i][j] < data.put_prices[i-1][j]) {
                        XSIGMA_LOG_WARNING("Violation monotonie puts en strike détectée");
                    }
                }
            }
            
            // 2. Convexité en strike
            for (size_t j = 0; j < data.maturities.size(); ++j) {
                for (size_t i = 1; i < data.strikes.size() - 1; ++i) {
                    double K_minus = data.strikes[i-1];
                    double K = data.strikes[i];
                    double K_plus = data.strikes[i+1];
                    
                    double C_minus = data.call_prices[i-1][j];
                    double C = data.call_prices[i][j];
                    double C_plus = data.call_prices[i+1][j];
                    
                    // Test de convexité approximatif
                    double expected_price = C_minus + (C_plus - C_minus) * (K - K_minus) / (K_plus - K_minus);
                    if (C < expected_price - 0.01) {
                        XSIGMA_LOG_WARNING("Violation convexité détectée en K=" + std::to_string(K));
                    }
                }
            }
        }
        
        void interpolate_missing_prices(MarketOptionData& data) {
            // Interpolation des prix manquants ou aberrants
            for (size_t i = 0; i < data.strikes.size(); ++i) {
                for (size_t j = 0; j < data.maturities.size(); ++j) {
                    if (data.call_prices[i][j] <= 0 || data.put_prices[i][j] <= 0) {
                        interpolate_price_at_point(data, i, j);
                    }
                }
            }
        }
        
        struct ImpliedVolatilitySurface {
            std::vector<double> strikes;
            std::vector<double> maturities;
            std::vector<std::vector<double>> implied_vols;
        };
        
        ImpliedVolatilitySurface calculate_implied_volatility_surface(const MarketOptionData& data) {
            ImpliedVolatilitySurface iv_surface;
            iv_surface.strikes = data.strikes;
            iv_surface.maturities = data.maturities;
            iv_surface.implied_vols.resize(data.strikes.size(), 
                                          std::vector<double>(data.maturities.size()));
            
            // Calcul des volatilités implicites via Newton-Raphson
            for (size_t i = 0; i < data.strikes.size(); ++i) {
                for (size_t j = 0; j < data.maturities.size(); ++j) {
                    double market_price = data.call_prices[i][j];
                    double K = data.strikes[i];
                    double T = data.maturities[j];
                    
                    iv_surface.implied_vols[i][j] = calculate_implied_volatility_newton_raphson(
                        market_price, data.spot_price, K, T, data.risk_free_rate, data.dividend_yield);
                }
            }
            
            return iv_surface;
        }
        
        LocalVolatilitySurface apply_dupire_calibration(
            const MarketOptionData& market_data,
            const ImpliedVolatilitySurface& iv_surface,
            const CalibrationParameters& params) {
            
            LocalVolatilitySurface lv_surface;
            lv_surface.strikes = market_data.strikes;
            lv_surface.maturities = market_data.maturities;
            lv_surface.spot_price = market_data.spot_price;
            lv_surface.risk_free_rate = market_data.risk_free_rate;
            lv_surface.dividend_yield = market_data.dividend_yield;
            
            // Calcul des dérivées partielles des prix d'options
            auto price_derivatives = calculate_price_derivatives_from_market(market_data);
            
            // Application de la formule de Dupire
            lv_surface.local_vol_matrix = apply_dupire_formula_with_regularization(
                price_derivatives, market_data, params);
            
            return lv_surface;
        }
        
        LocalVolatilitySurface apply_smoothing_and_regularization(
            const LocalVolatilitySurface& raw_surface,
            const CalibrationParameters& params) {
            
            LocalVolatilitySurface smoothed_surface = raw_surface;
            
            // Lissage via splines bicubiques
            if (params.smoothing_factor > 0) {
                smoothed_surface.local_vol_matrix = apply_bicubic_spline_smoothing(
                    raw_surface.local_vol_matrix, params.smoothing_factor);
            }
            
            // Régularisation pour éviter les valeurs extrêmes
            if (params.regularization_parameter > 0) {
                smoothed_surface.local_vol_matrix = apply_tikhonov_regularization(
                    smoothed_surface.local_vol_matrix, params.regularization_parameter);
            }
            
            // Application des contraintes d'absence d'arbitrage
            if (params.enforce_no_arbitrage) {
                smoothed_surface = enforce_no_arbitrage_constraints(smoothed_surface);
            }
            
            return smoothed_surface;
        }
        
        void validate_calibrated_surface(const LocalVolatilitySurface& surface,
                                        const MarketOptionData& market_data) {
            
            // Validation par re-pricing des options de marché
            double max_pricing_error = 0.0;
            double avg_pricing_error = 0.0;
            int num_options = 0;
            
            for (size_t i = 0; i < market_data.strikes.size(); ++i) {
                for (size_t j = 0; j < market_data.maturities.size(); ++j) {
                    
                    // Re-pricing avec la surface calibrée
                    double theoretical_price = price_option_with_local_vol_surface(
                        surface, market_data.strikes[i], market_data.maturities[j], "CALL");
                    
                    double market_price = market_data.call_prices[i][j];
                    double pricing_error = std::abs(theoretical_price - market_price) / market_price;
                    
                    max_pricing_error = std::max(max_pricing_error, pricing_error);
                    avg_pricing_error += pricing_error;
                    num_options++;
                }
            }
            
            avg_pricing_error /= num_options;
            
            XSIGMA_LOG_INFO("Validation calibration - Erreur max: " + std::to_string(max_pricing_error * 100) + 
                           "%, Erreur moyenne: " + std::to_string(avg_pricing_error * 100) + "%");
            
            if (max_pricing_error > 0.05) { // 5%
                XSIGMA_LOG_WARNING("Erreur de calibration élevée détectée");
            }
        }
        
        // Méthodes utilitaires (placeholders pour implémentations complètes)
        void initialize_surface_grid(LocalVolatilitySurface& surface, const MarketOptionData& data) {
            surface.strikes = data.strikes;
            surface.maturities = data.maturities;
            surface.spot_price = data.spot_price;
            surface.risk_free_rate = data.risk_free_rate;
            surface.dividend_yield = data.dividend_yield;
        }
        
        bool is_price_outlier(const MarketOptionData& data, size_t i, size_t j) {
            // Détection d'outliers basée sur les prix voisins
            return false; // Placeholder
        }
        
        void interpolate_outlier_price(MarketOptionData& data, size_t i, size_t j) {
            // Interpolation d'un prix aberrant
        }
        
        void interpolate_price_at_point(MarketOptionData& data, size_t i, size_t j) {
            // Interpolation d'un prix manquant
        }
        
        double calculate_implied_volatility_newton_raphson(
            double market_price, double spot, double strike, double maturity,
            double rate, double dividend) {
            
            // Implémentation Newton-Raphson pour volatilité implicite
            return 0.20; // Placeholder
        }
        
        struct PriceDerivatives {
            std::vector<std::vector<double>> dC_dT;
            std::vector<std::vector<double>> dC_dK;
            std::vector<std::vector<double>> d2C_dK2;
        };
        
        PriceDerivatives calculate_price_derivatives_from_market(const MarketOptionData& data) {
            return PriceDerivatives{}; // Placeholder
        }
        
        std::vector<std::vector<double>> apply_dupire_formula_with_regularization(
            const PriceDerivatives& derivatives,
            const MarketOptionData& data,
            const CalibrationParameters& params) {
            
            return {}; // Placeholder
        }
        
        std::vector<std::vector<double>> apply_bicubic_spline_smoothing(
            const std::vector<std::vector<double>>& matrix, double smoothing_factor) {
            return matrix; // Placeholder
        }
        
        std::vector<std::vector<double>> apply_tikhonov_regularization(
            const std::vector<std::vector<double>>& matrix, double reg_param) {
            return matrix; // Placeholder
        }
        
        LocalVolatilitySurface enforce_no_arbitrage_constraints(const LocalVolatilitySurface& surface) {
            return surface; // Placeholder
        }
        
        double price_option_with_local_vol_surface(
            const LocalVolatilitySurface& surface,
            double strike, double maturity, const std::string& option_type) {
            return 5.0; // Placeholder
        }
    };
}
```

## Numerical Parameters Optimization

### PDE Grid Optimization

#### Adaptive Grid Calibration
```cpp
// Optimisation des paramètres numériques pour méthodes hybrides
class NumericalParametersOptimizer {
public:
    struct OptimizationTarget {
        double target_accuracy;        // Précision cible
        double max_computation_time;   // Temps de calcul maximal
        double max_memory_usage;       // Utilisation mémoire maximale
        bool prioritize_greeks_accuracy; // Prioriser précision des Greeks
    };
    
    struct OptimalParameters {
        // Paramètres PDE
        int optimal_spot_grid_points;
        int optimal_time_steps;
        std::string optimal_spatial_scheme;
        std::string optimal_time_scheme;
        
        // Paramètres Monte Carlo
        int optimal_num_paths;
        int optimal_mc_time_steps;
        bool use_variance_reduction;
        
        // Paramètres hybrides
        double complexity_threshold;
        PricingMethod default_method;
        
        // Métriques de performance
        double expected_accuracy;
        double expected_computation_time;
        double expected_memory_usage;
    };
    
    // Optimisation des paramètres numériques
    OptimalParameters optimize_numerical_parameters(
        const ProductSpecification& product,
        const OptimizationTarget& target) {
        
        OptimalParameters params;
        
        // Optimisation des paramètres PDE
        optimize_pde_parameters(product, target, params);
        
        // Optimisation des paramètres Monte Carlo
        optimize_mc_parameters(product, target, params);
        
        // Optimisation de la sélection hybride
        optimize_hybrid_selection(product, target, params);
        
        // Validation des paramètres optimaux
        validate_optimal_parameters(params, target);
        
        return params;
    }
    
private:
    void optimize_pde_parameters(const ProductSpecification& product,
                                const OptimizationTarget& target,
                                OptimalParameters& params) {
        
        // Optimisation basée sur la complexité du produit
        if (product.has_barriers) {
            params.optimal_spot_grid_points = 200; // Plus de points près des barrières
        } else {
            params.optimal_spot_grid_points = 100; // Standard pour vanilles
        }
        
        // Optimisation temporelle
        if (product.maturity < 0.1) { // Court terme
            params.optimal_time_steps = 200; // Plus de pas pour stabilité
        } else {
            params.optimal_time_steps = 100; // Standard
        }
        
        // Sélection du schéma selon le produit
        if (product.has_discontinuous_payoff) {
            params.optimal_spatial_scheme = "UPWIND";
        } else {
            params.optimal_spatial_scheme = "CENTRAL_DIFFERENCE";
        }
        
        params.optimal_time_scheme = "CRANK_NICOLSON"; // Généralement optimal
    }
    
    void optimize_mc_parameters(const ProductSpecification& product,
                               const OptimizationTarget& target,
                               OptimalParameters& params) {
        
        // Nombre de chemins basé sur la précision cible
        if (target.target_accuracy < 0.001) {
            params.optimal_num_paths = 1000000; // Haute précision
        } else if (target.target_accuracy < 0.01) {
            params.optimal_num_paths = 100000; // Précision standard
        } else {
            params.optimal_num_paths = 10000; // Précision modérée
        }
        
        // Pas de temps MC
        if (product.is_path_dependent) {
            params.optimal_mc_time_steps = 252; // Quotidien pour path-dependent
        } else {
            params.optimal_mc_time_steps = 50; // Standard pour vanilles
        }
        
        // Techniques de réduction de variance
        params.use_variance_reduction = (target.target_accuracy < 0.01);
    }
    
    void optimize_hybrid_selection(const ProductSpecification& product,
                                  const OptimizationTarget& target,
                                  OptimalParameters& params) {
        
        // Seuil de complexité pour sélection hybride
        if (target.prioritize_greeks_accuracy) {
            params.complexity_threshold = 1.0; // Favoriser PDE pour Greeks
            params.default_method = PricingMethod::PDE_ONLY;
        } else {
            params.complexity_threshold = 2.0; // Équilibre PDE/MC
            params.default_method = PricingMethod::HYBRID_ADAPTIVE;
        }
    }
    
    void validate_optimal_parameters(const OptimalParameters& params,
                                    const OptimizationTarget& target) {
        
        // Estimation des métriques de performance
        double estimated_time = estimate_computation_time(params);
        double estimated_memory = estimate_memory_usage(params);
        double estimated_accuracy = estimate_accuracy(params);
        
        if (estimated_time > target.max_computation_time) {
            XSIGMA_LOG_WARNING("Temps de calcul estimé dépasse la cible");
        }
        
        if (estimated_memory > target.max_memory_usage) {
            XSIGMA_LOG_WARNING("Utilisation mémoire estimée dépasse la cible");
        }
        
        if (estimated_accuracy > target.target_accuracy) {
            XSIGMA_LOG_WARNING("Précision estimée inférieure à la cible");
        }
    }
    
    double estimate_computation_time(const OptimalParameters& params) {
        // Estimation du temps de calcul basée sur les paramètres
        double pde_time = params.optimal_spot_grid_points * params.optimal_time_steps * 0.001; // ms
        double mc_time = params.optimal_num_paths * params.optimal_mc_time_steps * 0.0001; // ms
        
        return std::max(pde_time, mc_time); // Temps de la méthode dominante
    }
    
    double estimate_memory_usage(const OptimalParameters& params) {
        // Estimation de l'utilisation mémoire
        double pde_memory = params.optimal_spot_grid_points * params.optimal_spot_grid_points * 8 / 1e6; // MB
        double mc_memory = params.optimal_num_paths * params.optimal_mc_time_steps * 8 / 1e6; // MB
        
        return pde_memory + mc_memory;
    }
    
    double estimate_accuracy(const OptimalParameters& params) {
        // Estimation de la précision basée sur les paramètres
        double pde_accuracy = 1.0 / (params.optimal_spot_grid_points * params.optimal_time_steps);
        double mc_accuracy = 1.0 / std::sqrt(params.optimal_num_paths);
        
        return std::min(pde_accuracy, mc_accuracy);
    }
};
```

## Cross-Validation Framework

### PDE vs Monte Carlo Validation
```cpp
// Framework de validation croisée PDE vs Monte Carlo
class CrossValidationFramework {
public:
    struct ValidationResult {
        double price_difference_pct;
        double delta_difference_pct;
        double gamma_difference_pct;
        bool validation_passed;
        std::string validation_summary;
        std::vector<std::string> warnings;
    };
    
    // Validation croisée complète
    ValidationResult perform_cross_validation(
        const ProductSpecification& product,
        const LocalVolatilitySurface& lv_surface) {
        
        ValidationResult result;
        
        // Pricing PDE
        auto pde_result = price_via_pde(product, lv_surface);
        
        // Pricing Monte Carlo
        auto mc_result = price_via_monte_carlo(product, lv_surface);
        
        // Comparaison des prix
        result.price_difference_pct = std::abs(pde_result.price - mc_result.price) / mc_result.price * 100;
        
        // Comparaison des Greeks
        result.delta_difference_pct = std::abs(pde_result.delta - mc_result.delta) / std::abs(mc_result.delta) * 100;
        result.gamma_difference_pct = std::abs(pde_result.gamma - mc_result.gamma) / std::abs(mc_result.gamma) * 100;
        
        // Critères de validation
        result.validation_passed = (result.price_difference_pct < 2.0 &&  // 2%
                                   result.delta_difference_pct < 5.0 &&   // 5%
                                   result.gamma_difference_pct < 10.0);   // 10%
        
        // Génération du résumé
        generate_validation_summary(result);
        
        return result;
    }
    
private:
    struct PricingResult {
        double price;
        double delta;
        double gamma;
        double computation_time;
    };
    
    PricingResult price_via_pde(const ProductSpecification& product,
                               const LocalVolatilitySurface& surface) {
        return PricingResult{5.0, 0.6, 0.02, 100.0}; // Placeholder
    }
    
    PricingResult price_via_monte_carlo(const ProductSpecification& product,
                                       const LocalVolatilitySurface& surface) {
        return PricingResult{5.05, 0.61, 0.021, 200.0}; // Placeholder
    }
    
    void generate_validation_summary(ValidationResult& result) {
        if (result.validation_passed) {
            result.validation_summary = "Validation croisée réussie";
        } else {
            result.validation_summary = "Validation croisée échouée - différences significatives";
            
            if (result.price_difference_pct > 2.0) {
                result.warnings.push_back("Différence de prix > 2%");
            }
            if (result.delta_difference_pct > 5.0) {
                result.warnings.push_back("Différence de delta > 5%");
            }
            if (result.gamma_difference_pct > 10.0) {
                result.warnings.push_back("Différence de gamma > 10%");
            }
        }
    }
};
```

Le framework de calibration Local Volatility PDE and MC dans Our project assure une calibration robuste de la surface de volatilité locale via l'équation de Dupire, avec optimisation des paramètres numériques et validation croisée systématique entre méthodes PDE et Monte Carlo.
