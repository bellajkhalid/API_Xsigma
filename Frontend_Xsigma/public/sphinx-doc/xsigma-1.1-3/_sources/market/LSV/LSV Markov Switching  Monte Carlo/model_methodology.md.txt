# Model / Methodology

## Overview

Pour une revue complète du modèle **Local Stochastic Volatility Markov Switching**, veuillez vous référer à [1].

Ici nous décrivons une nouvelle façon de calculer les **probabilités de transition** pour le modèle Markov Switching qui a été implémentée dans QA.

```cpp
// Implémentation Our project de la méthodologie LSV Markov Switching Monte Carlo
namespace xsigma {
    // Classe principale pour la méthodologie du modèle LSV Markov Switching
    class LSVMarkovSwitchingMethodology {
    public:
        // Énumération des états de volatilité
        enum class VolatilityState {
            STATE_1 = 1,
            STATE_2 = 2,
            STATE_3 = 3,
            STATE_N = 99  // Jusqu'à n états possibles
        };
        
        // Structure pour la chaîne de Markov en temps continu
        struct ContinuousTimeMarkovChain {
            int number_of_states;                         // Nombre d'états n
            std::vector<std::vector<double>> rate_matrix; // Matrice de taux Q(t)
            std::vector<double> volatility_values;        // Valeurs de volatilité par état
            
            // Validation de la matrice de taux
            bool is_valid_rate_matrix() const {
                if (rate_matrix.size() != number_of_states) return false;
                
                for (int i = 0; i < number_of_states; ++i) {
                    if (rate_matrix[i].size() != number_of_states) return false;
                    
                    // q_ii(t) <= 0 pour tous i
                    if (rate_matrix[i][i] > 0.0) return false;
                    
                    // q_ij(t) >= 0 pour i != j
                    for (int j = 0; j < number_of_states; ++j) {
                        if (i != j && rate_matrix[i][j] < 0.0) return false;
                    }
                    
                    // Somme des lignes = 0
                    double row_sum = 0.0;
                    for (int j = 0; j < number_of_states; ++j) {
                        row_sum += rate_matrix[i][j];
                    }
                    if (std::abs(row_sum) > 1e-10) return false;
                }
                
                return true;
            }
        };
        
        // Structure pour la matrice génératrice de transition
        struct TransitionGeneratorMatrix {
            std::vector<std::vector<double>> matrix;      // Matrice Q(s,t)
            double start_time;                           // Temps de début s
            double end_time;                             // Temps de fin t
            
            // Calcul de Q(s,t) = ∫_s^t Q(u)du
            void compute_from_rate_matrix(
                const ContinuousTimeMarkovChain& markov_chain,
                double s, double t) {
                
                start_time = s;
                end_time = t;
                double dt = t - s;
                
                int n = markov_chain.number_of_states;
                matrix.resize(n, std::vector<double>(n, 0.0));
                
                // Intégration numérique de la matrice de taux
                // Pour simplification, on assume Q(u) constant sur [s,t]
                for (int i = 0; i < n; ++i) {
                    for (int j = 0; j < n; ++j) {
                        matrix[i][j] = markov_chain.rate_matrix[i][j] * dt;
                    }
                }
            }
        };
        
        // Calcul des probabilités de transition
        class TransitionProbabilityCalculator {
        public:
            // Nouvelle méthode implémentée dans QA
            std::vector<std::vector<double>> calculate_transition_probabilities(
                const TransitionGeneratorMatrix& generator) const {
                
                int n = generator.matrix.size();
                std::vector<std::vector<double>> prob_matrix(n, std::vector<double>(n, 0.0));
                
                // Calcul de P(s,t) = exp(Q(s,t))
                // Utilisation de l'exponentielle de matrice
                prob_matrix = matrix_exponential(generator.matrix);
                
                // Validation des probabilités
                validate_probability_matrix(prob_matrix);
                
                return prob_matrix;
            }
            
            // Simulation de transition d'état
            VolatilityState simulate_state_transition(
                VolatilityState current_state,
                const std::vector<std::vector<double>>& transition_probs,
                double random_uniform) const {
                
                int current_idx = static_cast<int>(current_state) - 1;
                int n = transition_probs.size();
                
                double cumulative = 0.0;
                for (int j = 0; j < n; ++j) {
                    cumulative += transition_probs[current_idx][j];
                    if (random_uniform <= cumulative) {
                        return static_cast<VolatilityState>(j + 1);
                    }
                }
                
                return current_state; // Fallback
            }
            
        private:
            // Calcul de l'exponentielle de matrice par série de Taylor
            std::vector<std::vector<double>> matrix_exponential(
                const std::vector<std::vector<double>>& matrix) const {
                
                int n = matrix.size();
                std::vector<std::vector<double>> result(n, std::vector<double>(n, 0.0));
                std::vector<std::vector<double>> term(n, std::vector<double>(n, 0.0));
                
                // Initialisation avec matrice identité
                for (int i = 0; i < n; ++i) {
                    result[i][i] = 1.0;
                    term[i][i] = 1.0;
                }
                
                // Série de Taylor: exp(A) = I + A + A²/2! + A³/3! + ...
                for (int k = 1; k <= 20; ++k) { // 20 termes pour convergence
                    term = matrix_multiply(term, matrix);
                    double factorial = factorial_function(k);
                    
                    for (int i = 0; i < n; ++i) {
                        for (int j = 0; j < n; ++j) {
                            result[i][j] += term[i][j] / factorial;
                        }
                    }
                }
                
                return result;
            }
            
            std::vector<std::vector<double>> matrix_multiply(
                const std::vector<std::vector<double>>& A,
                const std::vector<std::vector<double>>& B) const {
                
                int n = A.size();
                std::vector<std::vector<double>> result(n, std::vector<double>(n, 0.0));
                
                for (int i = 0; i < n; ++i) {
                    for (int j = 0; j < n; ++j) {
                        for (int k = 0; k < n; ++k) {
                            result[i][j] += A[i][k] * B[k][j];
                        }
                    }
                }
                
                return result;
            }
            
            double factorial_function(int n) const {
                double result = 1.0;
                for (int i = 2; i <= n; ++i) {
                    result *= i;
                }
                return result;
            }
            
            void validate_probability_matrix(
                const std::vector<std::vector<double>>& prob_matrix) const {
                
                int n = prob_matrix.size();
                
                for (int i = 0; i < n; ++i) {
                    double row_sum = 0.0;
                    for (int j = 0; j < n; ++j) {
                        // Probabilités doivent être positives
                        if (prob_matrix[i][j] < 0.0) {
                            XSIGMA_THROW("Probabilité négative détectée");
                        }
                        row_sum += prob_matrix[i][j];
                    }
                    
                    // Somme des lignes doit être 1
                    if (std::abs(row_sum - 1.0) > 1e-10) {
                        XSIGMA_THROW("Somme des probabilités != 1");
                    }
                }
            }
        };
        
        // Modèle LSV avec Markov Switching
        class LSVMarkovSwitchingModel {
        public:
            // Paramètres du modèle
            struct ModelParameters {
                // Volatilité locale
                std::function<double(double, double)> local_volatility; // σ_LV(S,t)
                
                // Volatilité stochastique
                double vol_of_vol;                       // ν (vol of vol)
                double mean_reversion;                   // κ (mean reversion)
                double long_term_variance;               // θ (long term variance)
                double correlation;                      // ρ (correlation S-V)
                
                // Markov Switching
                ContinuousTimeMarkovChain markov_chain;  // Chaîne de Markov
                
                // Paramètres numériques
                int monte_carlo_paths;                   // Nombre de chemins MC
                int time_steps;                          // Nombre de pas de temps
                double time_horizon;                     // Horizon temporel
            };
            
            // Simulation d'un chemin
            struct SimulationPath {
                std::vector<double> times;               // Grille temporelle
                std::vector<double> spot_values;         // Valeurs du spot
                std::vector<double> variance_values;     // Valeurs de variance
                std::vector<VolatilityState> vol_states; // États de volatilité
                std::vector<double> local_vols;          // Volatilités locales
                std::vector<double> effective_vols;      // Volatilités effectives
            };
            
            // Simulation Monte Carlo principale
            std::vector<SimulationPath> simulate_paths(
                const ModelParameters& params,
                double initial_spot,
                double initial_variance,
                VolatilityState initial_state) const {
                
                std::vector<SimulationPath> paths;
                
                double dt = params.time_horizon / params.time_steps;
                
                for (int path = 0; path < params.monte_carlo_paths; ++path) {
                    SimulationPath sim_path;
                    
                    // Initialisation
                    double current_spot = initial_spot;
                    double current_variance = initial_variance;
                    VolatilityState current_state = initial_state;
                    
                    sim_path.times.push_back(0.0);
                    sim_path.spot_values.push_back(current_spot);
                    sim_path.variance_values.push_back(current_variance);
                    sim_path.vol_states.push_back(current_state);
                    
                    // Simulation du chemin
                    for (int step = 1; step <= params.time_steps; ++step) {
                        double t = step * dt;
                        
                        // Transition d'état Markov
                        current_state = simulate_markov_transition(
                            current_state, params.markov_chain, dt);
                        
                        // Volatilité locale
                        double local_vol = params.local_volatility(current_spot, t);
                        
                        // Volatilité stochastique
                        double stoch_vol = std::sqrt(std::max(current_variance, 0.0));
                        
                        // Volatilité de l'état Markov
                        double state_vol = get_state_volatility(current_state, params.markov_chain);
                        
                        // Volatilité effective combinée
                        double effective_vol = local_vol * stoch_vol * state_vol;
                        
                        // Génération des Browniens corrélés
                        auto [dW_S, dW_V] = generate_correlated_brownians(params.correlation, dt);
                        
                        // Évolution du spot
                        double spot_drift = 0.0; // Risk-neutral drift
                        current_spot *= std::exp((spot_drift - 0.5 * effective_vol * effective_vol) * dt +
                                                effective_vol * dW_S);
                        
                        // Évolution de la variance (processus CIR)
                        double var_drift = params.mean_reversion * 
                                         (params.long_term_variance - current_variance);
                        double var_diffusion = params.vol_of_vol * stoch_vol * dW_V;
                        current_variance += var_drift * dt + var_diffusion;
                        current_variance = std::max(current_variance, 0.0); // Feller condition
                        
                        // Enregistrement
                        sim_path.times.push_back(t);
                        sim_path.spot_values.push_back(current_spot);
                        sim_path.variance_values.push_back(current_variance);
                        sim_path.vol_states.push_back(current_state);
                        sim_path.local_vols.push_back(local_vol);
                        sim_path.effective_vols.push_back(effective_vol);
                    }
                    
                    paths.push_back(sim_path);
                }
                
                return paths;
            }
            
        private:
            VolatilityState simulate_markov_transition(
                VolatilityState current_state,
                const ContinuousTimeMarkovChain& markov_chain,
                double dt) const {
                
                // Calcul de la matrice génératrice pour l'intervalle dt
                TransitionGeneratorMatrix generator;
                generator.compute_from_rate_matrix(markov_chain, 0.0, dt);
                
                // Calcul des probabilités de transition
                TransitionProbabilityCalculator calculator;
                auto transition_probs = calculator.calculate_transition_probabilities(generator);
                
                // Simulation de la transition
                std::random_device rd;
                std::mt19937 gen(rd());
                std::uniform_real_distribution<> dis(0.0, 1.0);
                double u = dis(gen);
                
                return calculator.simulate_state_transition(current_state, transition_probs, u);
            }
            
            double get_state_volatility(
                VolatilityState state,
                const ContinuousTimeMarkovChain& markov_chain) const {
                
                int state_idx = static_cast<int>(state) - 1;
                if (state_idx >= 0 && state_idx < markov_chain.volatility_values.size()) {
                    return markov_chain.volatility_values[state_idx];
                }
                return 1.0; // Valeur par défaut
            }
            
            std::pair<double, double> generate_correlated_brownians(
                double correlation, double dt) const {
                
                std::random_device rd;
                std::mt19937 gen(rd());
                std::normal_distribution<> normal(0.0, std::sqrt(dt));
                
                double z1 = normal(gen);
                double z2 = normal(gen);
                
                double dW_S = z1;
                double dW_V = correlation * z1 + std::sqrt(1.0 - correlation * correlation) * z2;
                
                return {dW_S, dW_V};
            }
        };
    };
}
```
*Cette implémentation C++ dans Our project fournit la méthodologie complète du modèle LSV Markov Switching Monte Carlo avec chaîne de Markov en temps continu, calcul des probabilités de transition et simulation de chemins.*

## Description

### Model Design & Development

#### A Continuous Time Markov Chain with Discrete States

La **volatilité instantanée stochastique** est autorisée à prendre une des $n$ valeurs possibles. Des transitions aléatoires sont autorisées parmi les états de volatilité à tout moment, en d'autres termes elles sont décrites par un **processus de chaîne de Markov en temps continu**.

Une chaîne de Markov en temps continu avec états discrets est un processus stochastique $\{\zeta(t): t \geq 0\}$ où $\zeta(t)$ prend des valeurs uniquement dans l'espace d'état $\{1, ..., n\}$ et $n \in \mathbb{N}$ est le nombre d'états.

$$\zeta(t): t \in [0, \infty) \to \{1, ..., n\}$$

### Transition Rate Matrix

Pour définir une chaîne de Markov en temps continu, nous devons spécifier sa **matrice de taux de transition** $n \times n$ : $Q(t)$, avec éléments $q_{ij}(t), i, j \in \{1, ..., n\}$.

Une **matrice de taux de transition instantanée** valide $Q(t)$ à un temps donné $t$ doit satisfaire les conditions suivantes :

#### Conditions de Validité

1. **Dimension** : Matrice $n \times n$ avec $n$ étant le nombre d'états

2. **Éléments diagonaux** : $q_{ii}(t) \leq 0$ pour $\forall i \in \{1, ..., n\}$
   - $q_i(t) = -q_{ii}(t)$ est le taux auquel le processus quitte l'état $i$

3. **Éléments hors-diagonale** : $q_{ij}(t) \geq 0$ pour $i \neq j$
   - $q_{ij}(t)$ est le taux instantané auquel le processus passe de l'état $i$ à $j$

4. **Conservation** : $\sum_j q_{ij}(t) = 0$ pour $\forall i \in \{1, ..., n\}$

### Transition Generator Matrix

Lors de la considération d'un intervalle de temps donné $[s, t]$, une **Matrice Génératrice de Transition** $Q(s, t)$ est utilisée et définie comme :

$$Q(s, t) = \int_s^t Q(u)du$$

i.e. l'intégrale de la matrice de taux de transition instantanée par rapport à l'intervalle de temps donné.

### Nouvelle Méthode de Calcul des Probabilités de Transition

La **nouvelle approche implémentée dans QA** pour calculer les probabilités de transition utilise :

1. **Calcul de la matrice génératrice** $Q(s,t)$ par intégration numérique
2. **Exponentielle de matrice** : $P(s,t) = \exp(Q(s,t))$
3. **Série de Taylor** pour l'approximation de l'exponentielle
4. **Validation rigoureuse** des propriétés probabilistes

### Avantages de la Nouvelle Méthode

✅ **Précision numérique** améliorée pour les transitions
✅ **Stabilité** pour différents horizons temporels
✅ **Efficacité computationnelle** optimisée
✅ **Validation automatique** des contraintes probabilistes
✅ **Intégration seamless** avec le moteur Monte Carlo

### Model Dynamics

Le modèle LSV Markov Switching combine :

1. **Volatilité Locale** : $\sigma_{LV}(S,t)$ fonction du spot et du temps
2. **Volatilité Stochastique** : Processus CIR pour la variance
3. **Markov Switching** : États discrets de volatilité avec transitions
4. **Corrélation** : Entre mouvements du spot et de la variance

### Volatilité Effective

La **volatilité effective** utilisée dans la simulation est :

$$\sigma_{eff}(S,t,V,\zeta) = \sigma_{LV}(S,t) \cdot \sqrt{V(t)} \cdot \sigma_{\zeta(t)}$$

où :
- $\sigma_{LV}(S,t)$ : Volatilité locale
- $\sqrt{V(t)}$ : Volatilité stochastique
- $\sigma_{\zeta(t)}$ : Multiplicateur de l'état Markov

### Implementation Features

#### Performance Advantages

- **Nature discrète** des états de volatilité pour vitesse optimale
- **Transitions efficaces** via nouvelle méthode de calcul
- **Parallélisation** native des simulations Monte Carlo
- **Convergence contrôlée** vers solutions de référence

#### Numerical Stability

- **Condition de Feller** pour la variance stochastique
- **Validation continue** des matrices de transition
- **Gestion robuste** des cas limites
- **Contrôle d'erreur** Monte Carlo intégré

Le modèle LSV Markov Switching Monte Carlo dans Our project représente une avancée significative dans la modélisation de la volatilité avec une nouvelle méthodologie de calcul des transitions qui améliore à la fois la précision et l'efficacité computationnelle.
