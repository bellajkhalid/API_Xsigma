# Numerical Implementation

## Overview

Cette section décrit l'implémentation numérique du modèle **FX LSV Markov Switching PDE**, incluant les méthodes de discrétisation, les solveurs PDE et les techniques d'optimisation pour le calcul des Greeks FX.

## PDE Discretization Framework

### Finite Difference Schemes

#### Spatial Discretization
```cpp
// Schémas de discrétisation spatiale pour FX LSV MS PDE
namespace xsigma::pde_discretization {
    
    class FXLSVMSPDEDiscretizer {
    public:
        enum class SpatialScheme {
            CENTRAL_DIFFERENCE,      // Différences centrées standard
            UPWIND,                  // Schéma upwind pour convection
            WEIGHTED_UPWIND,         // Upwind pondéré
            COMPACT_DIFFERENCE       // Différences compactes haute précision
        };
        
        enum class TimeScheme {
            EXPLICIT_EULER,          // Euler explicite
            IMPLICIT_EULER,          // Euler implicite
            CRANK_NICOLSON,          // Crank-Nicolson
            RUNGE_KUTTA_4,           // Runge-Kutta ordre 4
            ADAPTIVE_TIME_STEPPING   // Pas de temps adaptatif
        };
        
        struct DiscretizationParameters {
            SpatialScheme spatial_scheme;
            TimeScheme time_scheme;
            
            // Grilles
            int spot_grid_points;
            int variance_grid_points;
            int time_steps;
            
            // Domaines
            double spot_min, spot_max;
            double variance_min, variance_max;
            double maturity;
            
            // Paramètres de stabilité
            double cfl_number;               // Nombre CFL pour stabilité
            double theta_implicitness;       // Paramètre d'implicité (0=explicite, 1=implicite)
            bool use_adaptive_grid;          // Grille adaptative
            bool use_artificial_viscosity;   // Viscosité artificielle
        };
        
        // Construction de la matrice de discrétisation PDE
        Eigen::SparseMatrix<double> build_pde_discretization_matrix(
            const DiscretizationParameters& params,
            const FXLSVMSPDEParameters& model_params,
            int markov_state) {
            
            int n_spots = params.spot_grid_points;
            int n_vars = params.variance_grid_points;
            int total_size = n_spots * n_vars;
            
            Eigen::SparseMatrix<double> matrix(total_size, total_size);
            std::vector<Eigen::Triplet<double>> triplets;
            
            // Construction des grilles
            auto spot_grid = build_spot_grid(params);
            auto variance_grid = build_variance_grid(params);
            
            // Discrétisation pour chaque point de grille
            for (int i = 1; i < n_spots - 1; ++i) {
                for (int j = 1; j < n_vars - 1; ++j) {
                    
                    int idx = i * n_vars + j;
                    double S = spot_grid[i];
                    double V = variance_grid[j];
                    
                    // Coefficients de l'EDP FX LSV MS
                    auto coeffs = calculate_pde_coefficients(S, V, model_params, markov_state);
                    
                    // Application du schéma de discrétisation
                    add_discretization_terms(triplets, idx, i, j, n_spots, n_vars,
                                           coeffs, params, spot_grid, variance_grid);
                }
            }
            
            // Conditions aux limites
            add_boundary_conditions(triplets, params, n_spots, n_vars);
            
            matrix.setFromTriplets(triplets.begin(), triplets.end());
            return matrix;
        }
        
        // Structure pour coefficients PDE
        struct PDECoefficients {
            double drift_spot;           // μ_S = (r_d - r_f)S
            double diffusion_spot;       // σ_S² = σ_eff²S²/2
            double drift_variance;       // μ_V = κ(θ - V)
            double diffusion_variance;   // σ_V² = ν²V/2
            double cross_term;           // ρσ_S σ_V SV
            double discount_rate;        // r_d
        };
        
        // Calcul des coefficients PDE pour un point donné
        PDECoefficients calculate_pde_coefficients(
            double spot, double variance,
            const FXLSVMSPDEParameters& model_params,
            int markov_state) {
            
            PDECoefficients coeffs;
            
            // Volatilité effective pour cet état Markov
            double local_vol = interpolate_local_volatility(spot, 0.0); // Temps initial
            double state_vol_multiplier = model_params.state_volatilities[markov_state];
            double effective_vol = local_vol * std::sqrt(variance) * state_vol_multiplier;
            
            // Coefficients FX LSV MS
            coeffs.drift_spot = (model_params.domestic_rate - model_params.foreign_rate) * spot;
            coeffs.diffusion_spot = 0.5 * effective_vol * effective_vol * spot * spot;
            
            coeffs.drift_variance = model_params.mean_reversion_speed * 
                                   (model_params.long_term_variance - variance);
            coeffs.diffusion_variance = 0.5 * model_params.vol_of_vol * model_params.vol_of_vol * variance;
            
            coeffs.cross_term = model_params.correlation * model_params.vol_of_vol * 
                               effective_vol * spot * std::sqrt(variance);
            
            coeffs.discount_rate = model_params.domestic_rate;
            
            return coeffs;
        }
        
        // Application des termes de discrétisation
        void add_discretization_terms(
            std::vector<Eigen::Triplet<double>>& triplets,
            int idx, int i, int j, int n_spots, int n_vars,
            const PDECoefficients& coeffs,
            const DiscretizationParameters& params,
            const std::vector<double>& spot_grid,
            const std::vector<double>& variance_grid) {
            
            double h_s = spot_grid[i+1] - spot_grid[i];     // Pas spot
            double h_v = variance_grid[j+1] - variance_grid[j]; // Pas variance
            double dt = params.maturity / params.time_steps;    // Pas temps
            
            // Terme temporel (∂V/∂t)
            triplets.emplace_back(idx, idx, 1.0 / dt);
            
            // Terme de drift spot ((r_d - r_f)S ∂V/∂S)
            if (params.spatial_scheme == SpatialScheme::CENTRAL_DIFFERENCE) {
                double coeff_drift_s = coeffs.drift_spot / (2.0 * h_s);
                triplets.emplace_back(idx, (i+1) * n_vars + j, coeff_drift_s);
                triplets.emplace_back(idx, (i-1) * n_vars + j, -coeff_drift_s);
            } else if (params.spatial_scheme == SpatialScheme::UPWIND) {
                // Schéma upwind selon le signe du drift
                double coeff_drift_s = coeffs.drift_spot / h_s;
                if (coeffs.drift_spot > 0) {
                    triplets.emplace_back(idx, idx, coeff_drift_s);
                    triplets.emplace_back(idx, (i-1) * n_vars + j, -coeff_drift_s);
                } else {
                    triplets.emplace_back(idx, (i+1) * n_vars + j, -coeff_drift_s);
                    triplets.emplace_back(idx, idx, coeff_drift_s);
                }
            }
            
            // Terme de diffusion spot (σ_eff²S²/2 ∂²V/∂S²)
            double coeff_diff_s = coeffs.diffusion_spot / (h_s * h_s);
            triplets.emplace_back(idx, (i+1) * n_vars + j, coeff_diff_s);
            triplets.emplace_back(idx, idx, -2.0 * coeff_diff_s);
            triplets.emplace_back(idx, (i-1) * n_vars + j, coeff_diff_s);
            
            // Terme de drift variance (κ(θ - V) ∂V/∂V)
            double coeff_drift_v = coeffs.drift_variance / (2.0 * h_v);
            triplets.emplace_back(idx, i * n_vars + (j+1), coeff_drift_v);
            triplets.emplace_back(idx, i * n_vars + (j-1), -coeff_drift_v);
            
            // Terme de diffusion variance (ν²V/2 ∂²V/∂V²)
            double coeff_diff_v = coeffs.diffusion_variance / (h_v * h_v);
            triplets.emplace_back(idx, i * n_vars + (j+1), coeff_diff_v);
            triplets.emplace_back(idx, idx, -2.0 * coeff_diff_v);
            triplets.emplace_back(idx, i * n_vars + (j-1), coeff_diff_v);
            
            // Terme croisé (ρνσ_eff SV ∂²V/∂S∂V)
            double coeff_cross = coeffs.cross_term / (4.0 * h_s * h_v);
            triplets.emplace_back(idx, (i+1) * n_vars + (j+1), coeff_cross);
            triplets.emplace_back(idx, (i+1) * n_vars + (j-1), -coeff_cross);
            triplets.emplace_back(idx, (i-1) * n_vars + (j+1), -coeff_cross);
            triplets.emplace_back(idx, (i-1) * n_vars + (j-1), coeff_cross);
            
            // Terme de discount (-r_d V)
            triplets.emplace_back(idx, idx, -coeffs.discount_rate);
        }
        
        // Grille adaptative pour concentration autour de points critiques
        std::vector<double> build_adaptive_spot_grid(
            const DiscretizationParameters& params,
            double spot_current,
            const std::vector<double>& critical_points = {}) {
            
            std::vector<double> grid;
            
            if (!params.use_adaptive_grid) {
                // Grille uniforme
                return build_uniform_grid(params.spot_min, params.spot_max, params.spot_grid_points);
            }
            
            // Grille adaptative avec concentration
            std::vector<double> concentration_points = critical_points;
            concentration_points.push_back(spot_current); // Concentration autour du spot actuel
            
            // Tri des points de concentration
            std::sort(concentration_points.begin(), concentration_points.end());
            
            // Construction de la grille avec concentration
            int points_per_region = params.spot_grid_points / (concentration_points.size() + 1);
            
            // Région avant le premier point critique
            auto pre_region = build_concentrated_grid(
                params.spot_min, concentration_points[0], points_per_region, 0.8);
            grid.insert(grid.end(), pre_region.begin(), pre_region.end());
            
            // Régions entre points critiques
            for (size_t i = 0; i < concentration_points.size() - 1; ++i) {
                auto mid_region = build_concentrated_grid(
                    concentration_points[i], concentration_points[i+1], points_per_region, 0.5);
                grid.insert(grid.end(), mid_region.begin(), mid_region.end());
            }
            
            // Région après le dernier point critique
            auto post_region = build_concentrated_grid(
                concentration_points.back(), params.spot_max, points_per_region, 0.2);
            grid.insert(grid.end(), post_region.begin(), post_region.end());
            
            // Suppression des doublons et tri
            std::sort(grid.begin(), grid.end());
            grid.erase(std::unique(grid.begin(), grid.end()), grid.end());
            
            return grid;
        }
        
    private:
        std::vector<double> build_spot_grid(const DiscretizationParameters& params) {
            return build_uniform_grid(params.spot_min, params.spot_max, params.spot_grid_points);
        }
        
        std::vector<double> build_variance_grid(const DiscretizationParameters& params) {
            return build_uniform_grid(params.variance_min, params.variance_max, params.variance_grid_points);
        }
        
        std::vector<double> build_uniform_grid(double min_val, double max_val, int n_points) {
            std::vector<double> grid;
            double step = (max_val - min_val) / (n_points - 1);
            
            for (int i = 0; i < n_points; ++i) {
                grid.push_back(min_val + i * step);
            }
            return grid;
        }
        
        std::vector<double> build_concentrated_grid(
            double start, double end, int n_points, double concentration_factor) {
            
            std::vector<double> grid;
            
            for (int i = 0; i < n_points; ++i) {
                double xi = static_cast<double>(i) / (n_points - 1);
                
                // Transformation pour concentration
                double transformed_xi = std::pow(xi, concentration_factor);
                
                double point = start + transformed_xi * (end - start);
                grid.push_back(point);
            }
            
            return grid;
        }
        
        void add_boundary_conditions(
            std::vector<Eigen::Triplet<double>>& triplets,
            const DiscretizationParameters& params,
            int n_spots, int n_vars) {
            
            // Conditions aux limites Dirichlet sur les frontières
            // Implémentation des conditions spécifiques FX
            
            // Frontière spot inférieure (S = S_min)
            for (int j = 0; j < n_vars; ++j) {
                int idx = 0 * n_vars + j;
                triplets.emplace_back(idx, idx, 1.0);
                // Valeur de frontière sera définie dans le vecteur RHS
            }
            
            // Frontière spot supérieure (S = S_max)
            for (int j = 0; j < n_vars; ++j) {
                int idx = (n_spots - 1) * n_vars + j;
                triplets.emplace_back(idx, idx, 1.0);
            }
            
            // Frontière variance inférieure (V = V_min)
            for (int i = 0; i < n_spots; ++i) {
                int idx = i * n_vars + 0;
                triplets.emplace_back(idx, idx, 1.0);
            }
            
            // Frontière variance supérieure (V = V_max)
            for (int i = 0; i < n_spots; ++i) {
                int idx = i * n_vars + (n_vars - 1);
                triplets.emplace_back(idx, idx, 1.0);
            }
        }
        
        double interpolate_local_volatility(double spot, double time) {
            // Interpolation de la volatilité locale calibrée
            return 0.15; // Placeholder
        }
    };
}
```

### Multi-State PDE System

#### Coupled System Solver
```cpp
// Solveur pour système PDE couplé multi-états
class FXLSVMSCoupledPDESolver {
public:
    struct CoupledSystemParameters {
        int number_of_states;
        std::vector<std::vector<double>> transition_rate_matrix;
        std::vector<Eigen::SparseMatrix<double>> state_pde_matrices;
        std::vector<Eigen::VectorXd> state_rhs_vectors;
        
        // Paramètres de solveur
        std::string solver_type;         // "DIRECT", "ITERATIVE", "MULTIGRID"
        double tolerance;                // Tolérance de convergence
        int max_iterations;              // Itérations maximales
        bool use_preconditioning;        // Préconditionnement
    };
    
    struct CoupledSolutionResult {
        std::vector<Eigen::VectorXd> state_solutions;
        bool converged;
        int iterations_used;
        double final_residual;
        double computation_time_ms;
    };
    
    // Résolution du système couplé
    CoupledSolutionResult solve_coupled_pde_system(
        const CoupledSystemParameters& params) {
        
        CoupledSolutionResult result;
        auto start_time = std::chrono::high_resolution_clock::now();
        
        try {
            if (params.solver_type == "DIRECT") {
                result = solve_direct_coupled_system(params);
            } else if (params.solver_type == "ITERATIVE") {
                result = solve_iterative_coupled_system(params);
            } else if (params.solver_type == "MULTIGRID") {
                result = solve_multigrid_coupled_system(params);
            } else {
                XSIGMA_THROW("Type de solveur non supporté: " + params.solver_type);
            }
            
            auto end_time = std::chrono::high_resolution_clock::now();
            result.computation_time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                end_time - start_time).count();
            
        } catch (const std::exception& e) {
            XSIGMA_LOG_ERROR("Erreur lors de la résolution du système couplé: " + std::string(e.what()));
            result.converged = false;
            throw;
        }
        
        return result;
    }
    
private:
    // Résolution directe via factorisation LU du système global
    CoupledSolutionResult solve_direct_coupled_system(
        const CoupledSystemParameters& params) {
        
        CoupledSolutionResult result;
        
        // Construction du système global couplé
        auto global_system = build_global_coupled_system(params);
        
        // Factorisation LU
        Eigen::SparseLU<Eigen::SparseMatrix<double>> solver;
        solver.compute(global_system.matrix);
        
        if (solver.info() != Eigen::Success) {
            XSIGMA_THROW("Échec de la factorisation LU du système couplé");
        }
        
        // Résolution
        Eigen::VectorXd global_solution = solver.solve(global_system.rhs);
        
        if (solver.info() != Eigen::Success) {
            XSIGMA_THROW("Échec de la résolution du système couplé");
        }
        
        // Extraction des solutions par état
        result.state_solutions = extract_state_solutions(global_solution, params);
        result.converged = true;
        result.iterations_used = 1; // Méthode directe
        result.final_residual = calculate_residual(global_system, global_solution);
        
        return result;
    }
    
    // Résolution itérative via méthode de Gauss-Seidel par blocs
    CoupledSolutionResult solve_iterative_coupled_system(
        const CoupledSystemParameters& params) {
        
        CoupledSolutionResult result;
        
        // Initialisation des solutions
        result.state_solutions.resize(params.number_of_states);
        for (int i = 0; i < params.number_of_states; ++i) {
            result.state_solutions[i] = Eigen::VectorXd::Zero(params.state_rhs_vectors[i].size());
        }
        
        // Itérations Gauss-Seidel par blocs
        for (int iter = 0; iter < params.max_iterations; ++iter) {
            
            std::vector<Eigen::VectorXd> old_solutions = result.state_solutions;
            
            // Mise à jour de chaque état
            for (int i = 0; i < params.number_of_states; ++i) {
                
                // Construction du RHS modifié incluant le couplage
                Eigen::VectorXd modified_rhs = params.state_rhs_vectors[i];
                
                for (int j = 0; j < params.number_of_states; ++j) {
                    if (i != j) {
                        double coupling_rate = params.transition_rate_matrix[i][j];
                        modified_rhs += coupling_rate * result.state_solutions[j];
                    }
                }
                
                // Résolution pour l'état i
                Eigen::SparseLU<Eigen::SparseMatrix<double>> state_solver;
                state_solver.compute(params.state_pde_matrices[i]);
                result.state_solutions[i] = state_solver.solve(modified_rhs);
            }
            
            // Test de convergence
            double max_change = 0.0;
            for (int i = 0; i < params.number_of_states; ++i) {
                double change = (result.state_solutions[i] - old_solutions[i]).norm();
                max_change = std::max(max_change, change);
            }
            
            if (max_change < params.tolerance) {
                result.converged = true;
                result.iterations_used = iter + 1;
                result.final_residual = max_change;
                break;
            }
        }
        
        if (!result.converged) {
            XSIGMA_LOG_WARNING("Convergence non atteinte après " + 
                              std::to_string(params.max_iterations) + " itérations");
        }
        
        return result;
    }
    
    // Résolution multigrid pour accélération
    CoupledSolutionResult solve_multigrid_coupled_system(
        const CoupledSystemParameters& params) {
        
        CoupledSolutionResult result;
        
        // Implémentation multigrid pour systèmes couplés
        // Utilisation de grilles de différentes résolutions
        
        auto multigrid_hierarchy = build_multigrid_hierarchy(params);
        
        // Cycle multigrid V
        result.state_solutions = multigrid_v_cycle(multigrid_hierarchy, params);
        
        // Validation de convergence
        result.converged = validate_multigrid_convergence(result.state_solutions, params);
        result.iterations_used = 1; // Cycle V
        result.final_residual = calculate_multigrid_residual(result.state_solutions, params);
        
        return result;
    }
    
    struct GlobalCoupledSystem {
        Eigen::SparseMatrix<double> matrix;
        Eigen::VectorXd rhs;
    };
    
    GlobalCoupledSystem build_global_coupled_system(const CoupledSystemParameters& params) {
        GlobalCoupledSystem system;
        
        int state_size = params.state_pde_matrices[0].rows();
        int total_size = params.number_of_states * state_size;
        
        system.matrix.resize(total_size, total_size);
        system.rhs.resize(total_size);
        
        std::vector<Eigen::Triplet<double>> triplets;
        
        // Construction par blocs
        for (int i = 0; i < params.number_of_states; ++i) {
            for (int j = 0; j < params.number_of_states; ++j) {
                
                if (i == j) {
                    // Bloc diagonal : matrice PDE de l'état
                    for (int k = 0; k < params.state_pde_matrices[i].outerSize(); ++k) {
                        for (Eigen::SparseMatrix<double>::InnerIterator it(params.state_pde_matrices[i], k); it; ++it) {
                            int row = i * state_size + it.row();
                            int col = j * state_size + it.col();
                            triplets.emplace_back(row, col, it.value());
                        }
                    }
                } else {
                    // Bloc hors-diagonal : couplage Markov
                    double coupling_rate = params.transition_rate_matrix[i][j];
                    for (int k = 0; k < state_size; ++k) {
                        int row = i * state_size + k;
                        int col = j * state_size + k;
                        triplets.emplace_back(row, col, coupling_rate);
                    }
                }
            }
            
            // RHS global
            for (int k = 0; k < state_size; ++k) {
                system.rhs[i * state_size + k] = params.state_rhs_vectors[i][k];
            }
        }
        
        system.matrix.setFromTriplets(triplets.begin(), triplets.end());
        return system;
    }
    
    std::vector<Eigen::VectorXd> extract_state_solutions(
        const Eigen::VectorXd& global_solution,
        const CoupledSystemParameters& params) {
        
        std::vector<Eigen::VectorXd> state_solutions;
        int state_size = params.state_pde_matrices[0].rows();
        
        for (int i = 0; i < params.number_of_states; ++i) {
            Eigen::VectorXd state_sol(state_size);
            for (int j = 0; j < state_size; ++j) {
                state_sol[j] = global_solution[i * state_size + j];
            }
            state_solutions.push_back(state_sol);
        }
        
        return state_solutions;
    }
    
    double calculate_residual(const GlobalCoupledSystem& system,
                             const Eigen::VectorXd& solution) {
        Eigen::VectorXd residual = system.matrix * solution - system.rhs;
        return residual.norm();
    }
    
    // Méthodes multigrid (placeholders)
    struct MultigridHierarchy {
        std::vector<CoupledSystemParameters> levels;
        std::vector<Eigen::SparseMatrix<double>> restriction_operators;
        std::vector<Eigen::SparseMatrix<double>> prolongation_operators;
    };
    
    MultigridHierarchy build_multigrid_hierarchy(const CoupledSystemParameters& params) {
        MultigridHierarchy hierarchy;
        // Construction de la hiérarchie multigrid
        return hierarchy;
    }
    
    std::vector<Eigen::VectorXd> multigrid_v_cycle(
        const MultigridHierarchy& hierarchy,
        const CoupledSystemParameters& params) {
        
        std::vector<Eigen::VectorXd> solutions;
        // Implémentation du cycle V multigrid
        return solutions;
    }
    
    bool validate_multigrid_convergence(
        const std::vector<Eigen::VectorXd>& solutions,
        const CoupledSystemParameters& params) {
        return true; // Placeholder
    }
    
    double calculate_multigrid_residual(
        const std::vector<Eigen::VectorXd>& solutions,
        const CoupledSystemParameters& params) {
        return 1e-8; // Placeholder
    }
};
```

## Greeks Calculation via PDE

### Direct PDE Greeks
```cpp
// Calcul direct des Greeks via PDE
class FXLSVMSPDEGreeksCalculator {
public:
    struct PDEGreeksResult {
        // Greeks de premier ordre
        double delta_spot;               // ∂V/∂S
        double delta_variance;           // ∂V/∂V
        double theta;                    // ∂V/∂t
        double rho_domestic;             // ∂V/∂r_d
        double rho_foreign;              // ∂V/∂r_f
        
        // Greeks de second ordre
        double gamma_spot;               // ∂²V/∂S²
        double gamma_variance;           // ∂²V/∂V²
        double cross_gamma;              // ∂²V/∂S∂V
        
        // Greeks avancés
        double vanna;                    // ∂²V/∂S∂σ
        double volga;                    // ∂²V/∂σ²
        double charm;                    // ∂²V/∂S∂t
        double color;                    // ∂²V/∂S²∂t
        
        // Greeks spécifiques Markov
        std::vector<double> state_sensitivities; // ∂V/∂λ_ij
        double correlation_sensitivity;   // ∂V/∂ρ
    };
    
    // Calcul des Greeks via différentiation de la solution PDE
    PDEGreeksResult calculate_pde_greeks(
        const std::vector<Eigen::VectorXd>& pde_solutions,
        const DiscretizationParameters& disc_params,
        const FXLSVMSPDEParameters& model_params,
        double current_spot,
        double current_variance) {
        
        PDEGreeksResult greeks;
        
        // Localisation du point d'intérêt dans la grille
        auto grid_indices = find_grid_indices(current_spot, current_variance, disc_params);
        
        // Greeks de premier ordre via différences finies sur la grille
        greeks.delta_spot = calculate_delta_spot_pde(
            pde_solutions, grid_indices, disc_params);
        
        greeks.delta_variance = calculate_delta_variance_pde(
            pde_solutions, grid_indices, disc_params);
        
        // Greeks de second ordre
        greeks.gamma_spot = calculate_gamma_spot_pde(
            pde_solutions, grid_indices, disc_params);
        
        greeks.gamma_variance = calculate_gamma_variance_pde(
            pde_solutions, grid_indices, disc_params);
        
        greeks.cross_gamma = calculate_cross_gamma_pde(
            pde_solutions, grid_indices, disc_params);
        
        // Greeks temporels via résolution PDE décalée
        greeks.theta = calculate_theta_pde(pde_solutions, model_params);
        
        // Greeks de taux via bump and reprice PDE
        greeks.rho_domestic = calculate_rho_domestic_pde(model_params);
        greeks.rho_foreign = calculate_rho_foreign_pde(model_params);
        
        // Greeks avancés
        greeks.vanna = calculate_vanna_pde(pde_solutions, grid_indices, disc_params);
        greeks.volga = calculate_volga_pde(pde_solutions, grid_indices, disc_params);
        greeks.charm = calculate_charm_pde(pde_solutions, grid_indices, disc_params);
        greeks.color = calculate_color_pde(pde_solutions, grid_indices, disc_params);
        
        // Greeks Markov
        greeks.state_sensitivities = calculate_state_sensitivities_pde(
            pde_solutions, model_params);
        greeks.correlation_sensitivity = calculate_correlation_sensitivity_pde(
            pde_solutions, model_params);
        
        return greeks;
    }
    
private:
    struct GridIndices {
        int i_spot, j_variance;
        double weight_i, weight_j;
    };
    
    GridIndices find_grid_indices(double spot, double variance,
                                 const DiscretizationParameters& params) {
        
        GridIndices indices;
        
        // Localisation dans la grille spot
        double spot_step = (params.spot_max - params.spot_min) / (params.spot_grid_points - 1);
        indices.i_spot = static_cast<int>((spot - params.spot_min) / spot_step);
        indices.weight_i = (spot - (params.spot_min + indices.i_spot * spot_step)) / spot_step;
        
        // Localisation dans la grille variance
        double var_step = (params.variance_max - params.variance_min) / (params.variance_grid_points - 1);
        indices.j_variance = static_cast<int>((variance - params.variance_min) / var_step);
        indices.weight_j = (variance - (params.variance_min + indices.j_variance * var_step)) / var_step;
        
        return indices;
    }
    
    double calculate_delta_spot_pde(
        const std::vector<Eigen::VectorXd>& solutions,
        const GridIndices& indices,
        const DiscretizationParameters& params) {
        
        // Delta via différences centrées sur la grille
        double spot_step = (params.spot_max - params.spot_min) / (params.spot_grid_points - 1);
        
        double delta = 0.0;
        for (size_t state = 0; state < solutions.size(); ++state) {
            int idx_up = (indices.i_spot + 1) * params.variance_grid_points + indices.j_variance;
            int idx_down = (indices.i_spot - 1) * params.variance_grid_points + indices.j_variance;
            
            double state_delta = (solutions[state][idx_up] - solutions[state][idx_down]) / (2.0 * spot_step);
            delta += state_delta; // Pondération par probabilités d'état si nécessaire
        }
        
        return delta / solutions.size(); // Moyenne sur les états
    }
    
    double calculate_gamma_spot_pde(
        const std::vector<Eigen::VectorXd>& solutions,
        const GridIndices& indices,
        const DiscretizationParameters& params) {
        
        // Gamma via différences finies de second ordre
        double spot_step = (params.spot_max - params.spot_min) / (params.spot_grid_points - 1);
        
        double gamma = 0.0;
        for (size_t state = 0; state < solutions.size(); ++state) {
            int idx_center = indices.i_spot * params.variance_grid_points + indices.j_variance;
            int idx_up = (indices.i_spot + 1) * params.variance_grid_points + indices.j_variance;
            int idx_down = (indices.i_spot - 1) * params.variance_grid_points + indices.j_variance;
            
            double state_gamma = (solutions[state][idx_up] - 2.0 * solutions[state][idx_center] + 
                                 solutions[state][idx_down]) / (spot_step * spot_step);
            gamma += state_gamma;
        }
        
        return gamma / solutions.size();
    }
    
    double calculate_cross_gamma_pde(
        const std::vector<Eigen::VectorXd>& solutions,
        const GridIndices& indices,
        const DiscretizationParameters& params) {
        
        // Gamma croisé ∂²V/∂S∂V
        double spot_step = (params.spot_max - params.spot_min) / (params.spot_grid_points - 1);
        double var_step = (params.variance_max - params.variance_min) / (params.variance_grid_points - 1);
        
        double cross_gamma = 0.0;
        for (size_t state = 0; state < solutions.size(); ++state) {
            
            // Points de grille pour dérivée mixte
            int idx_up_up = (indices.i_spot + 1) * params.variance_grid_points + (indices.j_variance + 1);
            int idx_up_down = (indices.i_spot + 1) * params.variance_grid_points + (indices.j_variance - 1);
            int idx_down_up = (indices.i_spot - 1) * params.variance_grid_points + (indices.j_variance + 1);
            int idx_down_down = (indices.i_spot - 1) * params.variance_grid_points + (indices.j_variance - 1);
            
            double state_cross_gamma = (solutions[state][idx_up_up] - solutions[state][idx_up_down] -
                                       solutions[state][idx_down_up] + solutions[state][idx_down_down]) /
                                      (4.0 * spot_step * var_step);
            cross_gamma += state_cross_gamma;
        }
        
        return cross_gamma / solutions.size();
    }
    
    // Méthodes pour autres Greeks (placeholders)
    double calculate_delta_variance_pde(const std::vector<Eigen::VectorXd>& solutions,
                                       const GridIndices& indices,
                                       const DiscretizationParameters& params) {
        return 0.0; // Implémentation similaire à delta_spot
    }
    
    double calculate_gamma_variance_pde(const std::vector<Eigen::VectorXd>& solutions,
                                       const GridIndices& indices,
                                       const DiscretizationParameters& params) {
        return 0.0; // Implémentation similaire à gamma_spot
    }
    
    double calculate_theta_pde(const std::vector<Eigen::VectorXd>& solutions,
                              const FXLSVMSPDEParameters& params) {
        return 0.0; // Calcul via résolution PDE avec temps décalé
    }
    
    double calculate_rho_domestic_pde(const FXLSVMSPDEParameters& params) {
        return 0.0; // Bump and reprice avec taux domestique
    }
    
    double calculate_rho_foreign_pde(const FXLSVMSPDEParameters& params) {
        return 0.0; // Bump and reprice avec taux étranger
    }
    
    double calculate_vanna_pde(const std::vector<Eigen::VectorXd>& solutions,
                              const GridIndices& indices,
                              const DiscretizationParameters& params) {
        return 0.0; // ∂²V/∂S∂σ
    }
    
    double calculate_volga_pde(const std::vector<Eigen::VectorXd>& solutions,
                              const GridIndices& indices,
                              const DiscretizationParameters& params) {
        return 0.0; // ∂²V/∂σ²
    }
    
    double calculate_charm_pde(const std::vector<Eigen::VectorXd>& solutions,
                              const GridIndices& indices,
                              const DiscretizationParameters& params) {
        return 0.0; // ∂²V/∂S∂t
    }
    
    double calculate_color_pde(const std::vector<Eigen::VectorXd>& solutions,
                              const GridIndices& indices,
                              const DiscretizationParameters& params) {
        return 0.0; // ∂²V/∂S²∂t
    }
    
    std::vector<double> calculate_state_sensitivities_pde(
        const std::vector<Eigen::VectorXd>& solutions,
        const FXLSVMSPDEParameters& params) {
        
        std::vector<double> sensitivities;
        // Sensibilités aux paramètres de transition Markov
        return sensitivities;
    }
    
    double calculate_correlation_sensitivity_pde(
        const std::vector<Eigen::VectorXd>& solutions,
        const FXLSVMSPDEParameters& params) {
        return 0.0; // ∂V/∂ρ
    }
};
```

L'implémentation numérique du modèle FX LSV Markov Switching PDE dans Our project combine des méthodes de discrétisation avancées, des solveurs robustes et des techniques de calcul de Greeks optimisées pour fournir une solution PDE complète et efficace pour le pricing d'options FX complexes.
