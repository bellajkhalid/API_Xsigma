# Introduction to Model and Validation

## üéØ **Validation Scope**

### **Objectif de la Validation**
Cette section d√©finit le scope complet de la validation pour les mod√®les **DBOPT-CorrelationSkew**, incluant les trois configurations principales, les produits couverts, et les m√©thodologies de validation sp√©cialis√©es pour la mod√©lisation de corr√©lation.

### **Mod√®les dans le Scope**
1. **DBOPT-RateDeterministic_FXMarket_AssetMarket_CorrelationSkew**
2. **DBOPT-RateDeterministic_EquityBlackScholes_AssetMarket_CorrelationSkew**
3. **DBOPT-RatesMarketAFSABR_FXMarket_EquityBlackScholes_CorrelationSkew**

### **Version du Mod√®le**
Le mod√®le a √©t√© revu pour **DBAnalytics** avec validation compl√®te des fonctionnalit√©s de corr√©lation et performances Monte Carlo.

---

## üìä **Product Description**

### **Caract√©ristiques G√©n√©rales des Produits**

#### **Propri√©t√©s Fondamentales**
Les produits couverts par ce framework partagent les caract√©ristiques suivantes :
- **D√©pendance** √† deux sous-jacents (IR/EQ/FX/Asset)
- **Fixation simultan√©e** des sous-jacents √† la m√™me date
- **Payoffs 2D** avec corr√©lation complexe
- **Pricing Monte Carlo** avec copule de corr√©lation

#### **Structure Math√©matique**
Les produits peuvent √™tre repr√©sent√©s sous la forme g√©n√©rale :

$$\text{Payoff} = f(S_1, S_2, \rho(S_1, S_2))$$

o√π $f$ est une fonction des deux sous-jacents $S_1, S_2$ et $\rho(S_1, S_2)$ est la corr√©lation d√©pendante des niveaux.

### **Produits Sp√©cifiques**

#### **üîÑ HybMultiDigital**
**Description :** Digitaux hybrides multi-actifs avec payoffs binaires.

**Formule de Payoff :**
$$\text{Payoff} = N \times \mathbf{1}_{\{S_1 > K_1, S_2 > K_2\}}$$

o√π :
- $N$ = Notionnel
- $S_1, S_2$ = Sous-jacents (IR/EQ/FX/Asset)
- $K_1, K_2$ = Strikes des digitaux
- $\mathbf{1}_{\{\cdot\}}$ = Fonction indicatrice

#### **üí∞ HybContingentOptMultiAssetBasket**
**Description :** Options contingentes sur panier multi-actifs.

**Formule de Payoff :**
$$\text{Payoff} = N \times \max(w_1 S_1 + w_2 S_2 - K, 0) \times \mathbf{1}_{\{S_1 > B_1, S_2 > B_2\}}$$

o√π :
- $w_1, w_2$ = Poids du panier
- $K$ = Strike de l'option
- $B_1, B_2$ = Barri√®res contingentes

---

## üèóÔ∏è **Model Description**

### **Framework Th√©orique**

#### **Mod√®le DBOPT-CorrelationSkew**
Le mod√®le DBOPT est une impl√©mentation analytique et Monte Carlo single horizon pour pricing de d√©riv√©s sur un ou deux sous-jacents.

**Composants Principaux :**
- **AFSABR** pour volatilit√© IR
- **PIV** pour volatilit√©s FX, EQ et Asset
- **Copule CorrelationSkew** pour distribution jointe

#### **Copule de Corr√©lation**
```cpp
// Impl√©mentation de la copule CorrelationSkew dans Our project
class correlation_skew_copula : public copula {
private:
    struct term_skew_parameters {
        int max_iterations;
        bool smoothing_enabled;
        std::string interpolation_type;
        matrix<double> correlation_targets;
    };
    
    term_skew_parameters params_;
    std::unique_ptr<monte_carlo_engine> mc_engine_;
    
public:
    correlation_skew_copula(const term_skew_parameters& params)
        : params_(params) {
        
        // Validation des param√®tres
        XSIGMA_CHECK(params_.max_iterations > 0, 
                     "TermSkewMaxIter must be positive");
        XSIGMA_CHECK(!params_.correlation_targets.empty(),
                     "CorrelationSkewTargets matrix required");
        
        // Initialisation du moteur Monte Carlo
        mc_engine_ = std::make_unique<monte_carlo_engine>(
            monte_carlo_config{
                .num_simulations = 100000,
                .random_seed = 12345,
                .copula_method = "SIMCOPULA"
            }
        );
    }
    
    std::pair<double, double> generate_correlated_pair(
        double u1, double u2, 
        double underlying_level_1, 
        double underlying_level_2) const {
        
        // Corr√©lation d√©pendante des niveaux (sticky strike)
        double correlation = get_correlation_for_levels(
            underlying_level_1, underlying_level_2);
        
        // G√©n√©ration via copule avec corr√©lation ajust√©e
        return generate_gaussian_copula_pair(u1, u2, correlation);
    }
    
private:
    double get_correlation_for_levels(double s1, double s2) const {
        // Interpolation dans la matrice de corr√©lation cible
        return interpolate_correlation_matrix(s1, s2, params_.correlation_targets);
    }
};
```
*Cette impl√©mentation C++ dans Our project montre la construction d'une copule de corr√©lation avec d√©pendance aux niveaux des sous-jacents (sticky strike) et param√®tres configurables.*

### **M√©thodologie TermSkew**

#### **Algorithme It√©ratif**
```cpp
// Algorithme TermSkew dans Our project
class term_skew_algorithm {
public:
    struct iteration_result {
        std::vector<std::pair<double, double>> simulated_pairs;
        double achieved_correlation;
        double target_correlation;
        double convergence_error;
        int iteration_number;
    };
    
    std::vector<iteration_result> run_term_skew_calibration(
        const correlation_skew_targets& targets) {
        
        std::vector<iteration_result> results;
        
        for (int iter = 0; iter < params_.max_iterations; ++iter) {
            iteration_result result;
            result.iteration_number = iter;
            
            // G√©n√©ration de paires corr√©l√©es
            result.simulated_pairs = generate_simulation_pairs(targets);
            
            // Calcul de la corr√©lation r√©alis√©e
            result.achieved_correlation = calculate_empirical_correlation(
                result.simulated_pairs);
            
            result.target_correlation = targets.get_target_correlation();
            result.convergence_error = std::abs(
                result.achieved_correlation - result.target_correlation);
            
            results.push_back(result);
            
            // Test de convergence
            if (result.convergence_error < CONVERGENCE_TOLERANCE) {
                break;
            }
            
            // Ajustement pour it√©ration suivante
            adjust_correlation_parameters(result);
        }
        
        return results;
    }
    
private:
    static constexpr double CONVERGENCE_TOLERANCE = 1e-6;
    
    void adjust_correlation_parameters(const iteration_result& result) {
        // Ajustement adaptatif des param√®tres de corr√©lation
        double adjustment_factor = result.convergence_error * 0.1;
        
        if (result.achieved_correlation < result.target_correlation) {
            increase_correlation_strength(adjustment_factor);
        } else {
            decrease_correlation_strength(adjustment_factor);
        }
    }
};
```
*Cet algorithme C++ dans Our project impl√©mente la m√©thode TermSkew avec calibration it√©rative pour atteindre les corr√©lations cibles.*

---

## üîß **Model Configurations**

### **Configuration 1 : RateDeterministic_FXMarket_AssetMarket**

#### **Param√®tres de Mod√®le**
```cpp
// Configuration 1 dans Our project
struct config_rate_fx_asset {
    // Param√®tres de courbe
    struct curve_params {
        std::string curve_type = "DETERMINISTIC";
        std::string interpolation = "LINEAR";
        std::string extrapolation = "FLAT";
    } rates_config;
    
    // Param√®tres FX
    struct fx_params {
        std::string vol_model = "PIV";
        std::string smile_model = "DSLV";
        bool auto_calibration = true;
    } fx_config;
    
    // Param√®tres Asset
    struct asset_params {
        std::string vol_model = "PIV";
        std::string dividend_model = "DETERMINISTIC";
    } asset_config;
    
    // Param√®tres de corr√©lation
    struct correlation_params {
        std::string copula_method = "SIMCOPULA";
        std::string correlation_space = "TERMSKEW";
        int term_skew_max_iter = 1000;
        bool term_skew_smoothing = true;
        std::string interp_type = "LINEAR";
    } correlation_config;
};
```

### **Configuration 2 : RateDeterministic_EquityBlackScholes_AssetMarket**

#### **Param√®tres Equity Black-Scholes**
```cpp
// Configuration 2 avec Equity BS dans Our project
struct config_rate_equity_asset {
    // Param√®tres Equity
    struct equity_params {
        std::string model_type = "BSANALYTIC";
        std::string vol_surface = "IMPLIED";
        std::string dividend_yield = "CONTINUOUS";
        
        // Validation du mod√®le BS
        bool validate_bs_parameters() const {
            return model_type == "BSANALYTIC" || model_type == "BSMC";
        }
    } equity_config;
    
    // H√©ritage des autres param√®tres
    config_rate_fx_asset::curve_params rates_config;
    config_rate_fx_asset::asset_params asset_config;
    config_rate_fx_asset::correlation_params correlation_config;
};
```

### **Configuration 3 : RatesMarketAFSABR_FXMarket_EquityBlackScholes**

#### **Param√®tres AFSABR Complets**
```cpp
// Configuration 3 avec AFSABR dans Our project
struct config_afsabr_fx_equity {
    // Param√®tres AFSABR
    struct afsabr_params {
        std::string model_type = "AFSABR";
        std::string calibration_target = "CMS_SKEW";
        bool auto_calibration = true;
        
        struct sabr_parameters {
            double alpha;
            double beta;
            double rho;
            double nu;
        } sabr_params;
        
        // Validation AFSABR
        bool validate_afsabr_setup() const {
            return sabr_params.beta >= 0.0 && sabr_params.beta <= 1.0 &&
                   sabr_params.rho >= -1.0 && sabr_params.rho <= 1.0;
        }
    } rates_config;
    
    // FX avec AUTO
    struct fx_auto_params {
        std::string model_type = "AUTO";
        std::string vol_surface = "MARKET_IMPLIED";
    } fx_config;
    
    // Equity BS analytique
    config_rate_equity_asset::equity_params equity_config;
    
    // Corr√©lation TERMSKEW
    struct correlation_termskew_params {
        std::string method = "TERMSKEW";
        std::string copula_method = "SIMCOPULA";
        bool advanced_smoothing = true;
    } correlation_config;
};
```

---

## üìà **Feeder and Servicer Models**

### **Architecture des Mod√®les**
Les mod√®les DBOPT-CorrelationSkew fonctionnent dans un √©cosyst√®me complexe :

#### **Feeder Models**
- **Market Data Feeds** : Courbes de taux, surfaces de volatilit√©
- **Correlation Targets** : Matrices de corr√©lation cibles
- **Calibration Data** : Prix de digitaux duaux pour calibration

#### **Servicer Models**
- **Risk Calculation Engines** : Calcul de sensibilit√©s corr√©l√©es
- **Stress Testing Frameworks** : CCAR, IRRBB avec corr√©lations
- **Monte Carlo Engines** : Simulations pour pricing et risques

### **Int√©gration avec Simulation Manager**
```cpp
// Int√©gration avec le gestionnaire de simulation dans Our project
class correlation_simulation_manager : public simulation_manager {
public:
    void initialize_correlation_matrix(
        const std::vector<asset_id>& assets,
        const correlation_skew_targets& targets) {
        
        // Construction de la matrice de corr√©lation
        size_t num_assets = assets.size();
        correlation_matrix_ = matrix<double>(num_assets, num_assets);
        
        // Remplissage avec corr√©lations cibles
        for (size_t i = 0; i < num_assets; ++i) {
            for (size_t j = 0; j < num_assets; ++j) {
                if (i == j) {
                    correlation_matrix_(i, j) = 1.0;
                } else {
                    correlation_matrix_(i, j) = targets.get_correlation(
                        assets[i], assets[j]);
                }
            }
        }
        
        // D√©composition de Cholesky pour simulation
        cholesky_decomposition(
            correlation_matrix_.begin(),
            static_cast<int>(correlation_matrix_.columns()),
            cholesky_decomposition_enum::LOWER_TRIANGULAR
        );
    }
    
    std::vector<double> generate_correlated_random_variables(
        const std::vector<double>& independent_randoms) {
        
        // Application de la d√©composition de Cholesky
        std::vector<double> correlated_randoms(independent_randoms.size());
        
        for (size_t i = 0; i < independent_randoms.size(); ++i) {
            correlated_randoms[i] = 0.0;
            for (size_t j = 0; j <= i; ++j) {
                correlated_randoms[i] += correlation_matrix_(i, j) * 
                                        independent_randoms[j];
            }
        }
        
        return correlated_randoms;
    }
};
```
*Cette classe C++ dans Our project montre l'int√©gration avec le gestionnaire de simulation pour g√©rer les corr√©lations complexes entre actifs.*

---

## üß™ **Validation Outline**

### **M√©thodologie de Validation Sp√©cialis√©e**

#### **üîç Phase 1 : Validation de Corr√©lation**
- V√©rification des copules de corr√©lation
- Tests de convergence TermSkew
- Validation sticky strike

#### **üîç Phase 2 : Tests Monte Carlo**
- Convergence des simulations
- Stabilit√© des prix et sensibilit√©s
- Validation des distributions marginales

#### **üîç Phase 3 : Tests de Produits**
- Pricing de digitaux duaux
- Options contingentes multi-actifs
- Validation sous stress de corr√©lation

#### **üîç Phase 4 : Validation R√©glementaire**
- Tests CCAR avec corr√©lations
- IRRBB avec actifs corr√©l√©s
- HistSim multivari√©e

### **Crit√®res d'Acceptation Sp√©cialis√©s**
- **Convergence Monte Carlo** : Erreur < 0.1% avec 100k simulations
- **Corr√©lation r√©alis√©e** : √âcart < 1% vs cible
- **Stabilit√© des risques** : Sensibilit√©s stables sous stress
- **Performance** : Temps de calcul < 30s par trade

---

*Cette section fournit une introduction compl√®te aux mod√®les DBOPT-CorrelationSkew et √† leur validation, int√©grant les impl√©mentations C++ de Our project avec les m√©thodologies de validation sp√©cialis√©es pour la corr√©lation.*
