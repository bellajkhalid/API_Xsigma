# Independent Validation Testing

## üß™ **Model Specific Testing**

### **Vue d'Ensemble des Tests**
Cette section pr√©sente les tests de validation ind√©pendants effectu√©s pour v√©rifier le comportement des mod√®les **DBOPT-CorrelationSkew** dans le pricing de produits 2D avec corr√©lation complexe, incluant la validation de la m√©thodologie TermSkew et des copules de corr√©lation.

### **M√©thodologie de Test**
Les tests sont organis√©s en plusieurs phases sp√©cialis√©es :
1. **Tests de Convergence Monte Carlo**
2. **Tests de Corr√©lation et TermSkew**
3. **Tests de Stabilit√© sous Stress**
4. **Tests sous Frameworks R√©glementaires**

---

## üìä **Tests de Convergence Monte Carlo**

### **üîç Test 1 : Convergence des Simulations**

#### **Objectif**
V√©rifier la convergence des simulations Monte Carlo pour les diff√©rentes configurations de mod√®le.

#### **M√©thodologie**
```cpp
// Tests de convergence Monte Carlo dans Our project
class monte_carlo_convergence_tester {
public:
    struct convergence_test_config {
        std::vector<int> simulation_counts = {1000, 5000, 10000, 50000, 100000};
        double convergence_tolerance = 1e-3;
        int num_convergence_tests = 10;
    };
    
    struct convergence_results {
        std::vector<int> simulation_sizes;
        std::vector<double> price_estimates;
        std::vector<double> standard_errors;
        std::vector<double> convergence_rates;
        bool converged;
    };
    
    convergence_results test_price_convergence(
        const correlation_skew_product& product,
        const market_data& market) {
        
        convergence_results results;
        
        // Test de r√©f√©rence avec beaucoup de simulations
        double reference_price = calculate_reference_price(product, market, 1000000);
        
        for (int num_sims : config_.simulation_counts) {
            // Multiples runs pour estimer l'erreur standard
            std::vector<double> price_samples;
            
            for (int run = 0; run < config_.num_convergence_tests; ++run) {
                double price = calculate_price_with_simulations(
                    product, market, num_sims);
                price_samples.push_back(price);
            }
            
            // Statistiques de convergence
            double mean_price = calculate_mean(price_samples);
            double std_error = calculate_standard_error(price_samples);
            double convergence_rate = std::abs(mean_price - reference_price) / reference_price;
            
            results.simulation_sizes.push_back(num_sims);
            results.price_estimates.push_back(mean_price);
            results.standard_errors.push_back(std_error);
            results.convergence_rates.push_back(convergence_rate);
        }
        
        // Validation de la convergence
        results.converged = validate_convergence_pattern(results);
        
        return results;
    }
    
private:
    convergence_test_config config_;
    
    bool validate_convergence_pattern(const convergence_results& results) const {
        // V√©rification que l'erreur diminue avec le nombre de simulations
        for (size_t i = 1; i < results.convergence_rates.size(); ++i) {
            if (results.convergence_rates[i] > results.convergence_rates[i-1] * 1.1) {
                // Tol√©rance de 10% pour fluctuations
                return false;
            }
        }
        
        // V√©rification que la convergence finale est acceptable
        return results.convergence_rates.back() < config_.convergence_tolerance;
    }
};
```
*Cette impl√©mentation C++ dans Our project teste la convergence Monte Carlo avec diff√©rentes tailles d'√©chantillon et validation statistique.*

### **üîç Test 2 : Stabilit√© des Sensibilit√©s**

#### **Tests de Convergence des Greeks**
```cpp
// Tests de convergence des sensibilit√©s dans Our project
class sensitivity_convergence_tester {
public:
    struct sensitivity_test_results {
        std::map<std::string, std::vector<double>> delta_convergence;
        std::map<std::string, std::vector<double>> vega_convergence;
        std::map<std::string, std::vector<double>> correlation_sensitivity_convergence;
        bool all_sensitivities_converged;
    };
    
    sensitivity_test_results test_sensitivity_convergence(
        const correlation_skew_product& product,
        const market_data& market) {
        
        sensitivity_test_results results;
        
        std::vector<int> sim_counts = {10000, 25000, 50000, 100000, 200000};
        
        for (int num_sims : sim_counts) {
            // Calcul des sensibilit√©s avec diff√©rentes tailles d'√©chantillon
            auto sensitivities = calculate_sensitivities_mc(product, market, num_sims);
            
            // Stockage des r√©sultats
            results.delta_convergence["IR_DELTA"].push_back(sensitivities.ir_delta);
            results.delta_convergence["FX_DELTA"].push_back(sensitivities.fx_delta);
            results.delta_convergence["EQ_DELTA"].push_back(sensitivities.eq_delta);
            
            results.vega_convergence["IR_VEGA"].push_back(sensitivities.ir_vega);
            results.vega_convergence["FX_VEGA"].push_back(sensitivities.fx_vega);
            results.vega_convergence["EQ_VEGA"].push_back(sensitivities.eq_vega);
            
            results.correlation_sensitivity_convergence["CORR_SENSITIVITY"].push_back(
                sensitivities.correlation_sensitivity);
        }
        
        // Validation de la convergence pour chaque sensibilit√©
        results.all_sensitivities_converged = validate_all_sensitivities_convergence(results);
        
        return results;
    }
    
private:
    bool validate_all_sensitivities_convergence(
        const sensitivity_test_results& results) const {
        
        // Validation pour chaque type de sensibilit√©
        for (const auto& [sens_name, values] : results.delta_convergence) {
            if (!validate_single_sensitivity_convergence(values)) {
                return false;
            }
        }
        
        for (const auto& [sens_name, values] : results.vega_convergence) {
            if (!validate_single_sensitivity_convergence(values)) {
                return false;
            }
        }
        
        for (const auto& [sens_name, values] : results.correlation_sensitivity_convergence) {
            if (!validate_single_sensitivity_convergence(values)) {
                return false;
            }
        }
        
        return true;
    }
    
    bool validate_single_sensitivity_convergence(
        const std::vector<double>& sensitivity_values) const {
        
        if (sensitivity_values.size() < 3) return false;
        
        // Calcul de la stabilit√© relative
        double final_value = sensitivity_values.back();
        double penultimate_value = sensitivity_values[sensitivity_values.size()-2];
        
        double relative_change = std::abs(final_value - penultimate_value) / 
                               std::max(std::abs(final_value), 1e-10);
        
        return relative_change < 0.05; // 5% de tol√©rance
    }
};
```

---

## üîÑ **Tests de Corr√©lation et TermSkew**

### **üîç Test 1 : Validation de l'Algorithme TermSkew**

#### **Tests de Convergence TermSkew**
```cpp
// Tests sp√©cifiques √† l'algorithme TermSkew dans Our project
class term_skew_validation_tester {
public:
    struct term_skew_test_config {
        matrix<double> target_correlation_matrix;
        int max_iterations = 1000;
        double convergence_tolerance = 1e-6;
        bool smoothing_enabled = true;
    };
    
    struct term_skew_validation_results {
        std::vector<double> iteration_errors;
        matrix<double> final_correlation_matrix;
        matrix<double> empirical_correlation_matrix;
        double final_convergence_error;
        bool algorithm_converged;
        int iterations_used;
    };
    
    term_skew_validation_results validate_term_skew_algorithm(
        const term_skew_test_config& config) {
        
        term_skew_validation_results results;
        
        // Configuration de l'algorithme TermSkew
        term_skew_methodology::term_skew_config ts_config;
        ts_config.max_iterations = config.max_iterations;
        ts_config.convergence_tolerance = config.convergence_tolerance;
        ts_config.smoothing_enabled = config.smoothing_enabled;
        ts_config.correlation_targets = config.target_correlation_matrix;
        
        // Ex√©cution de l'algorithme
        term_skew_methodology methodology;
        auto engine = methodology.create_engine(ts_config);
        auto iteration_history = engine.run_full_calibration();
        
        // Extraction des r√©sultats
        for (const auto& state : iteration_history) {
            results.iteration_errors.push_back(state.convergence_metric);
        }
        
        auto final_state = iteration_history.back();
        results.final_correlation_matrix = final_state.current_correlation_matrix;
        results.final_convergence_error = final_state.convergence_metric;
        results.algorithm_converged = final_state.converged;
        results.iterations_used = final_state.current_iteration;
        
        // Calcul de la corr√©lation empirique
        results.empirical_correlation_matrix = calculate_empirical_correlation_from_pairs(
            final_state.simulated_pairs);
        
        // Validation des r√©sultats
        validate_term_skew_results(results, config);
        
        return results;
    }
    
private:
    void validate_term_skew_results(
        const term_skew_validation_results& results,
        const term_skew_test_config& config) const {
        
        // Validation de la convergence
        EXPECT_TRUE(results.algorithm_converged);
        EXPECT_LT(results.final_convergence_error, config.convergence_tolerance);
        
        // Validation que la corr√©lation finale est proche de la cible
        double correlation_error = calculate_matrix_difference(
            results.final_correlation_matrix, config.target_correlation_matrix);
        EXPECT_LT(correlation_error, 0.01); // 1% de tol√©rance
        
        // Validation que la corr√©lation empirique est coh√©rente
        double empirical_error = calculate_matrix_difference(
            results.empirical_correlation_matrix, config.target_correlation_matrix);
        EXPECT_LT(empirical_error, 0.05); // 5% de tol√©rance pour l'empirique
        
        // Validation de la monotonie de convergence
        validate_convergence_monotonicity(results.iteration_errors);
    }
    
    void validate_convergence_monotonicity(
        const std::vector<double>& iteration_errors) const {
        
        // V√©rification que l'erreur diminue globalement
        if (iteration_errors.size() > 10) {
            double initial_error = iteration_errors[5]; // Apr√®s quelques it√©rations
            double final_error = iteration_errors.back();
            
            EXPECT_LT(final_error, initial_error);
        }
    }
};
```

### **üîç Test 2 : Validation Sticky Strike**

#### **Tests de Corr√©lation D√©pendante des Niveaux**
```cpp
// Tests de validation sticky strike dans Our project
class sticky_strike_validation_tester {
public:
    struct sticky_strike_test_scenario {
        std::vector<double> underlying_1_levels;
        std::vector<double> underlying_2_levels;
        matrix<double> expected_correlation_surface;
        std::string test_description;
    };
    
    void test_sticky_strike_behavior() {
        // Sc√©narios de test
        std::vector<sticky_strike_test_scenario> test_scenarios = {
            create_linear_correlation_scenario(),
            create_smile_correlation_scenario(),
            create_extreme_levels_scenario()
        };
        
        for (const auto& scenario : test_scenarios) {
            validate_single_sticky_strike_scenario(scenario);
        }
    }
    
private:
    void validate_single_sticky_strike_scenario(
        const sticky_strike_test_scenario& scenario) {
        
        // Configuration de la corr√©lation sticky strike
        sticky_strike_correlation::strike_level_mapping mapping;
        mapping.underlying_1_levels = scenario.underlying_1_levels;
        mapping.underlying_2_levels = scenario.underlying_2_levels;
        mapping.correlation_surface = scenario.expected_correlation_surface;
        
        sticky_strike_correlation correlation_model;
        auto interpolator = correlation_model.create_interpolator(mapping);
        
        // Tests d'interpolation
        for (size_t i = 0; i < scenario.underlying_1_levels.size(); ++i) {
            for (size_t j = 0; j < scenario.underlying_2_levels.size(); ++j) {
                double s1 = scenario.underlying_1_levels[i];
                double s2 = scenario.underlying_2_levels[j];
                
                double interpolated_corr = interpolator.get_correlation(s1, s2);
                double expected_corr = scenario.expected_correlation_surface(i, j);
                
                // Validation aux points de grille
                EXPECT_NEAR(interpolated_corr, expected_corr, 1e-10);
            }
        }
        
        // Tests d'interpolation entre points
        test_interpolation_between_grid_points(interpolator, scenario);
        
        // Validation des bornes de corr√©lation
        EXPECT_TRUE(interpolator.validate_correlation_bounds());
    }
    
    sticky_strike_test_scenario create_linear_correlation_scenario() {
        sticky_strike_test_scenario scenario;
        scenario.test_description = "Linear correlation surface";
        
        scenario.underlying_1_levels = {80.0, 90.0, 100.0, 110.0, 120.0};
        scenario.underlying_2_levels = {0.8, 0.9, 1.0, 1.1, 1.2};
        
        // Corr√©lation lin√©aire : plus les niveaux sont √©lev√©s, plus la corr√©lation est forte
        scenario.expected_correlation_surface = matrix<double>(5, 5);
        for (size_t i = 0; i < 5; ++i) {
            for (size_t j = 0; j < 5; ++j) {
                double base_corr = 0.3;
                double level_effect = 0.1 * (i + j) / 4.0;
                scenario.expected_correlation_surface(i, j) = base_corr + level_effect;
            }
        }
        
        return scenario;
    }
};
```

---

## üèõÔ∏è **Tests sous Frameworks R√©glementaires**

### **üîç CCAR Testing avec Corr√©lations**

#### **Tests de Stress Corr√©lation sous CCAR**
```cpp
// Tests CCAR avec corr√©lations dans Our project
class ccar_correlation_testing_framework {
public:
    struct ccar_correlation_scenario {
        std::string scenario_name;
        std::vector<market_data_snapshot> quarterly_snapshots;
        matrix<double> stressed_correlation_matrix;
        std::string stress_description;
    };
    
    void run_ccar_correlation_tests(
        const correlation_skew_product& product) {
        
        // Sc√©narios CCAR avec stress de corr√©lation
        std::vector<ccar_correlation_scenario> scenarios = {
            create_baseline_correlation_scenario(),
            create_severely_adverse_correlation_scenario(),
            create_adverse_correlation_scenario()
        };
        
        for (const auto& scenario : scenarios) {
            test_product_under_ccar_correlation_stress(product, scenario);
        }
    }
    
private:
    void test_product_under_ccar_correlation_stress(
        const correlation_skew_product& product,
        const ccar_correlation_scenario& scenario) {
        
        std::cout << "Testing CCAR scenario: " << scenario.scenario_name << std::endl;
        
        for (int quarter = 1; quarter <= 9; ++quarter) {
            const auto& market_data = scenario.quarterly_snapshots[quarter-1];
            
            // Application du stress de corr√©lation
            auto stressed_market = apply_correlation_stress(
                market_data, scenario.stressed_correlation_matrix);
            
            // Calcul des m√©triques sous stress
            double pv = product.calculate_pv(stressed_market);
            auto sensitivities = product.calculate_sensitivities(stressed_market);
            
            // Validation de stabilit√©
            EXPECT_TRUE(std::isfinite(pv));
            EXPECT_TRUE(validate_sensitivities_finite(sensitivities));
            
            // Tests de coh√©rence
            validate_correlation_stress_coherence(
                product, market_data, stressed_market, scenario);
            
            // Documentation des r√©sultats
            document_ccar_correlation_results(
                scenario.scenario_name, quarter, pv, sensitivities);
        }
    }
    
    ccar_correlation_scenario create_severely_adverse_correlation_scenario() {
        ccar_correlation_scenario scenario;
        scenario.scenario_name = "CCAR 2023 Severely Adverse with Correlation Stress";
        scenario.stress_description = "Increased correlations during stress periods";
        
        // Matrice de corr√©lation stress√©e (corr√©lations plus √©lev√©es)
        scenario.stressed_correlation_matrix = matrix<double>(2, 2);
        scenario.stressed_correlation_matrix(0, 0) = 1.0;
        scenario.stressed_correlation_matrix(0, 1) = 0.8;  // Augment√© de 0.5 √† 0.8
        scenario.stressed_correlation_matrix(1, 0) = 0.8;
        scenario.stressed_correlation_matrix(1, 1) = 1.0;
        
        // Chargement des donn√©es de march√© CCAR
        scenario.quarterly_snapshots = load_ccar_severely_adverse_data();
        
        return scenario;
    }
};
```

### **üîç IRRBB Testing avec Multi-Assets**

#### **Tests IRRBB pour Produits Multi-Actifs**
```cpp
// Tests IRRBB pour produits corr√©l√©s dans Our project
class irrbb_multiasset_testing_framework {
public:
    void run_irrbb_multiasset_tests(
        const correlation_skew_product& product,
        const market_data& base_market) {
        
        // Sc√©narios IRRBB adapt√©s pour multi-actifs
        std::vector<irrbb_multiasset_scenario> scenarios = {
            create_parallel_shift_multiasset_scenario(200),    // +200bp
            create_parallel_shift_multiasset_scenario(-200),   // -200bp
            create_steepener_multiasset_scenario(),
            create_flattener_multiasset_scenario(),
            create_fx_stress_scenario(),
            create_equity_stress_scenario()
        };
        
        double base_eve = calculate_economic_value_equity(product, base_market);
        
        for (const auto& scenario : scenarios) {
            auto stressed_market = apply_irrbb_multiasset_scenario(
                base_market, scenario);
            
            double stressed_eve = calculate_economic_value_equity(
                product, stressed_market);
            
            double delta_eve = stressed_eve - base_eve;
            double eve_ratio = std::abs(delta_eve) / base_eve;
            
            // Validation contre limites r√©glementaires adapt√©es
            validate_irrbb_multiasset_limits(scenario.name, eve_ratio);
            
            // Tests de stabilit√© des corr√©lations sous stress
            test_correlation_stability_under_irrbb(
                product, stressed_market, scenario);
        }
    }
    
private:
    struct irrbb_multiasset_scenario {
        std::string name;
        std::map<std::string, double> ir_shocks;
        std::map<std::string, double> fx_shocks;
        std::map<std::string, double> equity_shocks;
        matrix<double> correlation_adjustments;
    };
    
    void test_correlation_stability_under_irrbb(
        const correlation_skew_product& product,
        const market_data& stressed_market,
        const irrbb_multiasset_scenario& scenario) {
        
        // V√©rification que les corr√©lations restent dans des limites raisonnables
        auto correlation_matrix = extract_correlation_matrix(stressed_market);
        
        // Validation des bornes
        for (size_t i = 0; i < correlation_matrix.rows(); ++i) {
            for (size_t j = 0; j < correlation_matrix.columns(); ++j) {
                double corr = correlation_matrix(i, j);
                EXPECT_GE(corr, -1.0);
                EXPECT_LE(corr, 1.0);
                
                if (i == j) {
                    EXPECT_NEAR(corr, 1.0, 1e-10);
                }
            }
        }
        
        // Validation de la positivit√© semi-d√©finie
        EXPECT_TRUE(is_positive_semidefinite(correlation_matrix));
    }
};
```

---

## üìä **Tests de Validation Crois√©e**

### **üîç Validation contre Mod√®les Alternatifs**

#### **Comparaison avec Copules Standard**
```cpp
// Validation crois√©e avec copules standard dans Our project
class cross_validation_tester {
public:
    struct cross_validation_results {
        std::map<std::string, double> model_prices;
        std::map<std::string, std::vector<double>> model_sensitivities;
        std::map<std::string, double> pricing_differences;
        std::string recommended_model;
    };
    
    cross_validation_results compare_correlation_models(
        const correlation_skew_product& product,
        const market_data& market) {
        
        cross_validation_results results;
        
        // Mod√®les √† comparer
        std::vector<std::string> models = {
            "TERMSKEW",
            "GAUSSIAN_COPULA",
            "GUMBEL_COPULA",
            "CLAYTON_COPULA"
        };
        
        for (const auto& model_name : models) {
            // Configuration du mod√®le
            auto model_config = create_model_configuration(model_name);
            
            // Pricing avec le mod√®le
            double price = price_with_correlation_model(
                product, market, model_config);
            results.model_prices[model_name] = price;
            
            // Calcul des sensibilit√©s
            auto sensitivities = calculate_sensitivities_with_model(
                product, market, model_config);
            results.model_sensitivities[model_name] = sensitivities;
        }
        
        // Analyse des diff√©rences
        analyze_model_differences(results);
        
        // Recommandation bas√©e sur la validation
        results.recommended_model = determine_recommended_model(results);
        
        return results;
    }
    
private:
    void analyze_model_differences(cross_validation_results& results) {
        double termskew_price = results.model_prices["TERMSKEW"];
        
        for (const auto& [model_name, price] : results.model_prices) {
            if (model_name != "TERMSKEW") {
                double relative_diff = std::abs(price - termskew_price) / 
                                     std::abs(termskew_price);
                results.pricing_differences[model_name] = relative_diff;
            }
        }
    }
};
```

---

*Cette section fournit une documentation compl√®te des tests de validation ind√©pendants pour les mod√®les DBOPT-CorrelationSkew, int√©grant les impl√©mentations C++ de Our project avec des m√©thodologies de test sp√©cialis√©es pour la corr√©lation et les frameworks r√©glementaires.*
