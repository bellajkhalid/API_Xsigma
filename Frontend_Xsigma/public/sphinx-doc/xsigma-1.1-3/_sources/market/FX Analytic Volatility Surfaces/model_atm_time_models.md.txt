# ATM Time Models
## Advanced Temporal Interpolation Framework for FX Volatility Surfaces

![ATM Time Models Overview](Fig/5.png)

### üéØ **ATM Temporal Models Excellence Overview**

The **ATM Temporal Models** framework represents the sophisticated mathematical foundation for constructing volatility smiles at arbitrary maturities within Our project's FX volatility surface system. This advanced framework determines how volatility surfaces are interpolated across time, providing the critical bridge between liquid market tenors and the complete volatility surface required for comprehensive FX options pricing.

### üßÆ **Mathematical Foundation and Business Purpose**

#### **üé™ Core Temporal Interpolation Challenge**
After calibrating smile models for a set of marked tenors $T_i$, the framework constructs accurate volatility smiles for any maturity $T$ not included in the liquid tenor set. The sophisticated approach involves:

1. **üìä Multi-Quote Interpolation**: Temporal interpolation of 3 or 5 key quotes (ATM plus 25Œî/10Œî strikes)
2. **üéØ Smile Reconstruction**: Construction of complete smile model for target expiration $T$
3. **üîÑ Consistency Maintenance**: Ensuring arbitrage-free interpolation across all maturities

#### **üéõÔ∏è Critical Market Distinction**
ATM temporal interpolation employs **specialized methodologies** distinct from wing quote interpolation, constituting the primary differentiator between short-term and long-term surface construction approaches.

### üíº **Business Impact and Applications**

| **Application** | **Business Function** | **Performance Benefit** | **Risk Management Value** |
|-----------------|----------------------|------------------------|---------------------------|
| **Intraday Pricing** | Real-time option valuation | Sub-millisecond evaluation | Accurate mark-to-market |
| **Risk Calculation** | Greeks computation | Smooth risk metrics | Stable hedging ratios |
| **Exotic Products** | Complex payoff pricing | Consistent surface behavior | Reliable exotic valuation |
| **Portfolio Management** | Multi-maturity analysis | Unified framework | Comprehensive risk view |

---

## üîß **Advanced ATM Temporal Model Architecture**

![ATM Model Types](Fig/6.png)

### üìä **Sophisticated Model Type Specification**

Our framework employs **two specialized temporal models** optimized for different market segments and trading requirements:

#### **üéØ Complete Model Comparison Framework**

| **Model Type** | **Target Segment** | **Mathematical Approach** | **Market Sensitivity** | **Key Features** | **Performance** |
|----------------|-------------------|---------------------------|------------------------|------------------|-----------------|
| **Variance Interpolation (VI)** | Long-term surfaces | Smooth variance interpolation | Event-independent | Stability-focused | High computational efficiency |
| **Mean-Reverting (MR)** | Short-term surfaces | Mean-reverting backbone | Event-sensitive | Real-time adaptation | Ultra-fast recalibration |

#### **üîß Variance Interpolation (VI) Model - Long-Term Excellence**

**Institutional-Grade Long-Term Framework:**
- **üéØ Primary Usage**: Long-term surfaces (T ‚â• 2 years) for institutional products
- **üßÆ Mathematical Approach**: Sophisticated smooth variance interpolation with stability guarantees
- **üìä Market Characteristic**: Filtered from short-term economic noise for stable long-term pricing
- **‚ö° Performance**: Optimized for large-scale portfolio calculations and risk management

```cpp
// Our project VI Model implementation
namespace xsigma::fx {
    class VarianceInterpolationATMModel {
    public:
        // Long-term stability framework
        struct LongTermStabilityConfig {
            InterpolationType variance_method;           // Linear, cubic spline
            bool noise_filtering_enabled;               // Economic event filtering
            double stability_threshold;                 // Variance stability control
            std::vector<double> long_term_anchors;      // 2-40 year structure

            // Institutional requirements
            bool regulatory_compliance;                 // Basel III compliance
            double minimum_variance_level;              // Floor for variance
            bool extrapolation_bounds_check;            // Safe extrapolation
        };
    };
}
```

#### **üîß Mean-Reverting (MR) Model - Short-Term Precision**

**Event-Driven Short-Term Framework:**
- **üéØ Primary Usage**: Short-term surfaces (T < 2 years) for active trading operations
- **üßÆ Mathematical Approach**: Mean-reverting backbone with sophisticated event impact modeling
- **üìä Market Characteristic**: Captures and quantifies economic and political event impacts
- **‚ö° Performance**: Sub-millisecond recalibration for real-time trading applications

```cpp
// Our project MR Model implementation
namespace xsigma::fx {
    class MeanRevertingATMModel {
    public:
        // Event-sensitive framework
        struct EventSensitiveConfig {
            double mean_reversion_speed;                // Speed of reversion to long-term mean
            double long_term_mean_level;                // Long-term volatility equilibrium
            std::vector<EconomicEvent> scheduled_events; // FOMC, ECB, BOE meetings
            std::vector<PoliticalEvent> political_events; // Brexit, elections, etc.

            // Real-time event processing
            bool real_time_event_integration;          // Live event impact
            EventImpactModel impact_quantifier;        // Event impact calculation
            double event_decay_rate;                   // Impact decay modeling
            bool weekend_holiday_adjustment;           // Calendar effect handling
        };
    };
}
```

*This dual-model architecture ensures optimal performance across all market conditions while maintaining the mathematical rigor required for institutional FX options trading.*

### **Implementation in Our Project**

#### **üîß ATM Temporal Models Framework**
```cpp
// ATM temporal models framework in Our project
class fx_atm_time_model_framework {
public:
    enum class atm_time_model_type {
        VARIANCE_INTERPOLATION,  // VI - Long term
        MEAN_REVERTING          // MR - Short term
    };
    
    struct atm_time_calibration_inputs {
        std::vector<double> tenor_grid;
        std::vector<double> atm_volatilities;
        std::vector<double> market_rates_domestic;
        std::vector<double> market_rates_foreign;
        std::map<std::string, double> economic_events; // Date -> Impact
        bool weekend_holiday_adjustment;
    };
    
    class atm_time_model_base {
    protected:
        atm_time_model_type type_;
        atm_time_calibration_inputs inputs_;
        
    public:
        atm_time_model_base(atm_time_model_type type) : type_(type) {}
        
        virtual void calibrate(const atm_time_calibration_inputs& inputs) = 0;
        virtual double get_atm_volatility(double time_to_expiry) const = 0;
        virtual double get_daily_volatility(const std::string& date) const = 0;
        
        atm_time_model_type get_type() const { return type_; }
    };
    
    class variance_interpolation_model : public atm_time_model_base {
    private:
        std::vector<double> variance_curve_;
        std::vector<double> time_grid_;
        interpolation_type interp_type_;
        
    public:
        variance_interpolation_model(interpolation_type interp = interpolation_type::LINEAR_VARIANCE)
            : atm_time_model_base(atm_time_model_type::VARIANCE_INTERPOLATION),
              interp_type_(interp) {}
        
        void calibrate(const atm_time_calibration_inputs& inputs) override {
            inputs_ = inputs;
            time_grid_ = inputs.tenor_grid;
            
            // Convert volatilities to variances
            variance_curve_.clear();
            for (size_t i = 0; i < inputs.atm_volatilities.size(); ++i) {
                double vol = inputs.atm_volatilities[i];
                double time = inputs.tenor_grid[i];
                double variance = vol * vol * time;
                variance_curve_.push_back(variance);
            }
        }
        
        double get_atm_volatility(double time_to_expiry) const override {
            // Variance interpolation then conversion to volatility
            double interpolated_variance = interpolate_variance(time_to_expiry);

            if (time_to_expiry <= 0.0) {
                return 0.0;
            }

            return std::sqrt(interpolated_variance / time_to_expiry);
        }

        double get_daily_volatility(const std::string& date) const override {
            // For VI, no daily granularity - use standard interpolation
            double time_to_date = calculate_time_to_date(date);
            return get_atm_volatility(time_to_date);
        }
        
    private:
        double interpolate_variance(double time_to_expiry) const {
            switch (interp_type_) {
                case interpolation_type::LINEAR_VARIANCE:
                    return linear_interpolate_variance(time_to_expiry);
                case interpolation_type::CUBIC_VARIANCE:
                    return cubic_interpolate_variance(time_to_expiry);
                default:
                    return linear_interpolate_variance(time_to_expiry);
            }
        }
        
        double linear_interpolate_variance(double time_to_expiry) const {
            // Linear interpolation in variance
            if (time_to_expiry <= time_grid_.front()) {
                return variance_curve_.front();
            }
            if (time_to_expiry >= time_grid_.back()) {
                return variance_curve_.back();
            }

            // Search for interval
            auto it = std::lower_bound(time_grid_.begin(), time_grid_.end(), time_to_expiry);
            size_t idx = std::distance(time_grid_.begin(), it);

            if (idx == 0) idx = 1;

            double t1 = time_grid_[idx - 1];
            double t2 = time_grid_[idx];
            double v1 = variance_curve_[idx - 1];
            double v2 = variance_curve_[idx];

            // Linear interpolation
            double weight = (time_to_expiry - t1) / (t2 - t1);
            return v1 + weight * (v2 - v1);
        }
    };
    
    class mean_reverting_model : public atm_time_model_base {
    private:
        struct mr_parameters {
            std::vector<double> backbone_volatilities;
            std::vector<double> backbone_times;
            std::map<std::string, double> event_weights;
            std::map<std::string, double> offset_parameters;
            double mean_reversion_speed;
            double long_term_volatility;
        };
        
        mr_parameters params_;
        
    public:
        mean_reverting_model() : atm_time_model_base(atm_time_model_type::MEAN_REVERTING) {}
        
        void calibrate(const atm_time_calibration_inputs& inputs) override {
            inputs_ = inputs;

            // Calibrate mean-reverting backbone
            calibrate_backbone(inputs);

            // Calibrate economic events
            calibrate_economic_events(inputs);

            // Calibrate offset parameters
            calibrate_offset_parameters(inputs);
        }
        
        double get_atm_volatility(double time_to_expiry) const override {
            // Mean-reverting model: vol(t) = vol_LT + (vol_0 - vol_LT) * exp(-a*t)
            double vol_0 = params_.backbone_volatilities.front();
            double vol_LT = params_.long_term_volatility;
            double a = params_.mean_reversion_speed;

            double mr_vol = vol_LT + (vol_0 - vol_LT) * std::exp(-a * time_to_expiry);

            // Event adjustment (if applicable)
            double event_adjustment = calculate_event_adjustment(time_to_expiry);

            return mr_vol + event_adjustment;
        }
        
        double get_daily_volatility(const std::string& date) const override {
            double time_to_date = calculate_time_to_date(date);
            double base_vol = get_atm_volatility(time_to_date);

            // Date-specific adjustment
            double daily_adjustment = 0.0;

            // Economic/business events
            if (params_.event_weights.find(date) != params_.event_weights.end()) {
                daily_adjustment += params_.event_weights.at(date);
            }

            // Weekend/holiday adjustment
            if (inputs_.weekend_holiday_adjustment && is_weekend_or_holiday(date)) {
                daily_adjustment -= 0.05; // Volatility reduction
            }

            return base_vol + daily_adjustment;
        }
        
    private:
        void calibrate_backbone(const atm_time_calibration_inputs& inputs) {
            // Calibrate mean-reverting backbone to market tenors
            params_.backbone_times = inputs.tenor_grid;
            params_.backbone_volatilities = inputs.atm_volatilities;

            // Estimate mean-reverting parameters
            estimate_mean_reversion_parameters();
        }
        
        void estimate_mean_reversion_parameters() {
            // Least squares estimation of parameters a and vol_LT
            const size_t n = params_.backbone_volatilities.size();

            if (n < 2) {
                params_.mean_reversion_speed = 0.1;
                params_.long_term_volatility = params_.backbone_volatilities.back();
                return;
            }

            // Non-linear regression method to estimate a and vol_LT
            auto objective = [this](const std::vector<double>& params) {
                double a = params[0];
                double vol_LT = params[1];
                double vol_0 = params_.backbone_volatilities.front();

                double sse = 0.0;
                for (size_t i = 0; i < params_.backbone_times.size(); ++i) {
                    double t = params_.backbone_times[i];
                    double market_vol = params_.backbone_volatilities[i];
                    double model_vol = vol_LT + (vol_0 - vol_LT) * std::exp(-a * t);

                    sse += (market_vol - model_vol) * (market_vol - model_vol);
                }

                return sse;
            };

            // Optimization (simplified implementation)
            std::vector<double> initial_guess = {0.1, params_.backbone_volatilities.back()};
            auto optimized_params = optimize_parameters(objective, initial_guess);

            params_.mean_reversion_speed = optimized_params[0];
            params_.long_term_volatility = optimized_params[1];
        }
        
        void calibrate_economic_events(const atm_time_calibration_inputs& inputs) {
            // Calibrate economic event weights
            params_.event_weights = inputs.economic_events;

            // Validation and normalization of weights
            for (auto& [date, weight] : params_.event_weights) {
                // Constraints on event weights
                weight = std::max(-0.2, std::min(weight, 0.5)); // Between -20% and +50%
            }
        }

        double calculate_event_adjustment(double time_to_expiry) const {
            // Calculate average event adjustment over the period
            double total_adjustment = 0.0;
            int event_count = 0;

            for (const auto& [date, weight] : params_.event_weights) {
                double event_time = calculate_time_to_date(date);
                if (event_time <= time_to_expiry) {
                    total_adjustment += weight;
                    event_count++;
                }
            }

            return (event_count > 0) ? (total_adjustment / event_count) : 0.0;
        }

        bool is_weekend_or_holiday(const std::string& date) const {
            // Simplified implementation - calendar verification
            // In practice, would use a complete market calendar
            return false; // Placeholder
        }
    };
};
```
*This C++ implementation in Our project shows the two main approaches for ATM temporal models: Variance Interpolation for long-term and Mean-Reverting for short-term.*

---

## üìà **Variance Interpolation Model (VI)**

### **Main Characteristics**
- **Simplicity**: Linear or cubic interpolation in variance
- **Smoothing**: No information on fine economic events
- **Usage**: Long-term surfaces (20-40 years)
- **Justification**: Fine ATM backbone structure not necessary for long-term products

### **Advantages**
- **Marking simplicity**: Easy to mark and manage daily
- **Stability**: Smooth interpolation without discontinuities
- **Performance**: Fast and efficient calculations

### **Interpolation Methods**
- **Linear in Variance**: Simple linear interpolation
- **Cubic in Variance**: Cubic interpolation for more smoothing

---

## üéØ **Mean-Reverting Model (MR)**

### **Main Characteristics**
- **Daily granularity**: Precise marking of daily volatility
- **Economic events**: Capture of important event effects
- **Temporal adjustments**: Weekends and holidays with reduced volatility
- **Usage**: Short-term surfaces (up to 3 years)

### **Business Justification**
The FX market is very liquid and the short-term options business requires precise marking of daily volatility. Certain days with important economic and business events have more volatility, while weekends and holidays have less.

### **Types of Events Captured**
- **Monetary policy meetings**: FOMC, ECB, BOJ
- **Economic indicators**: NFP, GDP, CPI, PMI
- **Political events**: Elections, Brexit, trade wars
- **Corporate announcements**: Important company results

### **Model Parameters**
- **Mean reversion speed**: $a$ (typically 0.05 - 0.5)
- **Long-term volatility**: $\sigma_{LT}$ (equilibrium level)
- **Initial volatility**: $\sigma_0$ (current level)
- **Event weights**: Date-specific adjustments

---

## üîß **Approach Comparison**

### **Comparative Table**

| **Aspect** | **Variance Interpolation (VI)** | **Mean-Reverting (MR)** |
|------------|--------------------------------|--------------------------|
| **Maturity** | 20-40 years | Up to 3 years |
| **Granularity** | Monthly/Quarterly | Daily |
| **Events** | No | Yes |
| **Complexity** | Low | High |
| **Maintenance** | Simple | Intensive |
| **ST Precision** | Moderate | High |
| **LT Stability** | High | Moderate |

### **Model Choice**
- **VI**: Preferred for long-term products where fine granularity is not critical
- **MR**: Necessary for short-term trading where every day counts
- **Hybrid**: Possible combination for extended surfaces

---

*This section details the two main approaches for ATM temporal modeling, integrating Our project best practices with business considerations specific to different FX market segments.*
