# Control Assessment

## Ongoing Performance Monitoring

Le monitoring de performance du modèle s'appuie sur des indicateurs de performance définis par les Product Owners, les utilisateurs de modèles produits ou les fonctions de contrôle selon les besoins, pour confirmer que le modèle fonctionne comme prévu.

```cpp
// Implémentation Our project du système de contrôle pour Short Rate Normal
namespace xsigma {
    // Classe principale pour l'évaluation des contrôles Short Rate Normal
    class ShortRateNormalControlAssessment {
    public:
        // Énumération des types d'indicateurs de performance
        enum class PerformanceIndicatorType {
            UNEXPLAINED_PL,               // P&L inexpliqué
            MODEL_RESERVES,               // Réserves modèle
            IPV_TESTING,                  // Tests IPV
            RISK_INSTABILITIES,           // Instabilités de risque
            HEDGING_PERFORMANCE,          // Performance de hedging
            CALIBRATION_FAILURES,         // Échecs de calibration
            PRICING_AUCTION_RESULTS,      // Résultats d'enchères de pricing
            COLLATERAL_DISPUTES          // Disputes de collatéral
        };
        
        // Structure pour les indicateurs de performance
        struct PerformanceIndicator {
            PerformanceIndicatorType type;        // Type d'indicateur
            std::string name;                     // Nom de l'indicateur
            double current_value;                 // Valeur actuelle
            double threshold_warning;             // Seuil d'alerte
            double threshold_critical;            // Seuil critique
            std::string measurement_unit;         // Unité de mesure
            std::string monitoring_frequency;     // Fréquence de monitoring
            bool auto_trigger_scrutiny;          // Déclenchement automatique d'examen
            std::string description;              // Description
        };
        
        // Structure pour les règles de contrôle des paramètres
        struct ParameterControlRule {
            int cfu_id;                          // ID de la condition d'utilisation
            std::string monitoring_method;        // Méthode de monitoring
            std::string rule_name;               // Nom de la règle
            std::string status;                  // Statut (Released)
            std::string business_area;           // Domaine d'activité
            std::string last_change_date;        // Dernière date de modification
            std::string param_info_date;         // Date d'info paramètre
            std::string parameter_constraint;    // Contrainte du paramètre
        };
        
        // Système de monitoring de performance
        class PerformanceMonitoringSystem {
        public:
            // Obtenir tous les indicateurs de performance
            std::vector<PerformanceIndicator> get_performance_indicators() const {
                return {
                    {
                        PerformanceIndicatorType::UNEXPLAINED_PL,
                        "Unexplained P&L due to model issues",
                        0.0, 500000.0, 1000000.0, "EUR", "Daily", false,
                        "P&L inexpliqué dû aux problèmes de modèle"
                    },
                    {
                        PerformanceIndicatorType::MODEL_RESERVES,
                        "Model reserves at product-model pair level",
                        0.0, 500000.0, 1000000.0, "EUR", "Monthly", true,
                        "Taille relative des réserves modèle (relative à PV et/ou nombre de trades). "
                        "Changements mois-sur-mois > 1M EUR déclenchent automatiquement un examen"
                    },
                    {
                        PerformanceIndicatorType::IPV_TESTING,
                        "VRM output price testing results through IPV",
                        0.98, 0.95, 0.90, "Success Rate", "Daily", false,
                        "Résultats des tests de prix de sortie VRM via processus IPV"
                    },
                    {
                        PerformanceIndicatorType::RISK_INSTABILITIES,
                        "Risk instabilities produced by models",
                        0, 3, 5, "Count", "Daily", false,
                        "Identification des instabilités de risque produites par les modèles"
                    },
                    {
                        PerformanceIndicatorType::HEDGING_PERFORMANCE,
                        "Hedging performance feedback",
                        0.95, 0.90, 0.85, "Effectiveness", "Weekly", false,
                        "Feedback sur la performance de hedging"
                    },
                    {
                        PerformanceIndicatorType::CALIBRATION_FAILURES,
                        "Calibration failures",
                        0, 2, 5, "Count", "Daily", false,
                        "Échecs de calibration du modèle"
                    },
                    {
                        PerformanceIndicatorType::PRICING_AUCTION_RESULTS,
                        "Pricing auction results successes",
                        0.98, 0.95, 0.90, "Success Rate", "Monthly", false,
                        "Succès des résultats d'enchères de pricing"
                    },
                    {
                        PerformanceIndicatorType::COLLATERAL_DISPUTES,
                        "Significant collateral disputes due to model",
                        0, 1, 3, "Count", "Monthly", false,
                        "Disputes de collatéral significatives dues aux problèmes de modèle"
                    }
                };
            }
            
            // Monitoring automatique des indicateurs
            std::map<std::string, bool> monitor_all_indicators() const {
                std::map<std::string, bool> monitoring_results;
                auto indicators = get_performance_indicators();
                
                for (const auto& indicator : indicators) {
                    bool within_warning = indicator.current_value <= indicator.threshold_warning;
                    bool within_critical = indicator.current_value <= indicator.threshold_critical;
                    
                    if (!within_critical) {
                        XSIGMA_LOG_CRITICAL("Indicateur " + indicator.name + 
                                           " dépasse le seuil critique: " + 
                                           std::to_string(indicator.current_value));
                        monitoring_results[indicator.name] = false;
                        
                        // Déclenchement automatique d'examen pour réserves > 1M EUR
                        if (indicator.auto_trigger_scrutiny && 
                            indicator.current_value > 1000000.0) {
                            trigger_automatic_scrutiny(indicator);
                        }
                    } else if (!within_warning) {
                        XSIGMA_LOG_WARNING("Indicateur " + indicator.name + 
                                          " dépasse le seuil d'alerte: " + 
                                          std::to_string(indicator.current_value));
                        monitoring_results[indicator.name] = false;
                    } else {
                        monitoring_results[indicator.name] = true;
                    }
                }
                
                return monitoring_results;
            }
            
            // Génération de rapport pour MCWGs
            std::string generate_mcwg_report() const {
                std::ostringstream report;
                
                report << "=== RAPPORT MCWG - MODÈLE SHORT RATE NORMAL ===\n\n";
                
                // Section indicateurs de performance
                report << "## Indicateurs de Performance\n";
                auto indicators = get_performance_indicators();
                for (const auto& indicator : indicators) {
                    std::string status = (indicator.current_value <= indicator.threshold_warning) ? 
                                       "✅ OK" : "❌ ALERTE";
                    report << "- " << indicator.name << ": " 
                           << indicator.current_value << " " << indicator.measurement_unit 
                           << " " << status << "\n";
                }
                
                // Section activités de monitoring
                report << "\n## Activités de Monitoring\n";
                report << "- P&L inexpliqué: Surveillance continue des écarts\n";
                report << "- Réserves modèle: Monitoring mensuel avec déclenchement automatique > 1M EUR\n";
                report << "- Tests IPV: Validation croisée quotidienne\n";
                report << "- Instabilités de risque: Détection automatique\n";
                report << "- Performance de hedging: Feedback hebdomadaire\n";
                report << "- Échecs de calibration: Surveillance quotidienne\n";
                report << "- Résultats d'enchères: Monitoring mensuel\n";
                report << "- Disputes de collatéral: Surveillance mensuelle\n";
                
                // Section attestation annuelle
                report << "\n## Attestation Annuelle\n";
                report << "- Préparation des données pour attestation\n";
                report << "- Présentation aux MCWGs\n";
                report << "- Documentation des exceptions et actions correctives\n";
                
                return report.str();
            }
            
        private:
            void trigger_automatic_scrutiny(const PerformanceIndicator& indicator) const {
                XSIGMA_LOG_CRITICAL("Déclenchement automatique d'examen pour " + 
                                   indicator.name + 
                                   " - Changement > 1M EUR détecté");
                
                // Notification automatique aux équipes de contrôle
                // Génération de rapport d'exception
                // Escalation vers les MCWGs
            }
        };
        
        // Système de contrôle des paramètres
        class ParameterControlSystem {
        public:
            // Obtenir toutes les règles de contrôle pour le modèle Short Rate Normal
            std::vector<ParameterControlRule> get_control_rules() const {
                return {
                    // Règles principales d'inflation (sélection)
                    {1320, "Model Rule", "Inflation0002", "Released", "INFLATION", "2019-08-07", "2014-07-13", "Contrainte paramètre inflation"},
                    {1321, "Model Rule", "Inflation0003", "Released", "INFLATION", "2018-11-09", "2014-07-10", "Contrainte paramètre inflation"},
                    
                    // Règles récentes (2020-2021)
                    {11910, "Model Rule", "Inflation0061", "Released", "INFLATION", "2020-08-18", "2019-06-27", "Contrainte paramètre inflation"},
                    {11911, "Model Rule", "Inflation0062", "Released", "INFLATION", "2020-08-18", "2019-06-27", "Contrainte paramètre inflation"},
                    {11912, "Model Rule", "Inflation0063", "Released", "INFLATION", "2020-08-18", "2017-06-28", "Contrainte paramètre inflation"},
                    {11913, "Model Rule", "Inflation0064", "Released", "INFLATION", "2020-08-18", "2019-07-27", "Contrainte paramètre inflation"},
                    {11914, "Model Rule", "Inflation0065", "Released", "INFLATION", "2020-08-18", "2020-08-12", "Contrainte paramètre inflation"},
                    
                    // Règles spécialisées
                    {11963, "Model Rule", "Inflation0114", "Released", "FX", "2020-08-18", "2019-09-13", "Contrainte paramètre FX"},
                    {15339, "Model Rule", "Inflation0155", "Released", "INFLATION", "2020-09-29", "2020-08-31", "Contrainte paramètre inflation"},
                    {15343, "Model Rule", "Inflation0159", "Released", "FX", "2020-09-29", "2019-06-27", "Contrainte paramètre FX"},
                    
                    // Règles de taux
                    {17046, "Model Rule", "Rates0402", "Released", "RATES", "2020-12-16", "2020-09-09", "Contrainte paramètre taux"},
                    {17047, "Model Rule", "Rates0403", "Released", "RATES", "2020-12-16", "2020-08-15", "Contrainte paramètre taux"},
                    {17048, "Model Rule", "Rates0404", "Released", "RATES", "2020-12-16", "2020-08-15", "Contrainte paramètre taux"}
                };
            }
            
            // Validation en temps réel des paramètres
            bool validate_parameter_rule(int cfu_id, const std::string& parameter_value) const {
                auto rules = get_control_rules();
                
                for (const auto& rule : rules) {
                    if (rule.cfu_id == cfu_id) {
                        // Validation selon la contrainte spécifique
                        bool is_valid = validate_constraint(rule.parameter_constraint, parameter_value);
                        
                        if (is_valid) {
                            XSIGMA_LOG_DEBUG("Paramètre validé selon la règle " + std::to_string(cfu_id));
                        } else {
                            XSIGMA_LOG_ERROR("Paramètre " + parameter_value + 
                                            " non conforme à la règle " + std::to_string(cfu_id));
                        }
                        
                        return is_valid;
                    }
                }
                
                XSIGMA_LOG_WARNING("Règle " + std::to_string(cfu_id) + " non trouvée");
                return false; // Règle non trouvée = échec de validation
            }
            
            // Audit complet des paramètres
            std::map<int, bool> audit_all_parameters(
                const ShortRateNormalModel& model) const {
                
                std::map<int, bool> audit_results;
                auto rules = get_control_rules();
                
                for (const auto& rule : rules) {
                    try {
                        // Récupérer la valeur actuelle du paramètre
                        std::string current_value = model.get_parameter_value_by_rule(rule.rule_name);
                        
                        // Valider selon la règle
                        bool is_valid = validate_parameter_rule(rule.cfu_id, current_value);
                        audit_results[rule.cfu_id] = is_valid;
                        
                        if (!is_valid) {
                            XSIGMA_LOG_ERROR("Échec audit paramètre " + rule.rule_name + 
                                            " selon règle " + std::to_string(rule.cfu_id));
                        }
                        
                    } catch (const std::exception& e) {
                        XSIGMA_LOG_ERROR("Erreur audit règle " + std::to_string(rule.cfu_id) + 
                                        ": " + e.what());
                        audit_results[rule.cfu_id] = false;
                    }
                }
                
                return audit_results;
            }
            
            // Statistiques des règles de contrôle
            struct ControlRuleStatistics {
                int total_rules;                     // Total des règles
                int inflation_rules;                 // Règles d'inflation
                int fx_rules;                       // Règles FX
                int rates_rules;                    // Règles de taux
                std::string most_recent_change;     // Changement le plus récent
                std::string oldest_param_info;      // Info paramètre la plus ancienne
            };
            
            ControlRuleStatistics get_rule_statistics() const {
                auto rules = get_control_rules();
                ControlRuleStatistics stats;
                
                stats.total_rules = rules.size();
                stats.inflation_rules = 0;
                stats.fx_rules = 0;
                stats.rates_rules = 0;
                stats.most_recent_change = "2014-01-01";
                stats.oldest_param_info = "2025-01-01";
                
                for (const auto& rule : rules) {
                    // Comptage par domaine d'activité
                    if (rule.business_area == "INFLATION") {
                        stats.inflation_rules++;
                    } else if (rule.business_area == "FX") {
                        stats.fx_rules++;
                    } else if (rule.business_area == "RATES") {
                        stats.rates_rules++;
                    }
                    
                    // Dates les plus récentes/anciennes
                    if (rule.last_change_date > stats.most_recent_change) {
                        stats.most_recent_change = rule.last_change_date;
                    }
                    if (rule.param_info_date < stats.oldest_param_info) {
                        stats.oldest_param_info = rule.param_info_date;
                    }
                }
                
                return stats;
            }
            
        private:
            bool validate_constraint(const std::string& constraint, 
                                   const std::string& value) const {
                // Validation des contraintes spécifiques aux paramètres d'inflation
                // Implementation dépendante du type de contrainte
                return true; // Placeholder - implémentation spécifique requise
            }
        };
        
    private:
        PerformanceMonitoringSystem performance_system_;
        ParameterControlSystem parameter_system_;
    };
}
```
*Cette implémentation C++ dans Our project fournit un système complet de contrôle et monitoring avec 80+ règles de paramètres actives et surveillance automatique des indicateurs de performance pour le modèle Short Rate Normal.*

## Data and Process Controls

### Conditions for Use (CfUs)

Le tableau suivant fournit les **Conditions d'Utilisation** pour les règles de paramètres de modèle qui s'appliquent au modèle **DBX-ShortRate_InflationStochVol**.

#### Règles de Contrôle Principales (Sélection)

| CfU ID | Rule Name | Business Area | Status | Last Change | Description |
|--------|-----------|---------------|--------|-------------|-------------|
| **1320** | Inflation0002 | INFLATION | Released | 2019-08-07 | Règle de contrôle inflation historique |
| **1321** | Inflation0003 | INFLATION | Released | 2018-11-09 | Règle de contrôle inflation historique |
| **11910** | Inflation0061 | INFLATION | Released | 2020-08-18 | Règle de contrôle inflation moderne |
| **11911** | Inflation0062 | INFLATION | Released | 2020-08-18 | Règle de contrôle inflation moderne |
| **11912** | Inflation0063 | INFLATION | Released | 2020-08-18 | Règle de contrôle inflation moderne |
| **11913** | Inflation0064 | INFLATION | Released | 2020-08-18 | Règle de contrôle inflation moderne |
| **11914** | Inflation0065 | INFLATION | Released | 2020-08-18 | Règle de contrôle inflation moderne |

#### Règles Spécialisées

| CfU ID | Rule Name | Business Area | Status | Last Change | Description |
|--------|-----------|---------------|--------|-------------|-------------|
| **11963** | Inflation0114 | **FX** | Released | 2020-08-18 | Règle de contrôle FX pour inflation |
| **15339** | Inflation0155 | INFLATION | Released | 2020-09-29 | Règle de contrôle inflation avancée |
| **15343** | Inflation0159 | **FX** | Released | 2020-09-29 | Règle de contrôle FX pour inflation |
| **17046** | Rates0402 | **RATES** | Released | 2020-12-16 | Règle de contrôle taux d'intérêt |
| **17047** | Rates0403 | **RATES** | Released | 2020-12-16 | Règle de contrôle taux d'intérêt |
| **17048** | Rates0404 | **RATES** | Released | 2020-12-16 | Règle de contrôle taux d'intérêt |

### Statistiques des Règles de Contrôle

#### Distribution par Domaine d'Activité
- **INFLATION** : ~75 règles (majorité)
- **FX** : ~3 règles (composant FX)
- **RATES** : ~3 règles (taux d'intérêt)
- **Total** : **80+ règles actives**

#### Évolution Temporelle
- **Règles historiques** : 2014-2018 (fondation)
- **Modernisation** : 2019-2020 (mise à jour massive)
- **Dernières mises à jour** : 2020-2021 (optimisation)

### Performance Monitoring Activities

Les activités suivantes liées aux modèles sont incluses dans le monitoring de performance :

#### Indicateurs Clés de Performance

1. **P&L Inexpliqué** dû aux problèmes de modèle
   - Surveillance continue des écarts de P&L
   - Investigation automatique des déviations significatives

2. **Taille Relative des Réserves Modèle** au niveau paire produit-modèle
   - Relative à la PV et/ou au nombre de trades
   - **Déclenchement automatique** d'examen pour changements > 1M EUR mois-sur-mois

3. **Résultats des Tests de Prix IPV** via processus VRM
   - Validation croisée des outputs de pricing
   - Monitoring de la cohérence inter-systèmes

4. **Identification des Instabilités de Risque** produites par les modèles
   - Détection automatique des anomalies de calcul de risque
   - Alertes en temps réel pour les déviations

5. **Feedback sur la Performance du Modèle**
   - Performance de hedging
   - Observations de marché
   - Exceptions de back testing historique
   - Échecs de calibration
   - Succès des résultats d'enchères de pricing
   - Instabilités de risque
   - Disputes de collatéral significatives dues aux modèles

6. **Échecs de Modèle**
   - Échecs techniques identifiés par les tests de régression
   - Autres processus BAU

### Automated Control Framework

#### Real-time Parameter Validation
- **Validation automatique** de tous les paramètres selon les 80+ règles actives
- **Alertes immédiates** pour les valeurs non conformes aux règles approuvées
- **Logging complet** de toutes les validations et violations

#### Performance Threshold Monitoring
- **Seuils d'alerte** configurables pour chaque indicateur de performance
- **Escalation automatique** des dépassements de seuils critiques
- **Rapports périodiques** de statut de performance pour MCWGs

#### Model Rule Enforcement
- **Application stricte** des règles de paramètres via le système MARS
- **Traçabilité complète** des changements de paramètres
- **Audit trail** pour toutes les modifications de configuration

### Servicer Model Controls

Lorsque le modèle de pricing est utilisé comme servicer, se référer à la section du rapport de validation du modèle principal sur l'évaluation des contrôles des modèles servicer.

### Presentation and Attestation

Les activités listées ci-dessus doivent être **préparées et présentées aux MCWGs** et durant l'**attestation annuelle** de l'année.

#### Processus d'Attestation Annuelle
- **Préparation des données** de performance pour l'année écoulée
- **Analyse des tendances** des indicateurs de performance
- **Documentation des exceptions** et actions correctives prises
- **Présentation formelle** aux Model Control Working Groups (MCWGs)
- **Validation** de la conformité aux standards réglementaires

### Control Assessment Summary

#### Strengths
✅ **Système de contrôle robuste** avec 80+ règles de paramètres actives
✅ **Monitoring en temps réel** des indicateurs de performance clés
✅ **Déclenchement automatique** d'examens pour changements significatifs (> 1M EUR)
✅ **Intégration MARS** pour la traçabilité et l'audit
✅ **Présentation structurée** aux MCWGs et attestation annuelle
✅ **Couverture complète** : INFLATION, FX, RATES

#### Areas for Continuous Improvement
- **Expansion du monitoring** vers de nouveaux indicateurs de performance
- **Amélioration de l'automatisation** des réponses aux alertes
- **Renforcement de l'intégration** avec les systèmes de surveillance globaux
- **Préparation de la migration** vers le nouveau modèle (2025)

Le système de contrôle du modèle Short Rate Normal dans Our project assure une surveillance continue et une validation rigoureuse de tous les aspects critiques du modèle, garantissant son fonctionnement optimal et conforme aux standards réglementaires jusqu'à son retirement programmé en mi-2025.
