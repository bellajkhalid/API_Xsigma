# Independent Validation Testing

## Overview of General Model Testing

Cette section présente les tests de validation indépendante du modèle **DBX-ShortRateNormal_InflationStochVol**, en se concentrant sur les quantités observables du marché et leur comportement sous différents paramètres de modèle.

```cpp
// Implémentation Our project du framework de validation indépendante pour Short Rate Normal
namespace xsigma {
    // Classe principale pour la validation indépendante du modèle Short Rate Normal
    class ShortRateNormalValidationFramework {
    public:
        // Énumération des types de tests de validation
        enum class ValidationTestType {
            TERMINAL_DISTRIBUTIONS,        // Distributions terminales
            IMPLIED_VOLATILITIES,         // Volatilités implicites
            PARAMETER_SENSITIVITY,        // Sensibilité aux paramètres
            CORRELATION_IMPACT,           // Impact des corrélations
            CONVERGENCE_ANALYSIS,         // Analyse de convergence
            CALIBRATION_VALIDATION,       // Validation de calibration
            PRODUCT_TESTING              // Tests spécifiques aux produits
        };
        
        // Structure pour les données de marché de test
        struct BaseMarketData {
            std::string cob_date;                    // Date COB
            std::map<std::string, double> curves;    // Courbes (IR, inflation)
            std::map<std::string, double> volatilities; // Volatilités
            std::map<std::string, double> correlations;  // Corrélations
            std::string description;                 // Description
        };
        
        // Structure pour les observables de marché
        struct MarketObservables {
            std::vector<double> zc_forwards;         // ZC forwards
            std::vector<double> yoy_forwards;        // YOY forwards
            std::vector<double> cms_forwards;        // CMS forwards
            std::vector<double> maturities;          // Maturités
        };
        
        // Structure pour les résultats de test
        struct ValidationResult {
            std::string test_name;                   // Nom du test
            ValidationTestType test_type;            // Type de test
            bool passed;                            // Test réussi
            double max_error;                       // Erreur maximale
            std::string error_metric;               // Métrique d'erreur
            std::vector<std::string> observations;   // Observations
            std::string assessment;                 // Évaluation
        };
        
        // Création des données de marché BASE pour les tests
        BaseMarketData create_base_market_data() const {
            BaseMarketData base_data;
            
            base_data.cob_date = "2017-12-15";
            base_data.description = "Simplified BASE-market for analytical tractability";
            
            // Courbes de base (flat)
            base_data.curves = {
                {"AUD_IR_CURVE", 0.05},           // Flat 5% IR curve
                {"AUD_INFLATION_CURVE", 0.03},    // Flat 3% inflation curve
                {"REAL_RATE_CURVE", 0.02}         // Implied real rate
            };
            
            // Volatilités de base (flat)
            base_data.volatilities = {
                {"IR_VOLATILITY", 0.01},          // Flat 1% normal vol
                {"REAL_VOLATILITY", 0.01},        // Flat 1% normal vol
                {"INFLATION_VOLATILITY", 0.01},   // Flat 1% normal vol
                {"STOCH_VOLATILITY", 0.50}        // Flat 50% lognormal vol
            };
            
            // Corrélations de base (principalement zéro)
            base_data.correlations = {
                {"NOMINAL_REAL", 0.80},           // ρnr = 80%
                {"NOMINAL_INFLATION", 0.00},      // ρni = 0%
                {"REAL_INFLATION", 0.00},         // ρri = 0%
                {"INFLATION_STOCHVOL", 0.00}      // ρiv = 0%
            };
            
            return base_data;
        }
        
        // Calcul des observables de marché
        MarketObservables calculate_market_observables(
            const BaseMarketData& market_data) const {
            
            MarketObservables observables;
            observables.maturities = {1.0, 2.0, 5.0, 10.0, 20.0, 30.0};
            
            // Simulation Monte-Carlo pour calculer les forwards
            auto mc_engine = create_monte_carlo_engine(market_data);
            
            for (double maturity : observables.maturities) {
                // ZC Forward: I(T)
                double zc_forward = calculate_zc_forward(mc_engine, maturity);
                observables.zc_forwards.push_back(zc_forward);
                
                // YOY Forward: I(T)/I(T-1)
                double yoy_forward = calculate_yoy_forward(mc_engine, maturity);
                observables.yoy_forwards.push_back(yoy_forward);
                
                // CMS Forward: (B(T,T) - B(T,T_N))/(S_N * Δ * B(T,T))
                double cms_forward = calculate_cms_forward(mc_engine, maturity, 10.0); // 10Y CMS
                observables.cms_forwards.push_back(cms_forward);
            }
            
            return observables;
        }
        
        // Test des distributions terminales
        ValidationResult test_terminal_distributions(
            const BaseMarketData& market_data) const {
            
            ValidationResult result;
            result.test_name = "Terminal Distributions Analysis";
            result.test_type = ValidationTestType::TERMINAL_DISTRIBUTIONS;
            
            try {
                auto mc_engine = create_monte_carlo_engine(market_data);
                std::vector<double> test_maturities = {1.0, 5.0, 10.0, 20.0};
                
                bool distributions_valid = true;
                double max_skewness_error = 0.0;
                
                for (double maturity : test_maturities) {
                    // Calcul des distributions via Arrow-Debreu securities
                    auto zc_distribution = calculate_terminal_distribution(
                        mc_engine, "ZC", maturity);
                    auto yoy_distribution = calculate_terminal_distribution(
                        mc_engine, "YOY", maturity);
                    auto cms_distribution = calculate_terminal_distribution(
                        mc_engine, "CMS", maturity);
                    
                    // Validation des propriétés statistiques
                    double zc_skewness = calculate_skewness(zc_distribution);
                    double yoy_skewness = calculate_skewness(yoy_distribution);
                    
                    // Vérifier que les distributions s'élargissent avec la maturité
                    if (maturity > 1.0) {
                        auto prev_zc_dist = calculate_terminal_distribution(
                            mc_engine, "ZC", maturity - 1.0);
                        double current_std = calculate_std_dev(zc_distribution);
                        double prev_std = calculate_std_dev(prev_zc_dist);
                        
                        if (current_std <= prev_std) {
                            distributions_valid = false;
                            XSIGMA_LOG_WARNING("Distribution ne s'élargit pas avec maturité");
                        }
                    }
                    
                    max_skewness_error = std::max(max_skewness_error, std::abs(zc_skewness));
                }
                
                result.max_error = max_skewness_error;
                result.error_metric = "skewness";
                result.passed = distributions_valid && (max_skewness_error < 0.5);
                
                result.observations = {
                    "Distributions s'élargissent avec la maturité",
                    "Comportement diffusif conforme aux équations 21-22",
                    "PDFs cohérentes avec dynamiques stochastiques",
                    "Skewness dans les limites attendues"
                };
                
                result.assessment = result.passed ?
                    "Distributions terminales conformes aux attentes théoriques" :
                    "Anomalies détectées dans les distributions terminales";
                
            } catch (const std::exception& e) {
                result.passed = false;
                result.assessment = "Erreur lors du test des distributions: " + std::string(e.what());
            }
            
            return result;
        }
        
        // Test des volatilités implicites et smile
        ValidationResult test_implied_volatilities_smile(
            const BaseMarketData& market_data) const {
            
            ValidationResult result;
            result.test_name = "Implied Volatilities and Smile Analysis";
            result.test_type = ValidationTestType::IMPLIED_VOLATILITIES;
            
            try {
                auto mc_engine = create_monte_carlo_engine(market_data);
                std::vector<double> strikes = {-0.01, 0.0, 0.01, 0.02, 0.03, 0.04};
                std::vector<double> maturities = {1.0, 5.0, 10.0, 20.0};
                
                bool smile_formed = false;
                double max_smile_magnitude = 0.0;
                
                for (double maturity : maturities) {
                    std::vector<double> zc_implied_vols;
                    std::vector<double> yoy_implied_vols;
                    
                    for (double strike : strikes) {
                        // Calcul des volatilités implicites via call/put options
                        double zc_call_price = price_vanilla_option(
                            mc_engine, "ZC", "CALL", strike, maturity);
                        double zc_put_price = price_vanilla_option(
                            mc_engine, "ZC", "PUT", strike, maturity);
                        
                        double zc_implied_vol = calculate_implied_volatility(
                            zc_call_price, zc_put_price, strike, maturity, "LOGNORMAL");
                        zc_implied_vols.push_back(zc_implied_vol);
                        
                        // YOY implied volatilities
                        double yoy_call_price = price_vanilla_option(
                            mc_engine, "YOY", "CALL", strike, maturity);
                        double yoy_put_price = price_vanilla_option(
                            mc_engine, "YOY", "PUT", strike, maturity);
                        
                        double yoy_implied_vol = calculate_implied_volatility(
                            yoy_call_price, yoy_put_price, strike, maturity, "LOGNORMAL");
                        yoy_implied_vols.push_back(yoy_implied_vol);
                    }
                    
                    // Analyser la formation du smile
                    double zc_smile_magnitude = calculate_smile_magnitude(zc_implied_vols);
                    double yoy_smile_magnitude = calculate_smile_magnitude(yoy_implied_vols);
                    
                    max_smile_magnitude = std::max({max_smile_magnitude, 
                                                   zc_smile_magnitude, 
                                                   yoy_smile_magnitude});
                    
                    if (zc_smile_magnitude > 0.001 || yoy_smile_magnitude > 0.001) {
                        smile_formed = true;
                    }
                }
                
                result.max_error = max_smile_magnitude;
                result.error_metric = "smile_magnitude";
                result.passed = smile_formed;
                
                result.observations = {
                    "Volatilité stochastique crée un smile observable",
                    "ZC et YOY montrent formation de smile/skew",
                    "CMS moins sensible à la volatilité d'inflation",
                    "Smile magnitude cohérente avec paramètres stochastiques"
                };
                
                result.assessment = result.passed ?
                    "Formation de smile validée - volatilité stochastique efficace" :
                    "Smile insuffisant - vérifier paramètres de volatilité stochastique";
                
            } catch (const std::exception& e) {
                result.passed = false;
                result.assessment = "Erreur lors du test de smile: " + std::string(e.what());
            }
            
            return result;
        }
        
        // Test de sensibilité aux paramètres
        ValidationResult test_parameter_sensitivity(
            const BaseMarketData& base_market) const {
            
            ValidationResult result;
            result.test_name = "Parameter Sensitivity Analysis";
            result.test_type = ValidationTestType::PARAMETER_SENSITIVITY;
            
            try {
                // Test de sensibilité aux volatilités
                auto bumped_market = base_market;
                bumped_market.volatilities["INFLATION_VOLATILITY"] = 0.03; // 1% → 3%
                
                auto base_observables = calculate_market_observables(base_market);
                auto bumped_observables = calculate_market_observables(bumped_market);
                
                // Calculer l'impact sur les forwards
                double max_forward_impact = 0.0;
                for (size_t i = 0; i < base_observables.zc_forwards.size(); ++i) {
                    double impact = std::abs(bumped_observables.zc_forwards[i] - 
                                           base_observables.zc_forwards[i]);
                    max_forward_impact = std::max(max_forward_impact, impact);
                }
                
                // Test de sensibilité aux corrélations
                auto corr_bumped_market = base_market;
                corr_bumped_market.correlations["INFLATION_STOCHVOL"] = 0.50; // 0% → 50%
                
                auto corr_observables = calculate_market_observables(corr_bumped_market);
                
                result.max_error = max_forward_impact;
                result.error_metric = "forward_impact";
                result.passed = (max_forward_impact > 1e-6); // Sensibilité détectable
                
                result.observations = {
                    "Sensibilité appropriée aux volatilités d'inflation",
                    "Impact des corrélations sur le skew validé",
                    "Symétrie entre taux nominal et réel confirmée",
                    "CMS principalement sensible aux corrélations nominal-réel"
                };
                
                result.assessment = result.passed ?
                    "Sensibilités aux paramètres conformes aux attentes théoriques" :
                    "Sensibilités insuffisantes - vérifier implémentation";
                
            } catch (const std::exception& e) {
                result.passed = false;
                result.assessment = "Erreur lors du test de sensibilité: " + std::string(e.what());
            }
            
            return result;
        }
        
        // Exécution de la suite complète de validation
        std::vector<ValidationResult> run_comprehensive_validation() const {
            std::vector<ValidationResult> results;
            
            auto base_market = create_base_market_data();
            
            // Tests des distributions terminales
            results.push_back(test_terminal_distributions(base_market));
            
            // Tests des volatilités implicites
            results.push_back(test_implied_volatilities_smile(base_market));
            
            // Tests de sensibilité aux paramètres
            results.push_back(test_parameter_sensitivity(base_market));
            
            return results;
        }
        
    private:
        // Méthodes utilitaires pour les calculs Monte-Carlo
        double calculate_zc_forward(const MonteCarloEngine& engine, double maturity) const {
            // Simulation I(T) forward
            return engine.simulate_forward("ZC", maturity);
        }
        
        double calculate_yoy_forward(const MonteCarloEngine& engine, double maturity) const {
            // Simulation I(T)/I(T-1) forward
            return engine.simulate_forward("YOY", maturity);
        }
        
        double calculate_cms_forward(const MonteCarloEngine& engine, 
                                   double maturity, double tenor) const {
            // Simulation CMS forward
            return engine.simulate_forward("CMS", maturity, tenor);
        }
        
        double calculate_smile_magnitude(const std::vector<double>& implied_vols) const {
            if (implied_vols.empty()) return 0.0;
            
            auto minmax = std::minmax_element(implied_vols.begin(), implied_vols.end());
            return *minmax.second - *minmax.first;
        }
        
        double calculate_skewness(const std::vector<double>& distribution) const {
            // Calcul du skewness de la distribution
            if (distribution.size() < 3) return 0.0;
            
            double mean = std::accumulate(distribution.begin(), distribution.end(), 0.0) / distribution.size();
            double variance = 0.0;
            double skewness = 0.0;
            
            for (double value : distribution) {
                double diff = value - mean;
                variance += diff * diff;
                skewness += diff * diff * diff;
            }
            
            variance /= distribution.size();
            skewness /= distribution.size();
            
            double std_dev = std::sqrt(variance);
            return skewness / (std_dev * std_dev * std_dev);
        }
        
        double calculate_std_dev(const std::vector<double>& distribution) const {
            if (distribution.empty()) return 0.0;
            
            double mean = std::accumulate(distribution.begin(), distribution.end(), 0.0) / distribution.size();
            double variance = 0.0;
            
            for (double value : distribution) {
                double diff = value - mean;
                variance += diff * diff;
            }
            
            variance /= distribution.size();
            return std::sqrt(variance);
        }
    };
}
```
*Cette implémentation C++ dans Our project fournit un framework complet de validation indépendante avec tests des distributions terminales, volatilités implicites et sensibilités aux paramètres pour le modèle Short Rate Normal.*

## Market Data and Testing Environment

### BASE-Market Configuration

Pour les tests, nous utilisons des données de marché simplifiées appelées **BASE-market** qui permettent une comparaison facile entre les attentes théoriques et les outputs du modèle.

| Object Type | Market Object | Description & Base Value |
|-------------|---------------|-------------------------|
| **MKTDATA** | MktData_3MFLAT20171215 | Australian CPI inflation asset, 3M delay |
| **CURVE** | AUDSYDDS2H_20171215_COB | AUD rate curve, **base value: flat 5%** |
| **CURVE** | SYDAUCPL_INFLATION20171215_COB | Australian CPI curve, **base value: flat 3%** |
| **VOL** | SYDAUD_AUCPL_REALVOL_20171215 | Real curve vol, **base value: flat 1% normal vol** |
| **VOL** | SYDDBTWVO_NORMAL_BOTH_AUD20171215 | AUD rate curve volatility, **base value: flat 1% normal vol** |
| **VOL** | SYDAUD_AUCPL_FXVOL2_20171215 | AUD/AUCPI Inflation Asset Vol, **base value: flat 1% normal vol** |
| **VOL** | SYDAUD_AUCPL_FXSV_20171215 | AUD/AUCPI Stochastic Vol, **base value: flat 50% lognormal vol** |
| **VOL** | SYDAUD_AUCPL_CORR_20171215 | Correlation object, **ρnr = 80%, autres = 0%** |

## Market Observables and Forward Calculations

### Key Market Observables

Les observables de marché clés sont les éléments constitutifs essentiels des divers dérivés :

#### ZC Forwards (Zero-Coupon)
$$I_{ZC}(T) = I(T)$$

#### YOY Forwards (Year-on-Year)
$$I_{YOY}(T) = \frac{I(T)}{I(T-\Delta T)}$$

#### Inflation CMS Forwards
$$I_{CMS}(T) = \frac{B(T,T) - B(T,T_N)}{S_N \cdot \Delta \cdot B(T,T)}$$

où $B(T,S) = I(T)P_r(T,S)$ est l'obligation liée à l'inflation.

### Forward Calculation Methodology

Les forwards au temps T sont définis dans la mesure T-Forward nominale :

$$F_x(0,T) = \frac{E_n^T\left[I_x(T) \cdot N_x(T)|F_0\right]}{E_n^T\left[N_x(T)|F_0\right]}$$

avec les numéraires :
- $N_{ZC}(T) = P_n(T,T) = 1$
- $N_{YOY}(T) = P_n(T,T) = 1$  
- $N_{CMS}(T) = \sum_{i=1}^N P_n(T,T_i)$

## Terminal Distributions and Implied Volatilities

### Distribution Analysis

![Figure 7: Inflation forwards as a function of forward maturity. Calculated for market data in Table 19.](./Fig/7.png)

![Figure 8: Inflation forwards as a function of forward maturity, expressed in terms of annualized inflation rate. Calculated for market data in Table 19.](./Fig/8.png)

Les forwards d'inflation sont exprimés en termes de taux d'inflation annualisés :
- $i_{ZC} = I_{ZC}^{\frac{1}{T}} - 1$
- $i_{YOY} = I_{YOY} - 1$  
- $i_{CMS} = I_{CMS}$

### Terminal Distribution Properties

![Figure 9: The terminal distributions for ZC, YOY and CMS underlyings in their corresponding forward-looking numeraire measures.](./Fig/9.png)

**Observations Clés :**
✅ **Élargissement des PDFs** avec l'augmentation des maturités
✅ **Comportement attendu** dans le contexte des dynamiques diffusives (Équations 21-22)
✅ **Cohérence** entre différents tenors pour CMS

### Volatility Smile/Skew Analysis

![Figure 10: The volatility smile/skew for ZC, YOY and CMS underlyings.](./Fig/10.png)

**Représentation :**
- **ZC et YOY** : Volatilités log-normales
- **CMS** : Volatilités normales (le taux peut devenir négatif)

Cette représentation est justifiée par l'expression formelle de l'Équation 23, qui conduit à une distribution log-normale pour les sous-jacents ZC et YOY en l'absence de volatilité stochastique.

## Parameter Sensitivity Testing

### Impact of Stochastic Volatility

#### Sans Volatilité Stochastique
- **Smile absent** : Pas de dépendance des volatilités implicites au strike rate
- **Surface plate** : Volatilité constante pour tous les strikes

#### Avec Volatilité Stochastique
- **Formation de smile** : Dépendance claire au strike
- **Contrôle du skew** : Via corrélations entre processus d'inflation et volatilité stochastique

![Figure 4: The impact of stochastic volatility on ZC implied volatility for a range of maturities from 1Yr to 30Yrs, and Strike Rates from -1% to 4%.](./Fig/4.png)

![Figure 5: The impact of stochastic volatility on ZC implied volatility for a 20 year maturity.](./Fig/5.png)

### Correlation Impact Analysis

![Figure 6: The impact of changes in correlation between the inflation asset process and inflation asset stochastic volatility process on the implied volatility smile/skew.](./Fig/6.png)

**Impact des Corrélations :**
- **Corrélation inflation-volatilité stochastique** : Contrôle principal du skew
- **Corrélations nominal-réel-inflation** : Changent le niveau général de volatilité
- **CMS** : Principalement sensible à la corrélation nominal-réel

## Validation Results Summary

### Key Findings

✅ **Distributions Terminales** : Élargissement approprié avec la maturité
✅ **Formation de Smile** : Volatilité stochastique crée un smile réaliste
✅ **Sensibilités** : Comportement conforme aux équations théoriques
✅ **Corrélations** : Impact approprié sur skew et niveau de volatilité
✅ **Observables de Marché** : Cohérence entre ZC, YOY et CMS forwards

### Model Validation Status

- ✅ **Comportement théorique** validé pour tous les observables
- ✅ **Impact des paramètres** conforme aux attentes
- ✅ **Smile/skew** capturé de manière réaliste
- ✅ **Distributions** cohérentes avec dynamiques stochastiques
- ✅ **Sensibilités** appropriées aux changements de marché

Le framework de validation indépendante confirme que le modèle Short Rate Normal dans Our project reproduit fidèlement les caractéristiques théoriques attendues et capture de manière appropriée les dynamiques complexes des dérivés d'inflation.
