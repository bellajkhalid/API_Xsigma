# Introduction to Model and Validation

## Validation Scope

La validation couvre le modèle **DBX-ShortRate_InflationStochVol** utilisé pour le pricing de divers dérivés d'inflation. Les produits avec des caractéristiques similaires ont été groupés et testés comme une unité cohérente, avec des produits représentatifs testés pour fournir une inférence à l'ensemble du groupe de produits.

```cpp
// Implémentation Our project du framework de validation pour Short Rate Normal
namespace xsigma {
    // Classe pour la gestion de la validation du modèle Short Rate Normal
    class ShortRateNormalValidationFramework {
    public:
        // Énumération des catégories de produits
        enum class ProductCategory {
            LINEAR_INFLATION,              // Inflation linéaire
            EUROPEAN_CONVEX,              // Européen convexe
            BERMUDAN_CONVEX,              // Bermudien convexe
            EUROPEAN_LINEAR,              // Européen linéaire
            HYBRID_INFLATION_IR,          // Hybride inflation/taux
            MEMORY_DEPENDENT,             // Dépendant de la mémoire
            CONVEX_NO_OPTION,            // Convexe sans option
            MEMORY_CONVEX,               // Mémoire convexe
            BERMUDAN_CONVEX_LINEAR,      // Bermudien convexe linéaire
            BERMUDAN_LINEAR,             // Bermudien linéaire
            ASIAN_CONVEX                 // Asiatique convexe
        };
        
        // Structure pour la description d'un produit
        struct ProductDescription {
            std::string product_name;           // Nom du produit
            ProductCategory category;           // Catégorie
            std::string underlying;             // Sous-jacent
            std::string coupon_structure;       // Structure de coupon
            std::string underlying_specifics;   // Spécificités du sous-jacent
            std::string option_type;            // Type d'option
            std::string barrier_type;           // Type de barrière
            std::string path_dependency;        // Dépendance au chemin
            bool is_test_representative;        // Produit représentatif pour tests
        };
        
        // Structure pour la composition du portfolio
        struct PortfolioComposition {
            std::string product_name;           // Nom du produit
            std::string model_configuration;    // Configuration du modèle
            int trade_count;                    // Nombre de trades
            double pv_eur_millions;             // PV en millions EUR
            double abs_pv_eur_millions;         // PV absolu en millions EUR
        };
        
        // Obtenir tous les produits supportés avec leurs descriptions
        std::vector<ProductDescription> get_supported_products() const {
            return {
                // Catégorie 1: Linear Inflation
                {"InflAssetSwap", ProductCategory::LINEAR_INFLATION, "Inflation", "Linear", "Linear", "None", "None", "None", false},
                {"InflSwapZC", ProductCategory::LINEAR_INFLATION, "Inflation", "Linear", "Linear", "None", "None", "None", true},
                
                // Catégorie 2: European Convex
                {"InflCapFloorYOY", ProductCategory::EUROPEAN_CONVEX, "Inflation", "EuroCpn", "Convex", "European", "None", "None", true},
                {"InflSwaptionYOYEuro", ProductCategory::EUROPEAN_CONVEX, "Inflation", "EuroCpn", "Convex", "European", "None", "None", false},
                {"InflSwaptionZCEuro", ProductCategory::EUROPEAN_CONVEX, "Inflation", "EuroCpn", "Convex", "European", "None", "None", false},
                {"InflSwapYOYCapFloor", ProductCategory::EUROPEAN_CONVEX, "Inflation", "EuroCpn", "Convex", "European", "None", "None", false},
                
                // Catégorie 3: Bermudan Convex
                {"InflCapFloorYOYCallable", ProductCategory::BERMUDAN_CONVEX, "Inflation", "EuroCpn", "Convex", "Bermudan", "None", "None", false},
                {"InflCapFloorZCCallable", ProductCategory::BERMUDAN_CONVEX, "Inflation", "EuroCpn", "Convex", "Bermudan", "None", "None", false},
                {"InflSwaptionYOYBerm", ProductCategory::BERMUDAN_CONVEX, "Inflation", "EuroCpn", "Convex", "Bermudan", "None", "None", false},
                {"InflSwaptionZCBerm", ProductCategory::BERMUDAN_CONVEX, "Inflation", "EuroCpn", "Convex", "Bermudan", "None", "None", false},
                
                // Catégorie 4: European Linear
                {"InflCapFloorZC", ProductCategory::EUROPEAN_LINEAR, "Inflation", "EuroCpn", "Linear", "European", "None", "None", true},
                
                // Catégorie 5: Hybrid Inflation/IR
                {"InflSwapInflNominalLin", ProductCategory::HYBRID_INFLATION_IR, "Inflation, InterestRate", "EuroCpn", "Convex", "European", "None", "None", false},
                {"InflVariableCapFloor", ProductCategory::HYBRID_INFLATION_IR, "Inflation, InterestRate", "EuroCpn", "Convex", "European", "None", "None", false},
                {"IRIndexOptSingle_INFLATION", ProductCategory::HYBRID_INFLATION_IR, "Inflation, InterestRate", "EuroCpn", "Convex", "European", "None", "None", false},
                
                // Catégorie 6: Memory Dependent
                {"InflSwapLookback", ProductCategory::MEMORY_DEPENDENT, "Inflation", "EuroCpn", "Convex", "European", "None", "Memory", true},
                {"InflSwapLPI", ProductCategory::MEMORY_DEPENDENT, "Inflation", "EuroCpn", "Convex", "European", "None", "Memory", false},
                {"InflSwapLPINonStd", ProductCategory::MEMORY_DEPENDENT, "Inflation", "EuroCpn", "Convex", "European", "None", "Memory", false},
                {"InflSwaptionLPIEuro", ProductCategory::MEMORY_DEPENDENT, "Inflation", "EuroCpn", "Convex", "European", "None", "Memory", false},
                
                // Catégorie 7: Convex No Option
                {"InflSwapPayDelay", ProductCategory::CONVEX_NO_OPTION, "Inflation", "Linear", "Convex", "None", "None", "None", false},
                {"InflSwapYOY", ProductCategory::CONVEX_NO_OPTION, "Inflation", "Linear", "Convex", "None", "None", "None", true},
                {"IRSwapRealRate", ProductCategory::CONVEX_NO_OPTION, "Inflation", "Linear", "Convex", "None", "None", "None", false},
                
                // Catégorie 8: Memory Convex
                {"InflSwapSnowball", ProductCategory::MEMORY_CONVEX, "Inflation", "Linear", "Convex", "None", "None", "Memory", true},
                
                // Catégorie 9: Bermudan Convex Linear
                {"InflSwapYOYCallable", ProductCategory::BERMUDAN_CONVEX_LINEAR, "Inflation", "Linear", "Convex", "Bermudan", "None", "None", false},
                
                // Catégorie 10: Bermudan Linear
                {"InflSwapZCCallable", ProductCategory::BERMUDAN_LINEAR, "Inflation", "Linear", "Linear", "Bermudan", "None", "None", false},
                
                // Catégorie 11: Asian Convex
                {"InflSwapAverage", ProductCategory::ASIAN_CONVEX, "Inflation", "EuroCpn", "Convex", "Asian", "None", "Asian", true}
            };
        }
        
        // Obtenir la composition actuelle du portfolio
        std::vector<PortfolioComposition> get_current_portfolio() const {
            return {
                {"InflSwapAverage", "DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV]", 5, 27.381184, 27.381184},
                {"InflSwapInflNominalLin", "DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV]", 5, 1.027304, 1.027304},
                {"InflSwapLPINonStd", "DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV]", 6, 354.411794, 354.411794},
                {"InflSwapLookBack", "DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV]", 1, 7.104650, 7.104650},
                {"InflSwapLookback", "DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV]", 63, -38.290207, 38.290207},
                {"InflSwapSnowball", "DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV]", 18, 14.705815, 14.705815},
                {"InflSwapYOYCapFloor", "DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV]", 1, -0.027910, 0.027910},
                {"InflSwaptionZCEuro", "DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV]", 5, 13.126691, 13.126691}
            };
        }
        
        // Analyse du portfolio
        struct PortfolioAnalysis {
            int total_trades;                   // Total des trades
            double total_pv_millions;           // PV total en millions
            double total_abs_pv_millions;       // PV absolu total en millions
            std::map<std::string, int> product_distribution; // Distribution par produit
            std::string largest_position;       // Position la plus importante
            std::string risk_concentration;     // Concentration des risques
        };
        
        PortfolioAnalysis analyze_portfolio() const {
            auto portfolio = get_current_portfolio();
            PortfolioAnalysis analysis;
            
            analysis.total_trades = 0;
            analysis.total_pv_millions = 0.0;
            analysis.total_abs_pv_millions = 0.0;
            
            double max_abs_pv = 0.0;
            std::string max_product;
            
            for (const auto& position : portfolio) {
                analysis.total_trades += position.trade_count;
                analysis.total_pv_millions += position.pv_eur_millions;
                analysis.total_abs_pv_millions += position.abs_pv_eur_millions;
                analysis.product_distribution[position.product_name] = position.trade_count;
                
                if (position.abs_pv_eur_millions > max_abs_pv) {
                    max_abs_pv = position.abs_pv_eur_millions;
                    max_product = position.product_name;
                }
            }
            
            analysis.largest_position = max_product;
            
            // Analyse de concentration
            double concentration_ratio = max_abs_pv / analysis.total_abs_pv_millions;
            if (concentration_ratio > 0.5) {
                analysis.risk_concentration = "HIGH - Position dominante: " + max_product;
            } else if (concentration_ratio > 0.3) {
                analysis.risk_concentration = "MEDIUM - Concentration modérée";
            } else {
                analysis.risk_concentration = "LOW - Portfolio diversifié";
            }
            
            return analysis;
        }
        
        // Obtenir les produits représentatifs pour les tests
        std::vector<std::string> get_test_representative_products() const {
            std::vector<std::string> representatives;
            auto products = get_supported_products();
            
            for (const auto& product : products) {
                if (product.is_test_representative) {
                    representatives.push_back(product.product_name);
                }
            }
            
            return representatives;
        }
        
        // Validation de la couverture des tests
        bool validate_test_coverage() const {
            auto products = get_supported_products();
            std::set<ProductCategory> categories_covered;
            
            for (const auto& product : products) {
                if (product.is_test_representative) {
                    categories_covered.insert(product.category);
                }
            }
            
            // Vérifier que toutes les catégories ont un représentant
            std::set<ProductCategory> all_categories = {
                ProductCategory::LINEAR_INFLATION,
                ProductCategory::EUROPEAN_CONVEX,
                ProductCategory::BERMUDAN_CONVEX,
                ProductCategory::EUROPEAN_LINEAR,
                ProductCategory::HYBRID_INFLATION_IR,
                ProductCategory::MEMORY_DEPENDENT,
                ProductCategory::CONVEX_NO_OPTION,
                ProductCategory::MEMORY_CONVEX,
                ProductCategory::BERMUDAN_CONVEX_LINEAR,
                ProductCategory::BERMUDAN_LINEAR,
                ProductCategory::ASIAN_CONVEX
            };
            
            bool full_coverage = true;
            for (const auto& category : all_categories) {
                if (categories_covered.find(category) == categories_covered.end()) {
                    XSIGMA_LOG_WARNING("Catégorie sans représentant de test: " + 
                                      std::to_string(static_cast<int>(category)));
                    full_coverage = false;
                }
            }
            
            return full_coverage;
        }
    };
}
```
*Cette implémentation C++ dans Our project gère la validation complète avec classification des produits d'inflation, analyse de portfolio et validation de la couverture des tests pour le modèle Short Rate Normal.*

## Product Description

### PRDS Descriptions

Le modèle supporte de nombreux produits liés à l'inflation, incluant :

#### Produits Principaux

- **InflAssetSwap** : Transaction de swap de taux d'intérêt impliquée dans une structure où l'investisseur achète une obligation liée à l'inflation
- **InflCapFloorYOY** : Swap d'inflation year-on-year avec caractéristiques de cap ou floor
- **InflSwapZC** : Swap d'inflation zéro-coupon
- **InflSwaptionZCEuro** : Swaption de style européen sur swap d'inflation zéro-coupon
- **InflSwapLPI** : Dérivés d'inflation à indexation de prix limitée
- **InflSwapYOY** : Swap d'inflation year-on-year
- **InflSwapSnowball** : Swap d'inflation avec effet boule de neige
- **InflSwapAverage** : Swap d'inflation avec moyenne asiatique

### Product Grouping Table

Les produits approuvés pour le modèle DBX-ShortRate_InflationStochVol sont organisés en catégories basées sur leurs caractéristiques :

| Underlying | Coupon Structure | Underlying Specifics | Option | Barrier | Path Dependent | Products |
|------------|-----------------|---------------------|--------|---------|----------------|----------|
| **Inflation** | Linear | Linear | None | None | None | InflAssetSwap, **InflSwapZC** |
| **Inflation** | EuroCpn | Convex | European | None | None | **InflCapFloorYOY**, InflSwaptionYOYEuro, InflSwaptionZCEuro, InflSwapYOYCapFloor |
| **Inflation** | EuroCpn | Convex | Bermudan | None | None | InflCapFloorYOYCallable, InflCapFloorZCCallable, InflSwaptionYOYBerm, InflSwaptionZCBerm |
| **Inflation** | EuroCpn | Linear | European | None | None | **InflCapFloorZC** |
| **Inflation, InterestRate** | EuroCpn | Convex | European | None | None | InflSwapInflNominalLin, InflVariableCapFloor, IRIndexOptSingle_INFLATION |
| **Inflation** | EuroCpn | Convex | European | None | Memory | **InflSwapLookback**, InflSwapLPI, InflSwapLPINonStd, InflSwaptionLPIEuro |
| **Inflation** | Linear | Convex | None | None | None | InflSwapPayDelay, **InflSwapYOY**, IRSwapRealRate |
| **Inflation** | Linear | Convex | None | None | Memory | **InflSwapSnowball** |
| **Inflation** | Linear | Convex | Bermudan | None | None | InflSwapYOYCallable |
| **Inflation** | Linear | Linear | Bermudan | None | None | InflSwapZCCallable |
| **Inflation** | EuroCpn | Convex | Asian | None | Asian | **InflSwapAverage** |

**Note :** Les produits en **gras** ont été spécifiquement testés comme représentatifs de leur catégorie.

### Portfolio Composition and PV of Trades

La population actuelle de production des trades mappés au modèle DBX-ShortRate_InflationStochVol au 19/08/2022 :

| Product Name | Model Configuration | Trade Count | PV EUR (millions) | ABS PV EUR (millions) |
|--------------|---------------------|-------------|-------------------|------------------------|
| **InflSwapAverage** | DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV] | 5 | 27.381184 | 27.381184 |
| **InflSwapInflNominalLin** | DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV] | 5 | 1.027304 | 1.027304 |
| **InflSwapLPINonStd** | DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV] | 6 | 354.411794 | 354.411794 |
| **InflSwapLookBack** | DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV] | 1 | 7.104650 | 7.104650 |
| **InflSwapLookback** | DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV] | 63 | -38.290207 | 38.290207 |
| **InflSwapSnowball** | DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV] | 18 | 14.705815 | 14.705815 |
| **InflSwapYOYCapFloor** | DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV] | 1 | -0.027910 | 0.027910 |
| **InflSwaptionZCEuro** | DBX-ShortRateNormal[LVTV]_InflationStochVol[DBTTV] | 5 | 13.126691 | 13.126691 |

#### Analyse du Portfolio

- **Total des trades** : 104 positions
- **PV total** : 379.439 millions EUR
- **PV absolu total** : 455.875 millions EUR
- **Position dominante** : InflSwapLPINonStd (77.7% du PV absolu)
- **Concentration des risques** : HIGH - Concentration significative sur LPI

## Model Description

### Model Configuration

Le modèle DBX-ShortRate_InflationStochVol a les configurations suivantes :

#### Configuration LVTV
- **Paramétrage de volatilité** via volatilités locales et volatilités de terme
- **Application** : Objets de volatilité DBAanalytics avec VolName DBMVOL et VolType LVT

#### Configuration DBTTV
- **Paramétrage de volatilité** via volatilités de terme uniquement
- **Volatilités locales** égales aux volatilités de terme
- **Application** : Objets de volatilité DBAanalytics avec VolName DBMVOL et VolType DBT

### Model Assumptions

Les hypothèses clés du modèle incluent :

1. **Absence d'arbitrage** dans le marché
2. **Taux d'intérêt nominal** : Modèle de diffusion Hull-White avec distribution normale
3. **Taux d'intérêt réel** : Modèle de diffusion Hull-White avec mean reversion et distribution normale
4. **Index d'inflation** : Processus lognormal avec composant de volatilité stochastique
5. **Extension Jarrow-Yildirim** : Le modèle peut être considéré comme une extension du modèle de diffusion classique Jarrow-Yildirim

### Model Parameters and Market Inputs

#### Implementation Parameters

Les paramètres d'implémentation définissent le moteur de pricing Monte-Carlo dans la bibliothèque DBAanalytics :

| Paramètre | Valeur par Défaut | Description |
|-----------|-------------------|-------------|
| **NumberSims** | 2000 | Nombre de simulations par run |
| **NumberRuns** | 1 | Nombre de runs indépendants |
| **FreqTimeVec** | 12 | Ajoute des points temporels aux dates de simulation (12 points par année) |
| **FrontLatticeFreq** | - | Ajoute des points temporels au début de la grille temporelle |
| **DecayTime** | 1 | Définit la fréquence des points temporels pour un temps arbitraire t |
| **VarianceReduction** | ORTHOGONAL | Spécifie comment les variates uniformes sont transformées (ORTHOGONAL recommandé) |

#### Model and Market Parameters

Dans la bibliothèque DBAanalytics, le pricing des dérivés d'inflation multi-devises nécessite :

- **DBMVOL VOL object** avec ModelType=LOGNORMAL, VolType=DBT pour la diffusion lognormale avec volatilité stochastique du processus d'index de taux d'inflation
- **DBMVOL VOL objects** avec ModelType=NORMAL, VolType=DBT pour le modèle Hull-White pour les taux d'intérêt nominaux et réels
- **CORRELATION** avec VolType=CORR pour la structure de terme des facteurs de corrélation instantanée
- **CURVE objects** pour les courbes de taux d'intérêt et les courbes d'inflation

## Model Dynamics

### The FX Analogy and The Jarrow-Yildirim Model

Le modèle Jarrow-Yildirim définit un index de taux d'inflation par analogie avec un taux de change spot FX. Si un actif vaut 1 unité de devise réelle, sa valeur en unités de devise nominale est I, où I est la valeur de l'index de taux d'inflation.

**L'index d'inflation peut être considéré comme un taux de change entre la devise nominale d'un côté et la devise réelle de l'autre.**

### Mathematical Formulation

#### Inflation Index Process
$$\frac{dI(t)}{I(t)} = (n(t) - r(t))dt + \eta(t)v(t)dW^I(t)$$

où :
- **η(t)** est le multiplicateur de volatilité (stochastique)
- **W^I(t)** est un mouvement brownien pilotant l'inflation
- **n(t)** est le taux court nominal
- **r(t)** est le taux court réel

#### Complete Model Specification

La dynamique complète du modèle est spécifiée par l'évolution de quatre facteurs stochastiques :

1. **rₙ(t)** - processus de taux court nominal
2. **rᵣ(t)** - processus de taux court réel  
3. **I(t)** - processus d'index d'inflation
4. **v(t)** - processus de volatilité stochastique de l'index d'inflation

Ces facteurs satisfont un système d'équations différentielles stochastiques jointes qui sont simulées en utilisant des méthodes Monte Carlo.

### The Correlation Matrix

Le modèle Jarrow-Yildirim nécessite la spécification de facteurs de corrélation instantanée entre les processus de taux nominal, réel et d'index de taux d'inflation. La matrice de corrélation est une matrice réelle symétrique et définie positive avec **10 inputs**.

## Risk Sensitivity

Les conventions Deutsche Bank pour les Greeks diffèrent des conventions typiques :

- **Deltas** ont des signes opposés (delta FX négatif signifie qu'une augmentation du taux FX a un impact positif)
- **Vegas** ont les signes standards (vega FX positif signifie qu'une augmentation de volatilité augmente la valeur du produit)
- **Greeks DBA** indiquent des changements en valeur absolue plutôt que des dérivées
- **Greeks** sont par défaut mis à l'échelle par 10⁶

### Risk Sensitivities Used

- **FLATDELTA** : Courbe IR shiftée vers le haut de 1 bp absolu
- **FLATGAMMA** : Différence de FLATDELTA quand la courbe est shiftée de 10bps
- **FLATVEGA** : Tous les paramètres de volatilité bumpés de 5% relatif

Le modèle Short Rate Normal dans Our project fournit un framework complet pour le pricing et la gestion des risques des dérivés d'inflation avec une architecture robuste et une validation exhaustive.
