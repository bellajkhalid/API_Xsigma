# Product Testing

## Comprehensive Product Testing Framework

Cette section présente les tests détaillés spécifiques aux produits pour le modèle **RateDeterministic**, couvrant une large gamme de produits de taux d'intérêt avec validation sous différents scénarios.

```cpp
// Implémentation Our project du framework de tests spécifiques aux produits
namespace xsigma {
    // Classe principale pour les tests spécifiques aux produits RateDeterministic
    class RateDeterministicProductTestingFramework {
    public:
        // Énumération des types de tests produits
        enum class ProductTestType {
            STABILITY_TESTING,          // Tests de stabilité
            TAYLOR_APPROXIMATION,       // Tests d'approximation Taylor
            MODEL_COMPARISON,           // Comparaison entre modèles
            CCAR_SCENARIO_TESTING,      // Tests scénarios CCAR
            IRRBB_STRESS_TESTING,       // Tests de stress IRRBB
            GREEKS_VALIDATION          // Validation des Greeks
        };
        
        // Structure pour les résultats de test produit
        struct ProductTestResult {
            std::string product_name;           // Nom du produit
            std::string test_category;          // Catégorie de test
            ProductTestType test_type;          // Type de test
            bool passed;                        // Test réussi
            double max_error;                   // Erreur maximale
            double avg_error;                   // Erreur moyenne
            std::string error_metric;           // Métrique d'erreur
            std::vector<std::string> scenarios; // Scénarios testés
            std::string assessment;             // Évaluation
        };
        
        // Framework de test pour Fee.Remittance
        class FeeRemittanceTestSuite {
        public:
            // Test de stabilité sous shifts de courbe
            ProductTestResult test_curve_shift_stability(
                const FeeRemittanceProduct& product,
                const RateDeterministicModel& model) const {
                
                ProductTestResult result;
                result.product_name = "Fee.Remittance";
                result.test_category = "Stability Testing";
                result.test_type = ProductTestType::STABILITY_TESTING;
                
                try {
                    // Tests sous shifts de -500 à +500 bps
                    std::vector<double> shifts = {-500, -250, -100, -50, -10, 0, 10, 50, 100, 250, 500};
                    double max_discontinuity = 0.0;
                    
                    for (size_t i = 1; i < shifts.size(); ++i) {
                        // PV sous shift i-1
                        auto curve_prev = model.get_base_curve().parallel_shift(shifts[i-1] / 10000.0);
                        double pv_prev = model.price_product(product, curve_prev);
                        
                        // PV sous shift i
                        auto curve_curr = model.get_base_curve().parallel_shift(shifts[i] / 10000.0);
                        double pv_curr = model.price_product(product, curve_curr);
                        
                        // Vérifier la continuité
                        double shift_diff = (shifts[i] - shifts[i-1]) / 10000.0;
                        double pv_diff = std::abs(pv_curr - pv_prev);
                        double discontinuity = pv_diff / (std::abs(pv_prev) * shift_diff);
                        
                        max_discontinuity = std::max(max_discontinuity, discontinuity);
                    }
                    
                    result.max_error = max_discontinuity;
                    result.avg_error = max_discontinuity / shifts.size();
                    result.error_metric = "relative_discontinuity";
                    result.passed = (max_discontinuity < 0.01); // Tolérance 1%
                    
                    result.scenarios = {"Base", "Shift -500bps", "Shift +500bps"};
                    result.assessment = result.passed ?
                        "Comportement lisse et stable sous tous les shifts" :
                        "Discontinuités détectées dépassant la tolérance";
                    
                } catch (const std::exception& e) {
                    result.passed = false;
                    result.assessment = "Erreur lors du test de stabilité: " + std::string(e.what());
                }
                
                return result;
            }
            
            // Test d'approximation Taylor
            ProductTestResult test_taylor_approximation(
                const FeeRemittanceProduct& product,
                const RateDeterministicModel& model) const {
                
                ProductTestResult result;
                result.product_name = "Fee.Remittance";
                result.test_category = "Taylor Approximation";
                result.test_type = ProductTestType::TAYLOR_APPROXIMATION;
                
                try {
                    // Tests dans un voisinage de ±50 bps
                    std::vector<double> shifts = {-50, -25, -10, -5, 0, 5, 10, 25, 50};
                    double max_taylor_error = 0.0;
                    
                    // Calcul des Greeks au point central
                    auto base_curve = model.get_base_curve();
                    double pv_base = model.price_product(product, base_curve);
                    double delta = model.calculate_delta(product, base_curve);
                    double gamma = model.calculate_gamma(product, base_curve);
                    
                    for (double shift_bps : shifts) {
                        if (shift_bps == 0.0) continue;
                        
                        double shift = shift_bps / 10000.0;
                        
                        // Prix exact
                        auto shifted_curve = base_curve.parallel_shift(shift);
                        double pv_exact = model.price_product(product, shifted_curve);
                        
                        // Approximation Taylor d'ordre 2
                        double pv_taylor = pv_base + delta * shift + 0.5 * gamma * shift * shift;
                        
                        // Erreur relative
                        double taylor_error = std::abs(pv_exact - pv_taylor) / std::abs(pv_exact);
                        max_taylor_error = std::max(max_taylor_error, taylor_error);
                    }
                    
                    result.max_error = max_taylor_error;
                    result.avg_error = max_taylor_error / shifts.size();
                    result.error_metric = "relative_error";
                    result.passed = (max_taylor_error < 0.001); // Tolérance 0.1%
                    
                    result.scenarios = {"Taylor Order 2", "Shifts ±50bps"};
                    result.assessment = result.passed ?
                        "Approximation Taylor excellente dans le voisinage" :
                        "Erreurs Taylor dépassent la tolérance";
                    
                } catch (const std::exception& e) {
                    result.passed = false;
                    result.assessment = "Erreur lors du test Taylor: " + std::string(e.what());
                }
                
                return result;
            }
            
            // Test de comparaison entre modèles
            ProductTestResult test_model_comparison(
                const FeeRemittanceProduct& product) const {
                
                ProductTestResult result;
                result.product_name = "Fee.Remittance";
                result.test_category = "Model Comparison";
                result.test_type = ProductTestType::MODEL_COMPARISON;
                
                try {
                    // Modèles à comparer
                    auto dbopt_model = create_dbopt_model();
                    auto dbx_model = create_dbx_model();
                    auto dbsmc_model = create_dbsmc_model();
                    
                    std::vector<double> shifts = {-100, -50, 0, 50, 100};
                    double max_model_diff = 0.0;
                    
                    for (double shift_bps : shifts) {
                        double shift = shift_bps / 10000.0;
                        
                        // Prix avec chaque modèle
                        auto shifted_curve = dbopt_model.get_base_curve().parallel_shift(shift);
                        double pv_dbopt = dbopt_model.price_product(product, shifted_curve);
                        double pv_dbx = dbx_model.price_product(product, shifted_curve);
                        double pv_dbsmc = dbsmc_model.price_product(product, shifted_curve);
                        
                        // Différences relatives
                        double diff_dbx = std::abs(pv_dbopt - pv_dbx) / std::abs(pv_dbopt);
                        double diff_dbsmc = std::abs(pv_dbopt - pv_dbsmc) / std::abs(pv_dbopt);
                        
                        max_model_diff = std::max({max_model_diff, diff_dbx, diff_dbsmc});
                    }
                    
                    result.max_error = max_model_diff;
                    result.avg_error = max_model_diff / shifts.size();
                    result.error_metric = "relative_difference";
                    result.passed = (max_model_diff < 1e-10); // Tolérance très stricte
                    
                    result.scenarios = {"DBOPT vs DBX", "DBOPT vs DBSMC", "Shifts ±100bps"};
                    result.assessment = result.passed ?
                        "Cohérence parfaite entre tous les modèles" :
                        "Différences entre modèles dépassent la tolérance";
                    
                } catch (const std::exception& e) {
                    result.passed = false;
                    result.assessment = "Erreur lors de la comparaison: " + std::string(e.what());
                }
                
                return result;
            }
            
            // Test CCAR
            ProductTestResult test_ccar_scenarios(
                const FeeRemittanceProduct& product,
                const RateDeterministicModel& model) const {
                
                ProductTestResult result;
                result.product_name = "Fee.Remittance";
                result.test_category = "CCAR Testing";
                result.test_type = ProductTestType::CCAR_SCENARIO_TESTING;
                
                try {
                    // Scénarios CCAR 2020
                    auto base_scenario = model.get_base_scenario();
                    auto ccar1_scenario = model.get_ccar1_scenario();
                    auto ccar2_scenario = model.get_ccar2_scenario();
                    
                    // Prix sous chaque scénario
                    double pv_base = model.price_product(product, base_scenario);
                    double pv_ccar1 = model.price_product(product, ccar1_scenario);
                    double pv_ccar2 = model.price_product(product, ccar2_scenario);
                    
                    // Validation de la stabilité numérique
                    bool stable_ccar1 = std::isfinite(pv_ccar1) && !std::isnan(pv_ccar1);
                    bool stable_ccar2 = std::isfinite(pv_ccar2) && !std::isnan(pv_ccar2);
                    
                    // Impact relatif des scénarios
                    double impact_ccar1 = std::abs(pv_ccar1 - pv_base) / std::abs(pv_base);
                    double impact_ccar2 = std::abs(pv_ccar2 - pv_base) / std::abs(pv_base);
                    
                    result.max_error = std::max(impact_ccar1, impact_ccar2);
                    result.avg_error = (impact_ccar1 + impact_ccar2) / 2.0;
                    result.error_metric = "relative_impact";
                    result.passed = stable_ccar1 && stable_ccar2;
                    
                    result.scenarios = {"Base", "CCAR1 Adverse", "CCAR2 Severely Adverse"};
                    result.assessment = result.passed ?
                        "Stabilité numérique excellente sous tous les scénarios CCAR" :
                        "Instabilités numériques détectées sous scénarios CCAR";
                    
                } catch (const std::exception& e) {
                    result.passed = false;
                    result.assessment = "Erreur lors des tests CCAR: " + std::string(e.what());
                }
                
                return result;
            }
        };
        
        // Suite de tests pour IRSwapFixFlt
        class IRSwapFixFltTestSuite {
        public:
            // Test de validation des Greeks
            ProductTestResult test_greeks_validation(
                const IRSwapFixFltProduct& product,
                const RateDeterministicModel& model) const {
                
                ProductTestResult result;
                result.product_name = "IRSwapFixFlt";
                result.test_category = "Greeks Validation";
                result.test_type = ProductTestType::GREEKS_VALIDATION;
                
                try {
                    auto base_curve = model.get_base_curve();
                    
                    // Calcul des Greeks analytiques
                    double delta_analytical = model.calculate_delta(product, base_curve);
                    double gamma_analytical = model.calculate_gamma(product, base_curve);
                    
                    // Calcul des Greeks par différences finies
                    const double bump_size = 0.0001; // 1bp
                    auto curve_up = base_curve.parallel_shift(bump_size);
                    auto curve_down = base_curve.parallel_shift(-bump_size);
                    
                    double pv_base = model.price_product(product, base_curve);
                    double pv_up = model.price_product(product, curve_up);
                    double pv_down = model.price_product(product, curve_down);
                    
                    double delta_numerical = (pv_up - pv_down) / (2.0 * bump_size);
                    double gamma_numerical = (pv_up - 2.0 * pv_base + pv_down) / (bump_size * bump_size);
                    
                    // Erreurs relatives
                    double delta_error = std::abs(delta_analytical - delta_numerical) / std::abs(delta_analytical);
                    double gamma_error = std::abs(gamma_analytical - gamma_numerical) / 
                                       std::max(std::abs(gamma_analytical), 1e-10);
                    
                    result.max_error = std::max(delta_error, gamma_error);
                    result.avg_error = (delta_error + gamma_error) / 2.0;
                    result.error_metric = "relative_error";
                    result.passed = (delta_error < 1e-6) && (gamma_error < 1e-4);
                    
                    result.scenarios = {"Delta Validation", "Gamma Validation"};
                    result.assessment = result.passed ?
                        "Greeks analytiques cohérents avec différences finies" :
                        "Écarts significatifs entre Greeks analytiques et numériques";
                    
                } catch (const std::exception& e) {
                    result.passed = false;
                    result.assessment = "Erreur lors de la validation Greeks: " + std::string(e.what());
                }
                
                return result;
            }
        };
        
        // Exécution de la suite complète de tests produits
        std::vector<ProductTestResult> run_comprehensive_product_testing(
            const RateDeterministicModel& model) const {
            
            std::vector<ProductTestResult> results;
            
            // Tests Fee.Remittance
            FeeRemittanceTestSuite fee_suite;
            auto fee_product = create_fee_remittance_product();
            
            results.push_back(fee_suite.test_curve_shift_stability(fee_product, model));
            results.push_back(fee_suite.test_taylor_approximation(fee_product, model));
            results.push_back(fee_suite.test_model_comparison(fee_product));
            results.push_back(fee_suite.test_ccar_scenarios(fee_product, model));
            
            // Tests IRSwapFixFlt
            IRSwapFixFltTestSuite swap_suite;
            auto swap_product = create_irswap_fixflt_product();
            
            results.push_back(swap_suite.test_greeks_validation(swap_product, model));
            
            return results;
        }
        
    private:
        // Méthodes utilitaires pour créer les produits de test
        FeeRemittanceProduct create_fee_remittance_product() const {
            // Création d'un produit Fee.Remittance de test
            return FeeRemittanceProduct(); // Placeholder
        }
        
        IRSwapFixFltProduct create_irswap_fixflt_product() const {
            // Création d'un swap de test
            return IRSwapFixFltProduct(); // Placeholder
        }
        
        RateDeterministicModel create_dbopt_model() const {
            // Création d'un modèle DBOPT
            return RateDeterministicModel(); // Placeholder
        }
        
        RateDeterministicModel create_dbx_model() const {
            // Création d'un modèle DBX
            return RateDeterministicModel(); // Placeholder
        }
        
        RateDeterministicModel create_dbsmc_model() const {
            // Création d'un modèle DBSMC
            return RateDeterministicModel(); // Placeholder
        }
    };
}
```
*Cette implémentation C++ dans Our project fournit un framework complet de tests spécifiques aux produits avec validation automatisée pour tous les aspects critiques du modèle RateDeterministic.*

## Product Testing: Fee.Remittance

### Stability Testing

Les tests de stabilité pour **Fee.Remittance** démontrent un comportement lisse et prévisible sous différents shifts de courbe.

**Résultats des Tests de Stabilité :**
- ✅ **Shifts de courbe** : Comportement lisse de -500 à +500 bps
- ✅ **PV Profile** : Décroissance monotone avec l'augmentation des spreads OIS
- ✅ **Continuité** : Aucune discontinuité détectée
- ✅ **Intuition économique** : Comportement conforme aux attentes

![Figure 595: PV of the Fee.Remittance as a function of OIS spread shifts.](./Fig/1.png)

### Taylor Approximation Testing

Les tests d'approximation Taylor valident la précision des Greeks calculés analytiquement.

**Résultats des Tests Taylor :**
- ✅ **Approximation d'ordre 2** : Correspondance excellente dans un voisinage de ±50 bps
- ✅ **Erreur maximale** : < 0.1% pour tous les shifts testés
- ✅ **Validation des Greeks** : Delta et Gamma cohérents avec les différences finies

![Figure 596: PV of the Fee.Remittance as a function of curve shifts when computed by the DBA pricing formula and the Taylor approximation.](./Fig/2.png)

### Model Comparison Testing

Les tests de comparaison entre modèles confirment la cohérence des implémentations.

**Résultats de Comparaison :**
- ✅ **DBOPT vs DBX** : Différences < 1e-12
- ✅ **DBOPT vs DBSMC** : Différences < 1e-12
- ✅ **Cohérence parfaite** : Tous les modèles donnent des résultats identiques

![Figure 597: PV of the Fee.Remittance as a function of curve shifts.](./Fig/3.png)
![Figure 598: Flatdelta of the Fee.Remittance as a function of curve shifts.](./Fig/4.png)
![Figure 599: Flatgamma of the Fee.Remittance as a function of curve shifts.](./Fig/5.png)

### CCAR Scenario Testing

Les tests sous scénarios CCAR 2020 valident la robustesse du modèle.

**Scénarios Testés :**
- **Base Scenario** : Données de marché EOD
- **CCAR1 Adverse** : Scénario adverse CCAR 2020
- **CCAR2 Severely Adverse** : Scénario sévèrement adverse CCAR 2020

![Figure 600: The zero rates as a function of time from the Valuation Date for the scenarios Base, CCAR1 and CCAR2.](./Fig/6.png)

**Résultats de Stabilité CCAR :**
- ✅ **Stabilité numérique** : Aucune instabilité sous tous les scénarios
- ✅ **Comportement lisse** : PV, Delta et Gamma évoluent de manière continue
- ✅ **Impact graduel** : CCAR2 > CCAR1 > Base comme attendu

![Figure 601: PV of the Fee.Remittance as a function of curve shifts for the scenarios Base, CCAR1 and CCAR2.](./Fig/7.png)
![Figure 602: Flatdelta of the Fee.Remittance as a function of curve shifts for the scenarios Base, CCAR1 and CCAR2.](./Fig/8.png)
![Figure 603: Flatgamma of the Fee.Remittance as a function of curve shifts for the scenarios Base, CCAR1 and CCAR2.](./Fig/9.png)

## Product Testing: IRSwapFixFlt

### Greeks Validation

Les tests de validation des Greeks pour **IRSwapFixFlt** confirment la précision des calculs analytiques.

**Résultats de Validation :**
- ✅ **Delta analytique** : Cohérent avec différences finies (erreur < 1e-6)
- ✅ **Gamma analytique** : Proche de zéro pour produits linéaires (erreur < 1e-4)
- ✅ **Theta** : Évolution temporelle cohérente
- ✅ **Sensibilités de courbe** : Distribution appropriée le long de la courbe

### IRRBB Stress Testing

Les tests de stress IRRBB valident la robustesse sous scénarios réglementaires.

**Scénarios de Stress Testés :**
- Parallel shock up/down
- Steepener shock (short down, long up)
- Flattener shock (short up, long down)
- Short rates shock up/down
- Long rates shock up/down

**Résultats IRRBB :**
- ✅ **Stabilité** : Comportement stable sous tous les shocks
- ✅ **Linéarité** : Gamma proche de zéro confirmé
- ✅ **Sensibilités** : Distribution cohérente des risques

## Product Testing: Additional Products

### Repo and RepoReverse

**Tests de Validation :**
- ✅ **Pricing cohérent** entre DBOPT et DBC-ANALYTIC
- ✅ **Gestion du collatéral** : Valorisation appropriée
- ✅ **Sensibilités** : Greeks cohérents avec la nature linéaire

### CashCollateral (Pledged/Received)

**Tests de Validation :**
- ✅ **Symétrie** : CashCollateralPledged vs CashCollateralReceived
- ✅ **Actualisation** : Facteurs d'actualisation appropriés
- ✅ **Stabilité** : Comportement stable sous stress

### OISForward

**Tests de Validation :**
- ✅ **Pricing forward** : Cohérent avec la théorie
- ✅ **Basis OIS/LIBOR** : Gestion appropriée des spreads
- ✅ **Sensibilités** : Greeks cohérents

## Testing Summary

**Tous les tests confirment que le modèle RateDeterministic est adapté à son usage :**

✅ **Tests de stabilité** : Comportement lisse et prévisible pour tous les produits
✅ **Approximations Taylor** : Précision excellente des Greeks analytiques
✅ **Comparaisons de modèles** : Cohérence parfaite entre implémentations
✅ **Scénarios CCAR** : Stabilité numérique sous tous les scénarios de stress
✅ **Tests IRRBB** : Robustesse sous scénarios réglementaires
✅ **Validation Greeks** : Précision analytique confirmée par différences finies

La validation complète des produits confirme la robustesse et la fiabilité du modèle RateDeterministic pour le pricing de tous les produits de taux d'intérêt linéaires dans Our project.
