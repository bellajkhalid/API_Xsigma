# Control Assessment

## üìä **Vue d'Ensemble de l'√âvaluation des Contr√¥les**

### **Objectif de la Section**
Cette section pr√©sente l'√©valuation des contr√¥les pour le mod√®le **DBSMC-RateDeterministic_FXMarket**, incluant le monitoring de performance continu, les contr√¥les de donn√©es et processus, et les conditions d'utilisation (CfU) via MARS.

### **Note sur les Mod√®les Servicer**
Lorsque le mod√®le de pricing est utilis√© comme servicer, se r√©f√©rer √† la section du rapport de validation du mod√®le principal sur l'√©valuation des contr√¥les des mod√®les servicer.

---

## üìà **Ongoing Performance Monitoring**

### **Surveillance de Performance Continue**

Le monitoring de performance du mod√®le repose sur des indicateurs de performance d√©finis par les Product Owners, utilisateurs de mod√®les de produits ou fonctions de contr√¥le selon les besoins, pour confirmer que le mod√®le fonctionne comme pr√©vu.

#### **üîß Activit√©s de Monitoring Incluses**

```cpp
// Framework de monitoring de performance dans Our project
class model_performance_monitoring_framework {
public:
    struct performance_indicators {
        std::map<std::string, double> unexplained_pnl_metrics;
        std::map<std::string, double> model_reserve_ratios;
        std::map<std::string, bool> ipv_test_results;
        std::map<std::string, double> risk_instability_measures;
        std::map<std::string, std::string> model_feedback_reports;
        bool monthly_threshold_breached;
    };
    
    performance_indicators monitor_model_performance(
        const dbsmc_model& model,
        const std::vector<trade_data>& trades,
        const market_data& market) {
        
        performance_indicators indicators;
        
        // 1. P&L inexpliqu√© d√ª aux probl√®mes de mod√®le
        indicators.unexplained_pnl_metrics = calculate_unexplained_pnl(model, trades, market);
        
        // 2. Taille relative des r√©serves de mod√®le
        indicators.model_reserve_ratios = calculate_model_reserve_ratios(model, trades);
        
        // 3. R√©sultats des tests de prix IPV via VRM
        indicators.ipv_test_results = perform_ipv_price_testing(model, trades, market);
        
        // 4. Identification des instabilit√©s de risque
        indicators.risk_instability_measures = identify_risk_instabilities(model, trades, market);
        
        // 5. Feedback sur la performance du mod√®le
        indicators.model_feedback_reports = collect_model_feedback(model);
        
        // V√©rification du seuil mensuel (1M EUR)
        indicators.monthly_threshold_breached = check_monthly_threshold_breach(indicators);
        
        return indicators;
    }
    
private:
    std::map<std::string, double> calculate_unexplained_pnl(
        const dbsmc_model& model,
        const std::vector<trade_data>& trades,
        const market_data& market) {
        
        std::map<std::string, double> unexplained_pnl;
        
        for (const auto& trade : trades) {
            // Calcul du P&L th√©orique vs r√©alis√©
            double theoretical_pnl = model.calculate_theoretical_pnl(trade, market);
            double realized_pnl = trade.get_realized_pnl();
            
            double unexplained_component = std::abs(theoretical_pnl - realized_pnl);
            
            // Attribution aux probl√®mes de mod√®le vs autres facteurs
            double model_attributed_pnl = attribute_pnl_to_model_issues(
                unexplained_component, trade, model);
            
            std::string trade_key = trade.get_trade_id();
            unexplained_pnl[trade_key] = model_attributed_pnl;
        }
        
        return unexplained_pnl;
    }
    
    std::map<std::string, double> calculate_model_reserve_ratios(
        const dbsmc_model& model,
        const std::vector<trade_data>& trades) {
        
        std::map<std::string, double> reserve_ratios;
        
        // Calcul par paire produit-mod√®le
        std::map<std::string, std::vector<trade_data>> product_trades;
        for (const auto& trade : trades) {
            product_trades[trade.get_product_name()].push_back(trade);
        }
        
        for (const auto& [product_name, product_trades_list] : product_trades) {
            double total_pv = 0.0;
            double total_reserves = 0.0;
            int trade_count = product_trades_list.size();
            
            for (const auto& trade : product_trades_list) {
                total_pv += std::abs(trade.get_present_value());
                total_reserves += trade.get_model_reserves();
            }
            
            // Ratio relatif au PV
            double pv_ratio = (total_pv > 0) ? (total_reserves / total_pv) : 0.0;
            
            // Ratio relatif au nombre de trades
            double trade_ratio = (trade_count > 0) ? (total_reserves / trade_count) : 0.0;
            
            reserve_ratios[product_name + "_PV_RATIO"] = pv_ratio;
            reserve_ratios[product_name + "_TRADE_RATIO"] = trade_ratio;
        }
        
        return reserve_ratios;
    }
    
    bool check_monthly_threshold_breach(const performance_indicators& indicators) {
        // Seuil automatique : changements mensuels > 1M EUR d√©clenchent examen approfondi
        const double THRESHOLD_EUR = 1000000.0;
        
        for (const auto& [reserve_key, ratio] : indicators.model_reserve_ratios) {
            if (ratio > THRESHOLD_EUR) {
                return true;
            }
        }
        
        return false;
    }
};
```
*Cette impl√©mentation C++ dans Our project montre un framework complet de monitoring de performance pour les mod√®les DBSMC.*

### **üìã Activit√©s de Monitoring Sp√©cifiques**

#### **1. P&L Inexpliqu√© d√ª aux Probl√®mes de Mod√®le**
- **Surveillance** : √âcarts entre P&L th√©orique et r√©alis√©
- **Attribution** : Identification des causes li√©es au mod√®le
- **Reporting** : Escalade automatique si seuils d√©pass√©s

#### **2. Taille Relative des R√©serves de Mod√®le**
- **Niveau** : Par paire produit-mod√®le
- **M√©triques** : Relatif au PV et/ou nombre de trades
- **Seuil** : Changements mensuels > 1M EUR ‚Üí examen approfondi automatique

#### **3. R√©sultats des Tests de Prix IPV via VRM**
- **Source** : Processus IPV (Independent Price Verification)
- **Fr√©quence** : Continue via VRM (Valuation Risk Management)
- **Validation** : Tests de coh√©rence des prix

#### **4. Identification des Instabilit√©s de Risque**
- **D√©tection** : Instabilit√©s produites par les mod√®les
- **Analyse** : Impact sur les m√©triques de risque
- **Mitigation** : Actions correctives si n√©cessaire

#### **5. Feedback sur la Performance du Mod√®le**
- **Sources** : Performance de hedging, observations de march√©, back testing
- **Inclut** : R√©sultats d'ench√®res de pricing, disputes de collat√©ral
- **√âchecs** : √âchecs techniques identifi√©s via tests de r√©gression

### **üìä Pr√©sentation et Attestation**

Les activit√©s list√©es ci-dessus doivent √™tre pr√©par√©es et pr√©sent√©es aux **MCWGs** (Model Control Working Groups) et lors de l'**attestation annuelle**.

---

## üîß **Data and Process Controls**

### **Contr√¥les de Donn√©es et Processus**

#### **üîç Conditions d'Utilisation (CfU)**

Le tableau suivant contient la liste des r√®gles de **Model Parameter Monitoring (MPM)** extraites de MARS, COB 17.12.2020, jug√©es pertinentes pour le mod√®le.

```cpp
// Framework de gestion des conditions d'utilisation dans Our project
class conditions_for_use_manager {
public:
    struct cfu_rule {
        int id;
        std::string rule_name;
        std::string business_area;
        std::string status;
        std::string last_change;
        std::string param_info;
        std::vector<std::string> minimum_conditions;
        std::vector<std::string> target_conditions;
    };
    
    struct cfu_validation_results {
        std::map<int, bool> rule_compliance;
        std::map<int, std::string> violation_details;
        bool overall_compliance;
        std::vector<int> critical_violations;
    };
    
    cfu_validation_results validate_conditions_for_use(
        const dbsmc_model_configuration& config,
        const std::vector<cfu_rule>& applicable_rules) {
        
        cfu_validation_results results;
        
        for (const auto& rule : applicable_rules) {
            bool rule_compliant = validate_individual_rule(config, rule);
            results.rule_compliance[rule.id] = rule_compliant;
            
            if (!rule_compliant) {
                results.violation_details[rule.id] = generate_violation_details(config, rule);
                
                // Identification des violations critiques
                if (is_critical_rule(rule)) {
                    results.critical_violations.push_back(rule.id);
                }
            }
        }
        
        // √âvaluation de la conformit√© globale
        results.overall_compliance = evaluate_overall_compliance(results);
        
        return results;
    }
    
private:
    bool validate_individual_rule(const dbsmc_model_configuration& config,
                                 const cfu_rule& rule) {
        
        // V√©rification des conditions minimales
        bool minimum_conditions_met = true;
        for (const auto& min_condition : rule.minimum_conditions) {
            if (!evaluate_condition(config, min_condition)) {
                minimum_conditions_met = false;
                break;
            }
        }
        
        // Si conditions minimales non remplies, r√®gle non applicable
        if (!minimum_conditions_met) {
            return true; // Non applicable = conforme
        }
        
        // V√©rification des conditions cibles
        for (const auto& target_condition : rule.target_conditions) {
            if (!evaluate_condition(config, target_condition)) {
                return false; // Violation de condition cible
            }
        }
        
        return true;
    }
    
    bool is_critical_rule(const cfu_rule& rule) {
        // R√®gles critiques pour DBSMC
        std::vector<std::string> critical_business_areas = {"FX", "RATES"};
        
        return std::find(critical_business_areas.begin(), 
                        critical_business_areas.end(), 
                        rule.business_area) != critical_business_areas.end();
    }
};
```

### **üìã R√®gles MPM Principales pour DBSMC**

#### **üîß R√®gles FX Critiques**

| **ID** | **Rule** | **Business** | **Status** | **Description** |
|--------|----------|--------------|------------|-----------------|
| **550** | FX0006 | FX | Released | Interpolation Type pour MARKETVOL |
| **588** | FX0007 | FX | Released | Vol Model CONSTANT_LV |
| **589** | FX0008 | FX | Released | Interpolation Space LOGSTRIKE/STRIKE |
| **11827** | FX0018 | FX | Released | SkewType SA4/LARGD pour PARAMETRICVOL |
| **11829** | FX0020 | FX | Released | PIV AutoFit Target Type VOL |
| **11831** | FX0021 | FX | Released | PIV AutoFit Synthetic Forwards NO |
| **11832** | FX0022 | FX | Released | PIV AutoFit Weighting NOTIONAL/VEGANOTIONAL |

#### **üîß R√®gles RATES/CREDIT**

| **ID** | **Rule** | **Business** | **Status** | **Description** |
|--------|----------|--------------|------------|-----------------|
| **11041** | CURVE0005 | RATES | Released | Extrapolation Method |
| **11044** | CURVE0019 | RATES | Released | CCY Use Base Curve |
| **11063** | CURVE0017 | RATES | Released | Curve Build Method |
| **13071** | CURVE0024 | RATES | Released | Base Rate Type LIBOR/OIS |

### **üîç Exemples de Conditions D√©taill√©es**

#### **CfU ID 550 - FX0006**
```
Configuration: all configurations
PRDS Product(s): all products
Minimum Condition(s): VOL::VolName == MARKETVOL and VOL::InputMode in (DELTAVOL, STRIKEVOL)
Target Condition(s): VOL::InterpolationType in (NATURALCUBIC, TIMESTRIKE)
```

#### **CfU ID 11829 - FX0020 (PIV AutoFit)**
```
Configuration: all configurations  
PRDS Product(s): all products
Minimum Condition(s): EXTRAINFO::ResultType == PIVAUTOFIT
Target Condition(s): EXTRAINFO::TargetType == VOL
```

#### **CfU ID 11832 - FX0022 (PIV AutoFit Weighting)**
```
Configuration: all configurations
PRDS Product(s): all products  
Minimum Condition(s): EXTRAINFO::ResultType == PIVAUTOFIT
Target Condition(s): EXTRAINFO::Weighting in (NOTIONAL, VEGANOTIONAL)
```

### **üìä Surveillance MARS**

#### **üîß Monitoring Automatis√©**
```cpp
// Syst√®me de surveillance MARS dans Our project
class mars_monitoring_system {
public:
    struct mars_alert {
        int rule_id;
        std::string violation_type;
        std::string severity;
        std::string timestamp;
        std::string remediation_action;
    };
    
    std::vector<mars_alert> monitor_cfu_compliance(
        const dbsmc_model& model,
        const std::vector<cfu_rule>& rules) {
        
        std::vector<mars_alert> alerts;
        
        for (const auto& rule : rules) {
            auto compliance_status = check_rule_compliance(model, rule);
            
            if (!compliance_status.is_compliant) {
                mars_alert alert;
                alert.rule_id = rule.id;
                alert.violation_type = compliance_status.violation_type;
                alert.severity = determine_severity(rule);
                alert.timestamp = get_current_timestamp();
                alert.remediation_action = suggest_remediation(rule, compliance_status);
                
                alerts.push_back(alert);
            }
        }
        
        return alerts;
    }
    
private:
    std::string determine_severity(const cfu_rule& rule) {
        // S√©v√©rit√© bas√©e sur l'impact business et la criticit√©
        if (rule.business_area == "FX" && rule.rule_name.find("PIV") != std::string::npos) {
            return "HIGH"; // PIV AutoFit critique pour FX
        } else if (rule.business_area == "RATES") {
            return "MEDIUM"; // Courbes de taux importantes
        } else {
            return "LOW";
        }
    }
};
```

### **üéØ Actions de Contr√¥le Recommand√©es**

#### **1. Surveillance Continue**
- **Monitoring automatis√©** des r√®gles CfU via MARS
- **Alertes en temps r√©el** pour violations critiques
- **Reporting mensuel** de conformit√©

#### **2. Validation P√©riodique**
- **Revue trimestrielle** des r√®gles MPM
- **Mise √† jour** des conditions selon √©volutions r√©glementaires
- **Tests de r√©gression** pour nouvelles r√®gles

#### **3. Escalade et Remediation**
- **Processus d'escalade** pour violations critiques
- **Plans de remediation** automatis√©s
- **Documentation** des exceptions approuv√©es

---

*Cette section fournit une √©valuation compl√®te des contr√¥les pour DBSMC-RateDeterministic_FXMarket, int√©grant les impl√©mentations C++ de Our project avec des frameworks de monitoring de performance et gestion des conditions d'utilisation MARS.*
