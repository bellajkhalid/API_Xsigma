# Model Uncertainty Identification, Measurement, and Management

## üìä **Vue d'Ensemble de la Gestion d'Incertitude**

### **Objectif de la Section**
Cette section pr√©sente l'identification, la mesure et la gestion des incertitudes du mod√®le **DBSMC-RateDeterministic_FXMarket**, incluant les limitations identifi√©es, les contr√¥les compensatoires et les r√©serves d'incertitude requises.

### **Classification des Incertitudes**
Les incertitudes et d√©ficiences du mod√®le ont √©t√© identifi√©es et cat√©goris√©es selon la classification d√©finie par la politique, avec √©mission de limitations et faiblesses du mod√®le pour les sources d'incertitude analys√©es.

---

## üîç **Model Uncertainty and Identification**

### **Sources d'Incertitude Identifi√©es**

Les limitations d'incertitude du mod√®le ont √©t√© identifi√©es et cat√©goris√©es dans :

- **Techniques num√©riques**
- **Hypoth√®ses m√©thodologiques** 
- **Impl√©mentation et d√©ploiement**
- **Facteurs de risque manquants**
- **Probl√®mes de processus**

### **Limitations du Mod√®le DBSMC-RateDeterministic_FXMarket**

#### **üîß Tableau des Limitations Identifi√©es**

| Limitation ID | Limitation Category | Limitation Type | Limitation Framework |
|---------------|-------------------|-----------------|---------------------|
| **707** | Missing Risk Factor | Interest Rate Volatility | ShortRateDeterministic |
| **1523** | Missing Risk Factor | FX Volatility Smile | FXMarket |
| **2742** | Missing Risk Factor | FX CORRELATION SKEW | FXMarket |
| **4050** | Calibration | Calibration Uncertainty | FXMarket |

### **D√©tail des Limitations**

#### **üîç Limitation 707 : Interest Rate Volatility (ShortRateDeterministic)**
```cpp
// Impact de la limitation dans Our project
class short_rate_deterministic_limitation_analyzer {
public:
    struct ir_volatility_impact_assessment {
        std::map<std::string, double> product_sensitivity_to_ir_vol;
        std::map<std::string, double> cashflow_linearity_measures;
        double limitation_materiality_score;
        bool limitation_reasonable;
    };
    
    ir_volatility_impact_assessment assess_ir_volatility_limitation(
        const std::vector<fx_derivative_base*>& products,
        const market_data& market) {
        
        ir_volatility_impact_assessment assessment;
        
        for (auto product : products) {
            // Analyse de la sensibilit√© aux taux
            auto ir_sensitivities = product->calculate_ir_sensitivities(market);
            
            // Mesure de lin√©arit√© des cashflows
            double linearity_measure = calculate_cashflow_linearity(product);
            
            // Score de mat√©rialit√© de la limitation
            double materiality = assess_ir_vol_materiality(product, market);
            
            std::string product_name = product->get_product_name();
            assessment.product_sensitivity_to_ir_vol[product_name] = materiality;
            assessment.cashflow_linearity_measures[product_name] = linearity_measure;
        }
        
        // √âvaluation globale de la limitation
        assessment.limitation_reasonable = evaluate_limitation_reasonableness(assessment);
        
        return assessment;
    }
    
private:
    bool evaluate_limitation_reasonableness(const ir_volatility_impact_assessment& assessment) {
        // La limitation est raisonnable si :
        // 1. Les cashflows sont fixes (coupon set/date = value/date)
        // 2. Lin√©aires dans un taux naturel (paydate = rate maturity)  
        // 3. L'incertitude des cashflows est domin√©e par la volatilit√© d'autres sous-jacents
        
        for (const auto& [product, linearity] : assessment.cashflow_linearity_measures) {
            if (linearity < 0.8) { // Cashflows non-lin√©aires
                double ir_sensitivity = assessment.product_sensitivity_to_ir_vol.at(product);
                if (ir_sensitivity > 0.1) { // Sensibilit√© significative
                    return false; // Limitation non raisonnable
                }
            }
        }
        
        return true;
    }
};
```
*Cette impl√©mentation C++ dans Our project analyse l'impact de la limitation de volatilit√© des taux d'int√©r√™t sur les produits FX.*

**Description :** Le framework ShortRateDeterministic fait l'hypoth√®se que l'incertitude des taux d'int√©r√™t n'est pas un facteur important pour le pricing. Cette hypoth√®se est raisonnable dans la mesure o√π les cashflows sont fixes, lin√©aires dans un taux naturel, ou o√π l'incertitude des cashflows est domin√©e par la volatilit√© d'autres sous-jacents.

#### **üîç Limitation 1523 : FX Volatility Smile (FXMarket)**
```cpp
// Analyse de l'impact du smile de volatilit√© dans Our project
class fx_volatility_smile_limitation_analyzer {
public:
    struct smile_impact_assessment {
        std::map<std::string, double> flat_vs_smile_pricing_differences;
        std::map<std::string, double> basket_approximation_errors;
        double smile_materiality_score;
        bool benchmarking_recommended;
    };
    
    smile_impact_assessment assess_fx_smile_limitation(
        const std::vector<fx_basket_option*>& basket_products,
        const market_data& market) {
        
        smile_impact_assessment assessment;
        
        for (auto basket_product : basket_products) {
            // Pricing avec smile plat (mod√®le actuel)
            double flat_smile_price = basket_product->calculate_pv_flat_smile(market);
            
            // Pricing avec smile complet (benchmark)
            double full_smile_price = calculate_benchmark_price_with_smile(basket_product, market);
            
            // Diff√©rence de pricing
            double pricing_difference = std::abs(flat_smile_price - full_smile_price);
            double relative_difference = pricing_difference / std::abs(full_smile_price);
            
            std::string product_name = basket_product->get_product_name();
            assessment.flat_vs_smile_pricing_differences[product_name] = relative_difference;
            
            // Erreur d'approximation pour l'index du panier
            double approximation_error = assess_lognormal_approximation_error(basket_product, market);
            assessment.basket_approximation_errors[product_name] = approximation_error;
        }
        
        // Score de mat√©rialit√© global
        assessment.smile_materiality_score = calculate_smile_materiality_score(assessment);
        assessment.benchmarking_recommended = (assessment.smile_materiality_score > 0.05);
        
        return assessment;
    }
    
private:
    double calculate_benchmark_price_with_smile(const fx_basket_option* basket_product,
                                              const market_data& market) {
        // Pricing de r√©f√©rence avec smile complet via mod√®le alternatif
        // (ex: Monte Carlo avec surfaces de volatilit√© compl√®tes)
        
        auto alternative_model = create_alternative_dbanalytics_model();
        return alternative_model->price_basket_with_full_smile(basket_product, market);
    }
};
```

**Description :** Le pricing des paniers repose sur la construction d'un index avec dynamiques lognormales √† partir des constituants du panier. Le mod√®le assume un smile de volatilit√© plat pour l'index. L'impact de la limitation peut √™tre √©valu√© par benchmarking contre des mod√®les DBAnalytics alternatifs.

#### **üîç Limitation 2742 : FX Correlation Skew (FXMarket)**
```cpp
// Analyse de l'impact du skew de corr√©lation dans Our project
class fx_correlation_skew_limitation_analyzer {
public:
    struct correlation_skew_assessment {
        std::map<std::string, double> three_moment_approximation_errors;
        std::map<std::string, double> higher_moment_impacts;
        double skew_limitation_materiality;
        bool three_moment_approximation_adequate;
    };
    
    correlation_skew_assessment assess_correlation_skew_limitation(
        const std::vector<fx_arithmetic_basket_option*>& arithmetic_baskets,
        const market_data& market) {
        
        correlation_skew_assessment assessment;
        
        for (auto basket : arithmetic_baskets) {
            // Pricing avec approximation 3 moments (mod√®le actuel)
            double three_moment_price = basket->calculate_pv_three_moment_matching(market);
            
            // Pricing avec moments d'ordre sup√©rieur (r√©f√©rence)
            double full_moment_price = calculate_full_moment_pricing(basket, market);
            
            // Erreur d'approximation
            double approximation_error = std::abs(three_moment_price - full_moment_price);
            double relative_error = approximation_error / std::abs(full_moment_price);
            
            std::string basket_name = basket->get_basket_name();
            assessment.three_moment_approximation_errors[basket_name] = relative_error;
            
            // Impact des moments d'ordre sup√©rieur
            double higher_moment_impact = assess_higher_moment_impact(basket, market);
            assessment.higher_moment_impacts[basket_name] = higher_moment_impact;
        }
        
        // √âvaluation de l'ad√©quation de l'approximation 3 moments
        assessment.three_moment_approximation_adequate = 
            evaluate_three_moment_adequacy(assessment);
        
        return assessment;
    }
    
private:
    bool evaluate_three_moment_adequacy(const correlation_skew_assessment& assessment) {
        // L'approximation 3 moments est ad√©quate si les erreurs restent < 5%
        for (const auto& [basket, error] : assessment.three_moment_approximation_errors) {
            if (error > 0.05) {
                return false;
            }
        }
        return true;
    }
};
```

**Description :** Lors du pricing des options de panier arithm√©tique multi-devises, le framework FXMarket utilise une approximation de matching √† trois moments sur la distribution de la variable de panier. Les moments d'ordre sup√©rieur ne sont donc pas calibr√©s dans ce framework.

#### **üîç Limitation 4050 : Calibration Uncertainty (FXMarket)**
```cpp
// Analyse de l'incertitude de calibration dans Our project
class calibration_uncertainty_analyzer {
public:
    struct calibration_uncertainty_assessment {
        std::map<std::string, double> calibration_target_sensitivities;
        std::map<std::string, double> parameter_uncertainties;
        std::map<std::string, double> calibration_quality_metrics;
        double overall_calibration_uncertainty;
        bool uncertainty_reserves_required;
    };
    
    calibration_uncertainty_assessment assess_calibration_uncertainty(
        const piv_auto_calibrator& calibrator,
        const std::vector<fx_option_market_quote>& market_quotes) {
        
        calibration_uncertainty_assessment assessment;
        
        // Tests de sensibilit√© aux cibles de calibration
        test_calibration_target_sensitivity(calibrator, market_quotes, assessment);
        
        // Tests de sensibilit√© aux param√®tres de calibration
        test_calibration_parameter_sensitivity(calibrator, market_quotes, assessment);
        
        // √âvaluation de la qualit√© de calibration
        assess_calibration_quality(calibrator, market_quotes, assessment);
        
        // Calcul de l'incertitude globale
        assessment.overall_calibration_uncertainty = 
            calculate_overall_uncertainty(assessment);
        
        // Recommandation de r√©serves d'incertitude
        assessment.uncertainty_reserves_required = 
            (assessment.overall_calibration_uncertainty > 0.02); // 2% seuil
        
        return assessment;
    }
    
private:
    void test_calibration_target_sensitivity(
        const piv_auto_calibrator& calibrator,
        const std::vector<fx_option_market_quote>& market_quotes,
        calibration_uncertainty_assessment& assessment) {
        
        // Test de sensibilit√© au choix des cibles de calibration
        std::vector<std::vector<fx_option_market_quote>> alternative_target_sets = 
            generate_alternative_calibration_targets(market_quotes);
        
        auto base_calibration = calibrator.calibrate(market_quotes);
        
        for (size_t i = 0; i < alternative_target_sets.size(); ++i) {
            auto alt_calibration = calibrator.calibrate(alternative_target_sets[i]);
            
            // Mesure de la diff√©rence de calibration
            double calibration_difference = measure_calibration_difference(
                base_calibration, alt_calibration);
            
            std::string target_set_name = "ALT_TARGETS_" + std::to_string(i);
            assessment.calibration_target_sensitivities[target_set_name] = calibration_difference;
        }
    }
};
```

**Description :** La calibration PIV/Auto du mod√®le FXMarket est sensible au choix des cibles de calibration et aux param√®tres de la routine de calibration. Ce choix de cibles de calibration et la qualit√© de calibration ajoutent de l'incertitude √† l'√©valuation.

---

## üìã **Product-Limitation Mapping**

### **Connexion Produits-Limitations**

Le tableau suivant affiche la connexion entre les produits dans le scope et les limitations de mod√®le identifi√©es qui sont pertinentes pour les dictionnaires de pricing :

| **Product Name** | **707** | **1523** | **2742** | **4050** |
|------------------|---------|----------|----------|----------|
| **FXDigitalOpt** | | | | ‚úÖ |
| **FXEuroOpt** | | | | ‚úÖ |
| **FXGeometricBasketOpt** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| **FXNonDeliverableEuroOpt** | | | | ‚úÖ |

### **Impact par Produit**

#### **üîß FXDigitalOpt & FXEuroOpt**
- **Limitation 4050** : Sensibles √† l'incertitude de calibration PIV
- **Impact** : Mod√©r√© - Affecte principalement la pr√©cision du pricing

#### **üîß FXGeometricBasketOpt**
- **Toutes les limitations** : Produit le plus expos√© aux incertitudes
- **Impact** : √âlev√© - Cumul de toutes les sources d'incertitude

#### **üîß FXNonDeliverableEuroOpt**
- **Limitation 4050** : Sensible √† l'incertitude de calibration
- **Impact** : Mod√©r√© - Similar aux options vanilles

---

## üîß **Model Uncertainty Measurement and Management**

### **M√©thodologie d'Ajustement de Valorisation**

L'exigence d'une m√©thodologie d'ajustement de valorisation pour compenser une limitation de mod√®le doit √™tre √©tablie et impl√©ment√©e par VC/GSA.

#### **üîç Tableau de Gestion des Limitations**

| **Limitation ID** | **Reserve Policy** | **Limitation Assessed** | **RFU** | **Reserve MVR** |
|-------------------|-------------------|------------------------|---------|-----------------|
| **707** | NL-** | YES | TBD | Pending GSA submission |
| **1523** | NL-** | YES | TBD | Pending GSA submission |
| **2742** | NL-** | YES | TBD | Pending GSA submission |
| **4050** | NL-** | YES | TBD | Pending GSA submission |

### **Contr√¥les Compensatoires**

```cpp
// Framework de contr√¥les compensatoires dans Our project
class compensating_controls_framework {
public:
    struct control_assessment {
        std::map<std::string, bool> control_implemented;
        std::map<std::string, double> control_effectiveness;
        std::map<std::string, std::string> control_methodology;
        bool overall_control_adequate;
    };
    
    control_assessment assess_compensating_controls(
        const std::vector<model_limitation>& limitations) {
        
        control_assessment assessment;
        
        for (const auto& limitation : limitations) {
            // √âvaluation du contr√¥le pour chaque limitation
            bool control_exists = evaluate_control_existence(limitation);
            double effectiveness = measure_control_effectiveness(limitation);
            std::string methodology = get_control_methodology(limitation);
            
            std::string limitation_id = std::to_string(limitation.id);
            assessment.control_implemented[limitation_id] = control_exists;
            assessment.control_effectiveness[limitation_id] = effectiveness;
            assessment.control_methodology[limitation_id] = methodology;
        }
        
        // √âvaluation globale
        assessment.overall_control_adequate = evaluate_overall_control_adequacy(assessment);
        
        return assessment;
    }
    
private:
    bool evaluate_overall_control_adequacy(const control_assessment& assessment) {
        // Contr√¥les ad√©quats si tous les contr√¥les sont impl√©ment√©s 
        // et ont une efficacit√© > 80%
        for (const auto& [limitation_id, implemented] : assessment.control_implemented) {
            if (!implemented) return false;
            
            double effectiveness = assessment.control_effectiveness.at(limitation_id);
            if (effectiveness < 0.8) return false;
        }
        
        return true;
    }
};
```

### **Recommandations de Gestion**

#### **üéØ Actions Recommand√©es**

1. **Monitoring Continu** : Surveillance de l'incertitude entourant chaque limitation
2. **R√©serves d'Incertitude** : Calcul de r√©serves si jug√© n√©cessaire par GSA
3. **Benchmarking R√©gulier** : Comparaison avec mod√®les DBAnalytics alternatifs
4. **Am√©lioration Continue** : √âvaluation p√©riodique des limitations pour am√©lioration

#### **üîç Note Sp√©ciale**
La limitation 2605, pr√©c√©demment li√©e √† ce mod√®le, n'√©tait pertinente que pour le produit FXBasketOpt, qui est actuellement d√©sactiv√©. En cas de r√©activation du produit, la limitation 2605 devrait √™tre r√©tablie.

---

*Cette section fournit une analyse compl√®te de la gestion d'incertitude pour DBSMC-RateDeterministic_FXMarket, int√©grant les impl√©mentations C++ de Our project avec des m√©thodologies de mesure et contr√¥le des limitations identifi√©es.*
