# DBSMC - FX Market Models

## üìã **Vue d'Ensemble**

Le mod√®le **DBSMC-RateDeterministic_FXMarket** est un framework analytique ferm√© multi-devises qui assume que la dynamique des taux d'int√©r√™t domestiques et √©trangers est d√©terministe et que la dynamique du taux FX suit un processus lognormal dont la volatilit√© peut avoir une forme non-param√©trique (interpolation/extrapolation de surface de volatilit√©) ou param√©trique (SA4, LABGD).

---

## üéØ **Caract√©ristiques Principales**

### **Mod√®les Couverts**
- **DBSMC-RateDeterministic_FXMarket[AUTO]**
- **DBSMC-RateDeterministic_FXMarket**

### **Produits Support√©s**
- **FXEuroOpt** - Options europ√©ennes FX
- **FXDigitalOpt** - Options digitales FX
- **FXGeometricBasketOpt** - Options sur panier g√©om√©trique FX
- **FXNonDeliverableEuroOpt** - Options europ√©ennes non-livrables

### **Usages Approuv√©s**
- ‚úÖ **End of Day (EOD)** - √âvaluation et gestion des risques
- ‚úÖ **HistSim** - Simulations historiques
- ‚úÖ **CCAR** - Tests de stress r√©glementaires
- ‚úÖ **IRRBB** - Interest Rate Risk in Banking Book

---

## üèóÔ∏è **Architecture du Framework**

### **Approche Multi-Devises**
Le framework utilise une approche sophistiqu√©e de mod√©lisation FX :
- **Taux d√©terministes** pour les devises domestiques et √©trang√®res
- **Processus lognormal** pour les taux de change
- **Surfaces de volatilit√©** non-param√©triques ou param√©triques
- **Calibration PIV** automatique aux donn√©es de march√©

### **Composants Techniques**
```cpp
// Exemple d'impl√©mentation Black-Scholes FX dans Our project
class fx_black_scholes_pricer {
private:
    double domestic_rate_;
    double foreign_rate_;
    double fx_spot_;
    std::shared_ptr<fx_volatility_surface> vol_surface_;

public:
    fx_black_scholes_pricer(double dom_rate, double for_rate,
                           double fx_spot,
                           std::shared_ptr<fx_volatility_surface> vol_surface)
        : domestic_rate_(dom_rate), foreign_rate_(for_rate),
          fx_spot_(fx_spot), vol_surface_(vol_surface) {}

    double price_european_option(double strike, double expiry,
                                bool is_call, double notional) const {
        // Calcul du forward FX
        double forward = fx_spot_ * std::exp((domestic_rate_ - foreign_rate_) * expiry);

        // Volatilit√© interpol√©e
        double volatility = vol_surface_->get_volatility(strike, expiry);

        // Prix Black-Scholes
        double discount_factor = std::exp(-domestic_rate_ * expiry);

        return black_scholes::price(forward, strike, expiry, volatility,
                                  discount_factor * notional, is_call ? 1.0 : -1.0);
    }
};
```
*Cette impl√©mentation C++ dans Our project montre le pricing Black-Scholes FX avec taux d√©terministes et surface de volatilit√© interpol√©e.*

---

## üìä **√âvaluation des Risques**

### **Global Model Risk Assessment**

| Crit√®re | Rating | Justification |
|---------|--------|---------------|
| **Complexit√©** | LOW | Le mod√®le est analytique |
| **Incertitude** | LOW | Le mod√®le n'utilise aucun mod√®le feeder externe |
| **D√©pendance** | HIGH | Les mod√®les de pricing ont une d√©pendance √©lev√©e |

**Justifications :**
- **Complexit√© LOW** : Mod√®le analytique ferm√© avec formules Black-Scholes
- **Incertitude LOW** : Pas de source d'incertitude externe ou de mod√®le feeder
- **D√©pendance HIGH** : Les outputs d√©finissent les m√©triques officiellement report√©es

---

## üìö **Documentation D√©taill√©e**

```{toctree}
:maxdepth: 2
:caption: Documentation DBSMC

executive_summary
introduction_model_validation
theoretical_overview
independent_validation_testing
model_uncertainty_management
control_assessment
conclusion
document_change_history
product_testing_fxeuropt
product_testing_fxdigitalopt
product_testing_fxbasketopt
model_parameters_testing
```

### **Sections Principales**

#### **üìã Documentation Fondamentale**
- **[Executive Summary](executive_summary.md)** - R√©sum√© ex√©cutif et √©valuation globale des risques
- **[Introduction & Model Validation](introduction_model_validation.md)** - Scope, description des produits et m√©thodologie
- **[Theoretical Overview](theoretical_overview.md)** - Vue d'ensemble th√©orique et surfaces de volatilit√©

#### **üî¨ Tests et Validation**
- **[Independent Validation Testing](independent_validation_testing.md)** - Tests de validation ind√©pendants et frameworks r√©glementaires

#### **üìä Tests de Produits Sp√©cifiques**
- **[Product Testing: FXEuroOpt](product_testing_fxeuropt.md)** - Tests complets pour options europ√©ennes FX
- **[Product Testing: FXDigitalOpt](product_testing_fxdigitalopt.md)** - Tests complets pour options digitales FX
- **[Product Testing: FXBasketOpt](product_testing_fxbasketopt.md)** - Tests complets pour options sur panier FX

#### **üîß Tests de Param√®tres**
- **[Model Parameters Testing](model_parameters_testing.md)** - Tests d√©taill√©s des param√®tres de mod√®le

#### **üî¨ Gestion des Risques et Contr√¥les**
- **[Model Uncertainty Management](model_uncertainty_management.md)** - Identification, mesure et gestion des incertitudes du mod√®le
- **[Control Assessment](control_assessment.md)** - √âvaluation des contr√¥les, monitoring de performance et conditions d'utilisation
- **[Conclusion](conclusion.md)** - Approbation du mod√®le, tests de stress et revue annuelle
- **[Document Change History](document_change_history.md)** - Historique complet des changements et versions

---

## üîß **Impl√©mentation Technique Avanc√©e**

### **Moteur Black-Scholes FX Optimis√©**
Le framework utilise un moteur Black-Scholes sp√©cialis√© pour FX :

```cpp
// Moteur Black-Scholes FX optimis√© dans Our project
class fx_black_scholes_engine_optimized {
public:
    struct fx_option_parameters {
        double spot;
        double strike;
        double expiry;
        double domestic_rate;
        double foreign_rate;
        double volatility;
        bool is_call;
        double notional;
    };

    struct complete_option_metrics {
        double price;
        double delta;
        double gamma;
        double vega;
        double theta;
        double rho_domestic;
        double rho_foreign;
        double lambda; // Elasticity
        double vanna;  // Cross-gamma
        double volga;  // Vega convexity
    };

    static complete_option_metrics calculate_all_metrics(
        const fx_option_parameters& params) {

        complete_option_metrics metrics;

        // Calculs pr√©liminaires optimis√©s
        double forward = params.spot * std::exp(
            (params.domestic_rate - params.foreign_rate) * params.expiry);

        double sqrt_t = std::sqrt(params.expiry);
        double vol_sqrt_t = params.volatility * sqrt_t;
        double vol_squared_t = params.volatility * params.volatility * params.expiry;

        double d1 = (std::log(forward / params.strike) + 0.5 * vol_squared_t) / vol_sqrt_t;
        double d2 = d1 - vol_sqrt_t;

        double discount_factor = std::exp(-params.domestic_rate * params.expiry);

        // Fonctions de distribution normale (optimis√©es)
        double n_d1 = normal_cdf(d1);
        double n_d2 = normal_cdf(d2);
        double phi_d1 = normal_pdf(d1);
        double phi_d2 = normal_pdf(d2);

        // Prix
        if (params.is_call) {
            metrics.price = discount_factor * (forward * n_d1 - params.strike * n_d2);
        } else {
            metrics.price = discount_factor * (params.strike * (1.0 - n_d2) - forward * (1.0 - n_d1));
        }
        metrics.price *= params.notional;

        // Greeks de premier ordre
        metrics.delta = discount_factor * (params.is_call ? n_d1 : n_d1 - 1.0) * params.notional;

        metrics.vega = discount_factor * forward * phi_d1 * sqrt_t * params.notional;

        // Greeks de second ordre
        metrics.gamma = discount_factor * phi_d1 / (params.spot * vol_sqrt_t) * params.notional;

        // Theta
        double theta_vol_term = -discount_factor * forward * phi_d1 * params.volatility / (2.0 * sqrt_t);
        double theta_rate_term = params.domestic_rate * metrics.price;
        metrics.theta = (theta_vol_term + theta_rate_term) * params.notional;

        // Rhos
        metrics.rho_domestic = params.expiry * metrics.price;
        metrics.rho_foreign = -params.expiry * discount_factor * forward *
                             (params.is_call ? n_d1 : n_d1 - 1.0) * params.notional;

        // Greeks avanc√©s
        metrics.lambda = metrics.delta * params.spot / metrics.price; // Elasticity

        // Vanna (sensibilit√© crois√©e Delta/Vol)
        metrics.vanna = -discount_factor * phi_d1 * d2 / params.volatility * params.notional;

        // Volga (convexit√© Vega)
        metrics.volga = metrics.vega * d1 * d2 / params.volatility;

        return metrics;
    }

    // Pricing vectoris√© pour performance
    static std::vector<double> price_option_portfolio(
        const std::vector<fx_option_parameters>& portfolio) {

        std::vector<double> prices;
        prices.reserve(portfolio.size());

        // Optimisation vectorielle
        for (const auto& params : portfolio) {
            auto metrics = calculate_all_metrics(params);
            prices.push_back(metrics.price);
        }

        return prices;
    }
};
```
*Cette impl√©mentation C++ dans Our project montre un moteur Black-Scholes FX optimis√© avec calcul complet des Greeks et support vectoris√©.*

---

## üéØ **Avantages Techniques du Framework**

### **‚úÖ Pricing Analytique Haute Performance**
- **Formules ferm√©es** Black-Scholes pour performance optimale
- **Calcul vectoris√©** pour portfolios d'options
- **Cache intelligent** des surfaces de volatilit√©
- **Optimisations num√©riques** pour Greeks avanc√©s

### **‚úÖ Flexibilit√© des Surfaces de Volatilit√©**
- **Support multi-m√©thodes** : Interpolation, SA4, LABGD, SVI
- **S√©lection automatique** de la m√©thode optimale
- **Calibration robuste** aux donn√©es de march√©
- **Validation d'arbitrage** int√©gr√©e

### **‚úÖ Validation Exhaustive**
- **Tests analytiques** contre formules th√©oriques
- **Validation des Greeks** par diff√©rences finies
- **Put-call parity** avec pr√©cision machine
- **Tests de stabilit√©** sous stress extr√™me

---

## üìà **Cas d'Usage Sp√©cialis√©s**

### **Options Europ√©ennes Multi-Devises**
```cpp
// Exemple d'usage pour portfolio FX multi-devises dans Our project
class fx_portfolio_manager {
public:
    void price_multi_currency_portfolio() {
        // Configuration du portfolio
        std::vector<fx_option_specification> portfolio = {
            {"EURUSD", 1.10, 1.0, true, 1000000},   // EUR/USD Call
            {"GBPUSD", 1.25, 0.5, false, 500000},   // GBP/USD Put
            {"USDJPY", 110.0, 2.0, true, 100000000}, // USD/JPY Call
            {"AUDUSD", 0.75, 1.5, false, 2000000}   // AUD/USD Put
        };

        // Pricing avec corr√©lations FX
        auto portfolio_metrics = calculate_portfolio_metrics(portfolio);

        // Analyse des risques
        analyze_portfolio_fx_risks(portfolio_metrics);
    }
};
```

### **Gestion des Risques FX**
- **Delta hedging** automatique multi-devises
- **Gamma scalping** pour options courtes
- **Vega hedging** contre volatilit√©
- **Stress testing** r√©glementaire

---

## üîç **Surveillance et Contr√¥le Qualit√©**

### **Model Parameter Monitoring**
- **Surveillance automatis√©e** des param√®tres de volatilit√© via MARS
- **Alertes** sur d√©viations de calibration significatives
- **Validation continue** des surfaces de volatilit√©
- **Monitoring** de la stabilit√© des Greeks

### **Contr√¥les de Coh√©rence**
- **Tests de r√©plication** quotidiens pour options vanilles
- **Validation crois√©e** avec donn√©es de march√©
- **Monitoring des √©carts** de pricing vs benchmarks
- **Analyse des tendances** de volatilit√© FX

---

*Cette documentation compl√®te du framework DBSMC-RateDeterministic_FXMarket int√®gre les meilleures pratiques de Our project avec une validation rigoureuse et des impl√©mentations techniques avanc√©es pour le pricing analytique de d√©riv√©s FX.*
